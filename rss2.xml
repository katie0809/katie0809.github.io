<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Women&#39;s Techmaker</title>
    <link>https://katie0809.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 07 Apr 2022 05:22:11 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Google Analytics] 데이터 수집 및 처리</title>
      <link>https://katie0809.github.io/2022/04/06/ga-study2/</link>
      <guid>https://katie0809.github.io/2022/04/06/ga-study2/</guid>
      <pubDate>Wed, 06 Apr 2022 12:19:30 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;1-학습목표&quot;&gt;&lt;a href=&quot;#1-학습목표&quot; class=&quot;headerlink&quot; title=&quot;1. 학습목표&quot;&gt;&lt;/a&gt;1. 학습목표&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;비즈니스에 필요한 데이터 수집 원리 파악&lt;ul&gt;
&lt;li&gt;구글 애널리틱스 웹사이트 트래픽 측정 원리 외&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="1-학습목표"><a href="#1-학습목표" class="headerlink" title="1. 학습목표"></a>1. 학습목표</h2><ul><li>비즈니스에 필요한 데이터 수집 원리 파악<ul><li>구글 애널리틱스 웹사이트 트래픽 측정 원리 외</li></ul></li></ul><span id="more"></span>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2022/04/06/ga-study2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Google Analytics] Google Analytics for Beginners</title>
      <link>https://katie0809.github.io/2022/04/06/ga-study1/</link>
      <guid>https://katie0809.github.io/2022/04/06/ga-study1/</guid>
      <pubDate>Wed, 06 Apr 2022 08:47:15 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;analytics.google.com 의 Universal Analytics 강의내용 정리&lt;/li&gt;
&lt;li&gt;유니버셜 애널리틱스는 deprecate되었다. 실제로 구글 애널리틱스 계정 신규 생성하면 자동적으로 google analytics 4 사용하는 화면으로 들어가짐..&lt;/li&gt;
&lt;li&gt;그렇다면 왜 deprecate된 내용을 뒷북 공부하느냐.. 무료 skillshop lessons for GA4가 영 시원찮음ㅋㅋㅠ&lt;/li&gt;
&lt;li&gt;어차피 전반적인 개념은 동일하고 세부 스킬들만 추가된것일테니… 일단 universal analytics로 공부하는걸로&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-Overview-of-Google-Analytics-data-collection&quot;&gt;&lt;a href=&quot;#1-Overview-of-Google-Analytics-data-collection&quot; class=&quot;headerlink&quot; title=&quot;1. Overview of Google Analytics data collection&quot;&gt;&lt;/a&gt;1. Overview of Google Analytics data collection&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Tracking code 기반으로 사용자의 행동을 추적한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;페이지 로드될때마다&lt;/code&gt; tracking code가 사용자 행동에 대한 정보 갱신해서 보낸다.&lt;/li&gt;
&lt;li&gt;이러한 정보는 period of time을 기준으로 그룹화된다 =&amp;gt; &lt;code&gt;session&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;하나의 세션은 사용자가 구글 애널리틱스 추적코드가 포함된 페이지를 navigate하는 시점에 시작된다.&lt;ul&gt;
&lt;li&gt;세션은 30분간 활동이 없으면 종료된다.&lt;/li&gt;
&lt;li&gt;사용자가 세션 종료후에 행동 시작하면 새로운 세션 생성된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;특정 정보 제외시키는 필터 설정가능(특정 국가로부터의 정보만 받는다던가..)&lt;ul&gt;
&lt;li&gt;필터를 통해 걸러진 데이터는 복구 불가한 듯 하다. 한번 저장된 데이터는 변경불가하므로 나중에라도 사용할 가능성이 있는 데이터는 필터링하지 않도록 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li>analytics.google.com 의 Universal Analytics 강의내용 정리</li><li>유니버셜 애널리틱스는 deprecate되었다. 실제로 구글 애널리틱스 계정 신규 생성하면 자동적으로 google analytics 4 사용하는 화면으로 들어가짐..</li><li>그렇다면 왜 deprecate된 내용을 뒷북 공부하느냐.. 무료 skillshop lessons for GA4가 영 시원찮음ㅋㅋㅠ</li><li>어차피 전반적인 개념은 동일하고 세부 스킬들만 추가된것일테니… 일단 universal analytics로 공부하는걸로</li></ul><h2 id="1-Overview-of-Google-Analytics-data-collection"><a href="#1-Overview-of-Google-Analytics-data-collection" class="headerlink" title="1. Overview of Google Analytics data collection"></a>1. Overview of Google Analytics data collection</h2><ul><li>Tracking code 기반으로 사용자의 행동을 추적한다.</li><li><code>페이지 로드될때마다</code> tracking code가 사용자 행동에 대한 정보 갱신해서 보낸다.</li><li>이러한 정보는 period of time을 기준으로 그룹화된다 =&gt; <code>session</code></li><li>하나의 세션은 사용자가 구글 애널리틱스 추적코드가 포함된 페이지를 navigate하는 시점에 시작된다.<ul><li>세션은 30분간 활동이 없으면 종료된다.</li><li>사용자가 세션 종료후에 행동 시작하면 새로운 세션 생성된다.</li></ul></li><li>특정 정보 제외시키는 필터 설정가능(특정 국가로부터의 정보만 받는다던가..)<ul><li>필터를 통해 걸러진 데이터는 복구 불가한 듯 하다. 한번 저장된 데이터는 변경불가하므로 나중에라도 사용할 가능성이 있는 데이터는 필터링하지 않도록 한다.</li></ul></li></ul><span id="more"></span><h2 id="2-The-Analytics-account-structure"><a href="#2-The-Analytics-account-structure" class="headerlink" title="2. The Analytics account structure"></a>2. The Analytics account structure</h2><ul><li><p>구글애널리틱스 계정 구조</p></li><li><p>Organization =&gt; Account =&gt; Property =&gt; View</p><p><img src="https://lh3.googleusercontent.com/IkBB3dPv5myVGTXfqqUMy6KAX2y9KDMgLWHjBHqWFu29nZLrHYe2rwBPgJOAbQ=w720" alt=""></p></li><li><p><code>Property</code> : 별도의 <code>Tracking ID</code>를 사용해 각각의 개별적인 데이터를 수집할 수 있다.</p><ul><li>즉, 하나의 계정에서도 Tracking ID만 분리하면 각각 다른 웹사이트, 어플리케이션에서 데이터 수집할 수 있는것이다.</li></ul></li><li><p><code>View</code> : 보고서에 어떤 데이터를 포함할지 필터로 설정 =&gt; 뷰 만들어진다</p><ul><li>삭제시 복구 35일 이내에 진행하지 않으면 데이터 영구삭제됨</li></ul></li></ul><h2 id="3-Google-Analytics-interface"><a href="#3-Google-Analytics-interface" class="headerlink" title="3. Google Analytics interface"></a>3. Google Analytics interface</h2><h3 id="개요보고서-항목설명"><a href="#개요보고서-항목설명" class="headerlink" title="개요보고서 항목설명"></a>개요보고서 항목설명</h3><ul><li>세션수 : 지정된 기간에 발생한 총 세션수</li><li>사용자 : 지정된 기간동안 사이트에서 세션을 한 번 이상 실행한 개인</li><li>페이지뷰 : 추적코드 포함된 페이지가 사용자에게 표시된 총 횟수<ul><li>같은 사용자가 한 페이지 반복 조회시 반복조회 횟수 모두 포함됨</li></ul></li><li>세션당 페이지 : 각 세션동안 조회된 평균 페이지수.<ul><li>마찬가지로 중복조회 횟수에 포함된다.</li></ul></li><li>평균세션시간 : 지정된 기간동안 사이트 방문한 사용자 기준으로 하나의 세션 평균길이</li><li>이탈율 : 한 페이지를 조회한 후 추가액션 없이 사이트 떠난 사용자 비율(사이트 도달후 상호작용 없이 이탈한 방문의 비율)</li></ul><h3 id="측정항목-Metrics-측정기준-Demension"><a href="#측정항목-Metrics-측정기준-Demension" class="headerlink" title="측정항목(Metrics) / 측정기준(Demension)"></a>측정항목(Metrics) / 측정기준(Demension)</h3><ul><li>측정항목 : 실제 수치데이터</li><li>측정기준 : 측정항목의 수치데이터를 특정 기준으로 구성가능하도록 하는 속성(Attribute of an dataset that can be organized in order to do better analysis)</li></ul><h3 id="전체보고서-항목설명"><a href="#전체보고서-항목설명" class="headerlink" title="전체보고서 항목설명"></a>전체보고서 항목설명</h3><ul><li>표 제일 왼쪽 컬럼 : 1차 측정기준(=primary demension). 수집된 데이터(=metrics =측정항목)(Users, New Users, Sessions 등..)를 측정기준에 따라 보여준다.<ul><li>Secondary demension을 추가해서 데이터를 더 상세히 보자</li><li>즉, <code>Country</code>라는 측정기준에 <code>os</code> 라는 측정기준 추가하면 ‘한국 &amp;&amp; 안드로이드’인 세션, ‘한국 &amp;&amp; ios’인 세션 이렇게 세부적으로 데이터 볼 수 있는것</li><li>우측상단 Search box 활용해서 측정기준 필터링해서 특정 표만 보이도록 할수있다</li></ul></li></ul><h2 id="4-기본보고서"><a href="#4-기본보고서" class="headerlink" title="4. 기본보고서"></a>4. 기본보고서</h2><h3 id="잠재고객-보고서"><a href="#잠재고객-보고서" class="headerlink" title="잠재고객 보고서"></a>잠재고객 보고서</h3><ul><li><code>활성사용자</code> : 지정된 기간동안 1개 이상의 세션을 실행한 사용자 수</li><li><code>Demographics</code> : 사용자의 나이, 성별 통계 제공</li><li><code>Behavior</code> : 신규 사용자와 재사용자 통계 제공</li></ul><h3 id="획득-보고서-where-to-focus-your-marketing-effort"><a href="#획득-보고서-where-to-focus-your-marketing-effort" class="headerlink" title="획득 보고서(where to focus your marketing effort)"></a>획득 보고서(where to focus your marketing effort)</h3><ul><li>사용자가 사이트 들어오면 GA 추적코드는 자동적으로 사용자의 경로에 대한 정보 추적<ul><li>traffic medium, source, marketing campaign name등..</li><li>즉, 이 정보 활용해서 어떤 마케팅, 어떤 플랫폼이 실제 효용을 보이는지 분석 가능하다</li></ul></li><li>웹사이트에 도달하는 경로에 대한 통계 제공<ul><li>특정 경로 통해 들어온 사용자의 이탈률이 낮다면 해당 소스 통한 트래픽 품질이 우수하다고 추측할 수 있다.</li><li>품질이 우수하다 = 사용자가 원하는 highly relative page로 잘 연결되고 있다.</li></ul></li></ul><h3 id="방문형태-보고서"><a href="#방문형태-보고서" class="headerlink" title="방문형태 보고서"></a>방문형태 보고서</h3><ul><li>사용자가 웹사이트에서 페이지 로드할 때마다 GA tracking code는 <code>pageview</code> 생성해서 리포트한다.<ul><li>GA는 이 페이지뷰 활용해 여러 metrics생성.</li></ul></li><li><code>Total pageview</code> : 사용자가 로드한 페이지뷰 단순 합산(Sum of each time a user laded a page on your website)</li><li><code>All pages</code> : 웹사이트의 각 페이지에 대한 페이지뷰(How frequently each page on your site was viewed)<ul><li>디폴트로 페이지 URI기준으로 데이터 보여준다</li><li><code>page title</code> 기준으로 볼 수 있다 =&gt; 이때 타이틀은 웹페이지 html의 title영역의 데이터 의미</li></ul></li><li><code>Content drilldown</code> : 페이지를 directory structure에 따라 그룹화한다.</li><li><code>Landing pages</code> : 사용자가 처음으로 진입한 페이지 통계 제공</li><li><code>Exit pages</code> : 사용자가 최종적으로 사이트에서 이탈한 페이지 통계 제공</li><li><code>Events</code> : How the users <u>interact with specific elements</u> of your website<ul><li>특정 버튼 클릭 등의 이벤트를 추적할 수 있다 =&gt; 별도 구현 필요</li></ul></li></ul><h2 id="5-기본-캠페인-전환-및-추적"><a href="#5-기본-캠페인-전환-및-추적" class="headerlink" title="5. 기본 캠페인 전환 및 추적"></a>5. 기본 캠페인 전환 및 추적</h2><ul><li>마케팅 캠페인은 ‘캠페인 태그 추가’를 통해 추적할 수 있다.</li><li><code>Campaign tags</code> : URL링크에 추가하는 extra bits of information. <ul><li>추가적인 url 파라미터로 삽입하는 듯.</li><li>필수 태그 : Medium(cpc, email..), source(google/bing/yahoo, newsletter..), campaign(name of marketing)</li><li>추가 태그 : Content(versions of your promotion), term(keyword for paid search campaign)</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2022/04/06/ga-study1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo, Icarus 업데이트하기</title>
      <link>https://katie0809.github.io/2021/10/25/update-hexo-icarus/</link>
      <guid>https://katie0809.github.io/2021/10/25/update-hexo-icarus/</guid>
      <pubDate>Mon, 25 Oct 2021 14:44:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;오랜만에 블로그 글을 쓰려하니 &lt;code&gt;TypeError [ERR_INVALID_ARG_TYPE]: The &amp;quot;mode&amp;quot; argument must be integer. Received an instance of Object&lt;/code&gt; 오류가 발생했다. 노드 버전을 낮추면 해결된다는 얘기가 있긴 했는데 굳이 그러고 싶지 않아서 hexo 버전을 업그레이드 하기로 결심.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>오랜만에 블로그 글을 쓰려하니 <code>TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object</code> 오류가 발생했다. 노드 버전을 낮추면 해결된다는 얘기가 있긴 했는데 굳이 그러고 싶지 않아서 hexo 버전을 업그레이드 하기로 결심.</p><span id="more"></span><ul><li>참고한 블로그 =&gt; <a href="https://skyksit.com/hexo/hexo-version-upgrade/">https://skyksit.com/hexo/hexo-version-upgrade/</a></li></ul><p>hexo를 4.2.0에서 5.4.0으로 버전업했지만 위의 에러가 여전히 발생했다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object</span><br><span class="line">      at copyFile (fs.js:1972:10)</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결국 아래의 블로그를 참고해서 노드 버전을 13.14.0으로 내렸다.</p><ul><li><a href="https://zhuanlan.zhihu.com/p/351536372">https://zhuanlan.zhihu.com/p/351536372</a></li></ul><p>그러자 이번엔 git 인증 문제가 발생</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br><span class="line">remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.</span><br><span class="line">fatal: Authentication failed for &#x27;https://github.com/katie0809/katie0809.github.io/&#x27;</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; </span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>github에서 더이상 아이디/비밀번호 기반 인증을 지원해주지 않는다고 한다. 깃헙 본인 계정에서 사용 가능한 access token을 발급받아 push시에 password 항목에 발급한 토큰을 넣는다. 아래 문서 참조.</p><ul><li><a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token</a></li></ul><p>그러자 이번엔.. 새 문제가 생겼다 와우! icarus에서 아래와 같은 에러를 뿜어낸다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ERROR ReferenceError: .../blog-backup/themes/icarus/layout/tag.ejs:11</span><br><span class="line">    9|     &lt;/div&gt;</span><br><span class="line">    10| &lt;/div&gt;</span><br><span class="line"> &gt;&gt; 11| &lt;%- _partial(&#x27;index&#x27;, &#123; page &#125;) %&gt;</span><br><span class="line"></span><br><span class="line">_partial is not defined</span><br></pre></td></tr></table></figure><p>뭐 이런식의 오류를 미친듯이 뿜어낸다. 다시 구글링을 해보니 최신 hexo와 구버전 icarus의 호환문제인 듯 싶었다.</p><ul><li><a href="https://aaronryu.github.io/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/">https://aaronryu.github.io/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/</a></li></ul><p>어쩔수없이 icarus도 업데이트 하기로 결심. </p><h2 id="기존-theme-백업-새-icarus-설치"><a href="#기존-theme-백업-새-icarus-설치" class="headerlink" title="기존 theme 백업, 새 icarus 설치"></a>기존 theme 백업, 새 icarus 설치</h2><ul><li>기존에는 icarus 깃 레포를 fork해와 내 블로그 글 백업 레포의 theme 밑에 submodule로 두고 각각 관리했다. 그런데 새 icarus는 npm으로 설치가 가능하다고 하니 일단 기존 폴더를 지우고 다시 설치했다.</li><li>.gitmodule에서 submodule “theme/icarus” 이쪽을 삭제해준다.</li><li>icarus 최신 테마를 설치한다. 다음 글을 참고했다. <a href="https://skyksit.com/hexo/hexo-icarus-theme/">https://skyksit.com/hexo/hexo-icarus-theme/</a><ul><li>참고로 hexo config를 사용하려면 관련된 이것저것들을 설치해줘야 했다.</li><li>hexo-renderer-inferno, hexo-renderer-stylus같은..</li></ul></li></ul><h2 id="icarus-커스텀-설정하기"><a href="#icarus-커스텀-설정하기" class="headerlink" title="icarus 커스텀 설정하기"></a>icarus 커스텀 설정하기</h2><ul><li>기존에 사용했던 아이콘, 이미지, 댓글창 등 여러가지 설정들이 다 지워진 상태이므로 기존 테마 폴더의 설정파일을 참고해서 새 icarus를 설정해준다.</li><li>기존에도 icarus의 설정은 _config.yml에서 진행했다. 새 버전의 icarus설정은 _config.icarus.yml에서 해주면 된다.<ul><li>기존 icarus의 설정과 유사하므로 하나씩 보면서 기존설정을 수동으로 옮겨주면 된다.</li></ul></li><li>아이콘 이미지같이 테마 기본 리소스를 바꾸고 싶으면 node-modules/hexo-theme-icarus 하위에서 작업하면 된다. 예를들어 아이콘 이미지의 /img/icon.svg는 ../node_modules/hexo-theme-icarus/img/icon.svg 를 의미한다.</li><li>추가설정에 참고할만한 사이트들<ul><li><a href="https://skyksit.com/categories/Hexo/page/2/">https://skyksit.com/categories/Hexo/page/2/</a></li><li><a href="https://heowc.dev/2018/11/14/introduction-hexo-tag-gdemo/">https://heowc.dev/2018/11/14/introduction-hexo-tag-gdemo/</a></li><li><a href="https://github.com/tea3/hexo-related-popular-posts">https://github.com/tea3/hexo-related-popular-posts</a></li><li><a href="https://karobben.github.io/2021/02/11/Blog/hexo_icarus/">https://karobben.github.io/2021/02/11/Blog/hexo_icarus/</a></li></ul></li></ul><h2 id="기타-설정"><a href="#기타-설정" class="headerlink" title="기타 설정"></a>기타 설정</h2><ul><li>기본 위젯명이 바뀌었다. <code>category</code> -&gt; <code>categories</code> , <code>tagcloud</code> -&gt; <code>tags</code></li><li>바뀐 위젯명에 맞춰 기존 발행된 포스트의 위젯명을 모두 바꿔줬다.</li><li>각 포스트의 설정 키값도 몇개 바뀌었다.<ul><li>예를들어  <code>thumbnail</code>은  <code>cover</code>와 <code>thumbnail</code>로 나뉘어졌다.</li><li>기존처럼 포스트의 제목 상단에 그림을 넣고싶으면 cover 로 넣어줘야 한다.</li><li>최근 글 등에 말그대로 썸네일로 보여주고 싶으면 thumbnail에 넣어줘야 한다.</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2021/10/25/update-hexo-icarus/#disqus_thread</comments>
    </item>
    
    <item>
      <title>네이버 코딩테스트 후기</title>
      <link>https://katie0809.github.io/2021/10/25/codility8/</link>
      <guid>https://katie0809.github.io/2021/10/25/codility8/</guid>
      <pubDate>Mon, 25 Oct 2021 04:09:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;네이버 월간영입 코딩테스트 후기. 테스트는 Codility 플랫폼에서 진행됐다. 총 3문제, 160분이었다. 테스트는 온라인 비대면으로 진행됐으며 서류합격발표(화요일) 후 해당 주 일요일 밤까지가 테스트 마감 기한이었다.&lt;/p&gt;
&lt;p&gt;문제는 모두 영어로 출제됐고 codility의 다른 lesson questions보다는 테스트 케이스가 나름 다양하게(?) 주어졌다. 문제당 기본 3-4개정도.. 난이도는 중 정도였다. 올해 치뤘던 카카오, SK 코테와 비교해보면 제일 어렵긴 했다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>네이버 월간영입 코딩테스트 후기. 테스트는 Codility 플랫폼에서 진행됐다. 총 3문제, 160분이었다. 테스트는 온라인 비대면으로 진행됐으며 서류합격발표(화요일) 후 해당 주 일요일 밤까지가 테스트 마감 기한이었다.</p><p>문제는 모두 영어로 출제됐고 codility의 다른 lesson questions보다는 테스트 케이스가 나름 다양하게(?) 주어졌다. 문제당 기본 3-4개정도.. 난이도는 중 정도였다. 올해 치뤘던 카카오, SK 코테와 비교해보면 제일 어렵긴 했다.</p><span id="more"></span><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><h3 id="문제설명"><a href="#문제설명" class="headerlink" title="[문제설명]"></a>[문제설명]</h3><ul><li>문자열 S와 이름 배열 L이 주어진다.</li><li>문자열 S의 문자들로 주어진 배열의 각 이름을 몇개나 만들 수 있을지 세어보고 최대 제작가능 횟수를 반환한다.</li><li>S=LILLYBILLYBOO, L=[‘BILL’, ‘MARIA’, ‘LILLY’] 일때 BILL은 2번, MARIA는 0번, LILLY는 1번 만들 수 있다. 따라서 2를 반환해야 한다.</li></ul><h3 id="풀이"><a href="#풀이" class="headerlink" title="[풀이]"></a>[풀이]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solutionTask1</span>(<span class="params">S, L</span>):</span></span><br><span class="line">    scnt = <span class="built_in">dict</span>()</span><br><span class="line">    maxret = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> S:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> scnt.keys():</span><br><span class="line">            scnt[s] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            scnt[s] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(scnt)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> L:</span><br><span class="line">        ncnt = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> name:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> ncnt.keys():</span><br><span class="line">                ncnt[c] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ncnt[c] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(name, ncnt)</span></span><br><span class="line"></span><br><span class="line">        curret = <span class="number">999</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> ncnt.keys():</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> scnt.keys():</span><br><span class="line">                curret = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(key, scnt[key], ncnt[key], curret, scnt[key] // ncnt[key])</span></span><br><span class="line">            curret = <span class="built_in">min</span>(curret, scnt[key] // ncnt[key])</span><br><span class="line"></span><br><span class="line">        maxret = <span class="built_in">max</span>(maxret, curret)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxret</span><br></pre></td></tr></table></figure><ul><li>부분합 알고리즘에서 사용했던 개념을 일부 사용했다</li></ul><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><h3 id="문제설명-1"><a href="#문제설명-1" class="headerlink" title="[문제설명]"></a>[문제설명]</h3><ul><li>배열 A와 기준 R이 주어진다.</li><li>배열 A에서 R 길이만큼을 빼고 남은 값들의 종류의 개수가 최대가 되는 경우를 찾아, 그 종류의 개수를 반환하라</li><li>배열의 순서는 바꿀 수 없다. A의 길이는 최대 10만. 배열의 원소 값도 최대 10만이었던걸로 기억한다.</li><li>A=[2, 3, 1, 4, 2, 2], R=3 일때 [4, 2, 2]를 빼면 남은 값의 종류의 개수가 3으로 최대가 된다.</li></ul><h3 id="풀이1"><a href="#풀이1" class="headerlink" title="[풀이1]"></a>[풀이1]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solutionTask2</span>(<span class="params">A, R</span>):</span></span><br><span class="line">    <span class="comment"># 가장 종류 적은 부분 R을 찾는다</span></span><br><span class="line">    minidx, minuniq = <span class="number">0</span>, <span class="number">2e9</span></span><br><span class="line">    curcnt = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 초기값</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> A[:R]:</span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> curcnt.keys():</span><br><span class="line">            curcnt[a] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curcnt[a] += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(curcnt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 배열 순회하며 가짓수가 최소가 되는 start idx(minidx) 찾는다</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A) - R):</span><br><span class="line">        curuniq = <span class="built_in">len</span>(<span class="built_in">list</span>(curcnt.keys()))</span><br><span class="line">        <span class="keyword">if</span> curuniq &lt; minuniq:</span><br><span class="line">            minuniq = curuniq</span><br><span class="line">            minidx = i</span><br><span class="line">        <span class="built_in">print</span>(i, curuniq, minuniq)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># R개 부분의 가짓수 저장 dict 업데이트</span></span><br><span class="line">        curkey, nextkey = A[i], A[R + i]</span><br><span class="line">        <span class="keyword">if</span> curcnt[curkey] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">del</span> curcnt[curkey]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curcnt[curkey] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nextkey <span class="keyword">not</span> <span class="keyword">in</span> curcnt.keys():</span><br><span class="line">            curcnt[nextkey] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curcnt[nextkey] += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(curkey, nextkey, curcnt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> A[minidx:minidx + R]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(A)))</span><br></pre></td></tr></table></figure><ul><li>처음엔 값의 종류가 가장 적은 R길이의 부분배열을 찾으면 될거라고 생각했다. </li><li>이경우 예외케이스가 생긴다. A=[2, 3, 1, 1, 2], R=2 일때 [1, 1]을 빼는 것 보다 [1,2] 를 빼는게 남은 원소의 종류의 개수 더 많기 때문.</li></ul><h3 id="풀이2"><a href="#풀이2" class="headerlink" title="[풀이2]"></a>[풀이2]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solutionTask222</span>(<span class="params">A, R</span>):</span></span><br><span class="line">    maxcnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> startidx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-R):</span><br><span class="line">        curcnt = <span class="built_in">len</span>(<span class="built_in">set</span>(A[:startidx]+A[startidx+R:]))</span><br><span class="line">        maxcnt = <span class="built_in">max</span>(maxcnt, curcnt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxcnt</span><br></pre></td></tr></table></figure><ul><li>시간이 얼마 안남아서 어쩔 수 없었다</li><li>알고리즘 없이 그냥 전체탐색.. tc는 모두 맞았지만 large testset 에서 백퍼 timeout 발생할거라고 예상된다.</li></ul><h2 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h2><h3 id="문제설명-2"><a href="#문제설명-2" class="headerlink" title="[문제설명]"></a>[문제설명]</h3><ul><li><p>N * M 의 지도 B가 주어진다. 지도의 각 셀은 # 혹은 . 로 표현된다.</p></li><li><p>지도에는 patrol, submarine, destroyers라는 세가지 타입의 배가 #로 표시되어있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Patrol</span><br><span class="line">=&gt; #</span><br><span class="line">2. Submarine</span><br><span class="line">=&gt; ##, #</span><br><span class="line">       #</span><br><span class="line">3. Destroyers</span><br><span class="line">=&gt; ###, ##, ##, #  ,  #  , #</span><br><span class="line">        #    #  ##   ##    #</span><br><span class="line">                           #</span><br></pre></td></tr></table></figure></li><li><p>‘.’ 은 빈 공간을 의미한다.</p></li><li><p>지도에서 patrol, submarine, destroyers의 갯수를 각각 세서 반환한다.</p></li><li><p>B=[‘.#..#’, ‘##..#’, ‘…#.’] 일때 [1, 1, 1]을 반환한다.</p></li></ul><h3 id="풀이-1"><a href="#풀이-1" class="headerlink" title="[풀이]"></a>[풀이]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">destroyers = [</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">0</span>]],</span><br><span class="line">    [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>]],</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]],</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [[<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isD</span>(<span class="params">B, a, b, M, N</span>):</span></span><br><span class="line">    whichShape = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">id</span>, shape <span class="keyword">in</span> <span class="built_in">enumerate</span>(destroyers):</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> addA, addB <span class="keyword">in</span> shape:</span><br><span class="line">            <span class="keyword">if</span> a + addA &lt; <span class="number">0</span> <span class="keyword">or</span> b + addB &lt; <span class="number">0</span> <span class="keyword">or</span> a + addA &gt;= N <span class="keyword">or</span> b + addB &gt;= M <span class="keyword">or</span> B[a + addA][b + addB] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">            whichShape = <span class="built_in">id</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> whichShape</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printB</span>(<span class="params">B</span>):</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> B:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">B</span>):</span></span><br><span class="line">    N, M = <span class="built_in">len</span>(B), <span class="built_in">len</span>(B[<span class="number">0</span>])</span><br><span class="line">    ret = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    B = <span class="built_in">list</span>(<span class="built_in">list</span>(col) <span class="keyword">for</span> col <span class="keyword">in</span> B)</span><br><span class="line">    <span class="keyword">for</span> a, col <span class="keyword">in</span> <span class="built_in">enumerate</span>(B):</span><br><span class="line">        <span class="keyword">for</span> b, cell <span class="keyword">in</span> <span class="built_in">enumerate</span>(col):</span><br><span class="line">            <span class="built_in">print</span>(a, b, cell)</span><br><span class="line">            printB(B)</span><br><span class="line">            <span class="keyword">if</span> cell == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="comment"># 어떤 모양인지 체크한다.</span></span><br><span class="line">                di = isD(B, a, b, M, N)</span><br><span class="line">                <span class="keyword">if</span> di &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># Destroyer인 경우</span></span><br><span class="line">                    B[a][b] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    B[a + destroyers[di][<span class="number">0</span>][<span class="number">0</span>]][b + destroyers[di][<span class="number">0</span>][<span class="number">1</span>]] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    B[a + destroyers[di][<span class="number">1</span>][<span class="number">0</span>]][b + destroyers[di][<span class="number">1</span>][<span class="number">1</span>]] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">                    ret[<span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> a + <span class="number">1</span> &lt; N <span class="keyword">and</span> B[a + <span class="number">1</span>][b] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                        <span class="comment"># Submarine shape1</span></span><br><span class="line">                        B[a][b] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                        B[a + <span class="number">1</span>][b] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">                        ret[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> b + <span class="number">1</span> &lt; M <span class="keyword">and</span> B[a][b + <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                        <span class="comment"># Submarine shape2</span></span><br><span class="line">                        B[a][b] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                        B[a][b + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">                        ret[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># Patrol</span></span><br><span class="line">                        B[a][b] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                        ret[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>좌측 상단부터 훑어가면서 # 인경우 세가지 배 중 어느타입에 속하는지 확인후 해당 셀을 ‘.’ 으로 바꾼다.</p><ul><li>string 문자열은 인덱스로 접근해 값 할당할 수 없으므로 초반에 받아온 문자열 배열을 리스트로 변환해준다.</li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2021/10/25/codility8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 w Python - (6) Prefix Sums, Sorting</title>
      <link>https://katie0809.github.io/2021/10/23/codility7/</link>
      <guid>https://katie0809.github.io/2021/10/23/codility7/</guid>
      <pubDate>Sat, 23 Oct 2021 08:03:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;구간합 알고리즘, 정렬 알고리즘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;설명 : &lt;a href=&quot;https://www.crocus.co.kr/843&quot;&gt;https://www.crocus.co.kr/843&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;부분합&lt;/code&gt;&lt;/strong&gt; : 길이 N의 배열에서 0 ~ k 까지의 합(0 &amp;lt;= k &amp;lt; N)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;구간합&lt;/code&gt;&lt;/strong&gt; : 길이 N의 배열에서 a ~ b 까지의 합(0 &amp;lt;= a &amp;lt;= b &amp;lt; N)&lt;/p&gt;
&lt;p&gt;배열을 순회하면서 인덱스 i까지의 합을 저장한 sum 배열을 계산한다.&lt;/p&gt;
&lt;p&gt;a ~ b까지의 구간합은 sum[b] - sum[a] 이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>구간합 알고리즘, 정렬 알고리즘</p><ul><li>설명 : <a href="https://www.crocus.co.kr/843">https://www.crocus.co.kr/843</a></li></ul><p><strong><code>부분합</code></strong> : 길이 N의 배열에서 0 ~ k 까지의 합(0 &lt;= k &lt; N)</p><p><strong><code>구간합</code></strong> : 길이 N의 배열에서 a ~ b 까지의 합(0 &lt;= a &lt;= b &lt; N)</p><p>배열을 순회하면서 인덱스 i까지의 합을 저장한 sum 배열을 계산한다.</p><p>a ~ b까지의 구간합은 sum[b] - sum[a] 이다.</p><span id="more"></span><h2 id="Q1-GenomicRangeQuery"><a href="#Q1-GenomicRangeQuery" class="headerlink" title="Q1. GenomicRangeQuery"></a>Q1. GenomicRangeQuery</h2><ul><li>문자열 S(길이 N)와 숫자배열 P,Q(길이 M)가 주어진다</li><li>문자열 S는 다음 4가지 문자로 이루어져 있다 : A, C, G, T</li><li>각 문자는 각각 1, 2, 3, 4의 숫자(=Impact Factor)와 대응된다</li><li>find the minimal impact factor of nucleotides contained in the DNA sequence between positions P[K] and Q[K] (inclusive).</li><li>숫자배열 P, Q는 각각 start index, end index를 의미한다. S[P[i]] ~ S[Q[i]] 사이의 문자들의 impact factor 중 최소값을 반환하라.</li></ul><h3 id="Try-1-https-app-codility-com-demo-results-trainingNCDUH8-QZA-66"><a href="#Try-1-https-app-codility-com-demo-results-trainingNCDUH8-QZA-66" class="headerlink" title="Try 1: https://app.codility.com/demo/results/trainingNCDUH8-QZA/ (66%)"></a>Try 1: <a href="https://app.codility.com/demo/results/trainingNCDUH8-QZA/">https://app.codility.com/demo/results/trainingNCDUH8-QZA/</a> (66%)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line">ip = &#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;G&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;T&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">S, P, Q</span>):</span></span><br><span class="line">    ret = []</span><br><span class="line">    N, M = <span class="built_in">len</span>(S), <span class="built_in">len</span>(P)</span><br><span class="line">    counter = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">    <span class="keyword">for</span> idx, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(S):</span><br><span class="line">        counter[idx] = deepcopy(counter[idx-<span class="number">1</span>])</span><br><span class="line">        counter[idx][ip[c]-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(counter)</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        start, end = P[idx], Q[idx]</span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            ret.append(ip[S[start]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="comment"># print(idx, counter[end][i], counter[end][i])</span></span><br><span class="line">                <span class="keyword">if</span> counter[end][i] - counter[start][i] &gt; <span class="number">0</span>:</span><br><span class="line">                    ret.append(i+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p><strong><code>POINT</code></strong> 문자를 순회하면서 각 문자별로 A, C, G, T가 등장했던 횟수를 저장한다. 등장했던 횟수의 차를 구해서 1번 이상 등장한 minimal impactor를 찾는다.</p><ul><li><p>Analysis summary</p><p>The following issues have been detected: wrong answers, timeout errors.</p><p>For example, for the input <code>(&#39;AC&#39;, [0, 0, 1], [0, 1, 1])</code> the solution returned a wrong answer (got [1, 2, 2] expected [1, 1, 2]).</p></li></ul><h3 id="Try-2-https-app-codility-com-demo-results-trainingJY9PSW-EVA-87"><a href="#Try-2-https-app-codility-com-demo-results-trainingJY9PSW-EVA-87" class="headerlink" title="Try 2: https://app.codility.com/demo/results/trainingJY9PSW-EVA/ (87%)"></a>Try 2: <a href="https://app.codility.com/demo/results/trainingJY9PSW-EVA/">https://app.codility.com/demo/results/trainingJY9PSW-EVA/</a> (87%)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line">ip = &#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;G&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;T&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">S, P, Q</span>):</span></span><br><span class="line">    ret = []</span><br><span class="line">    N, M = <span class="built_in">len</span>(S), <span class="built_in">len</span>(P)</span><br><span class="line">    counter = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">    <span class="keyword">for</span> idx, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(S):</span><br><span class="line">        counter[idx] = deepcopy(counter[idx-<span class="number">1</span>])</span><br><span class="line">        counter[idx][ip[c]-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(ip.values().index(0))</span></span><br><span class="line">    counter.append([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        start, end = P[idx]-<span class="number">1</span>, Q[idx]</span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            ret.append(ip[S[start]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> counter[end][i] - counter[start][i] &gt; <span class="number">0</span>:</span><br><span class="line">                    ret.append(i+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><ul><li>Almost all same letters 케이스에서 Timeout 발생</li></ul><h2 id="Q2-Distinct"><a href="#Q2-Distinct" class="headerlink" title="Q2. Distinct"></a>Q2. Distinct</h2><p><a href="https://app.codility.com/demo/results/trainingN5Y9M2-Z67/">https://app.codility.com/demo/results/trainingN5Y9M2-Z67/</a></p><ul><li>N개의 원소로 이루어진 배열 A</li><li>배열 A의 원소 종류의 개수를 반환하라</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(A))</span><br></pre></td></tr></table></figure><ul><li>시간 복잡도 : <strong>O(N*log(N)) or O(N)</strong></li></ul><p><strong><code>POINT</code></strong> 파이썬 리스트 중복제거하기 : <a href="https://blockdmask.tistory.com/543">https://blockdmask.tistory.com/543</a></p><h2 id="Q3-MaxProductOfThree"><a href="#Q3-MaxProductOfThree" class="headerlink" title="Q3. MaxProductOfThree"></a>Q3. MaxProductOfThree</h2><ul><li>길이 N(3 ~ 100,000)의 배열 A</li><li>원소 3개를 곱해서 값이 최대가 되게 하라</li></ul><h3 id="Try-1-https-app-codility-com-demo-results-trainingGYUQBS-SBY-44"><a href="#Try-1-https-app-codility-com-demo-results-trainingGYUQBS-SBY-44" class="headerlink" title="Try 1: https://app.codility.com/demo/results/trainingGYUQBS-SBY/ (44%)"></a>Try 1: <a href="https://app.codility.com/demo/results/trainingGYUQBS-SBY/">https://app.codility.com/demo/results/trainingGYUQBS-SBY/</a> (44%)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    A.sort()</span><br><span class="line">    <span class="keyword">return</span> A[-<span class="number">1</span>]*A[-<span class="number">2</span>]*A[-<span class="number">3</span>]</span><br></pre></td></tr></table></figure><ul><li>단순히 정렬해서 제일 큰 3개를 곱해서 반환</li><li>당연히 답이 아녔다</li><li>음수가 존재할 수 있으므로 음수 * 음수 * 양수 의 케이스로 최대값이 될 수 있다</li></ul><h3 id="Try-2-https-app-codility-com-demo-results-training7RGBFS-7K8-100"><a href="#Try-2-https-app-codility-com-demo-results-training7RGBFS-7K8-100" class="headerlink" title="Try 2: https://app.codility.com/demo/results/training7RGBFS-7K8/ (100%)"></a>Try 2: <a href="https://app.codility.com/demo/results/training7RGBFS-7K8/">https://app.codility.com/demo/results/training7RGBFS-7K8/</a> (100%)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    A.sort()</span><br><span class="line">    <span class="keyword">if</span> A[<span class="number">0</span>] &lt; <span class="number">0</span> <span class="keyword">and</span> A[<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(A[<span class="number">0</span>]*A[<span class="number">1</span>]*A[-<span class="number">1</span>], A[-<span class="number">1</span>]*A[-<span class="number">2</span>]*A[-<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> A[-<span class="number">1</span>]*A[-<span class="number">2</span>]*A[-<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="Q4-Triangle"><a href="#Q4-Triangle" class="headerlink" title="Q4. Triangle"></a>Q4. Triangle</h2><p><a href="https://app.codility.com/demo/results/trainingNGU2KK-WYV/">https://app.codility.com/demo/results/trainingNGU2KK-WYV/</a></p><ul><li>3개의 값 a,b,c에 대해 a+b &gt; c, b+c &gt; a, a+c &gt; b 이면 값 a,b,c는 triangular 하다고 한다.</li><li>주어진 길이 N(3 ~ 100,000)의 배열 A에 대해 triangular한 값이 존재하는경우 1을, 존재하지 않는경우 0을 반환하라</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    A.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(A)):</span><br><span class="line">        a, b, c = A[i-<span class="number">2</span>], A[i-<span class="number">1</span>], A[i]</span><br><span class="line">        abc = a+b+c</span><br><span class="line">        <span class="keyword">if</span> abc &gt; <span class="number">2</span>*a <span class="keyword">and</span> abc &gt; <span class="number">2</span>*b <span class="keyword">and</span> abc &gt; <span class="number">2</span>*c:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong><code>POINT</code></strong> : 주어진 조건을 만족하는 a,b,c 는 다음의 조건 역시 만족하게 된다 =&gt; <code>a+b+c &gt; 2a, a+b+c &gt; 2b, a+b+c &gt; 2c</code>. 배열 A를 정렬한 후 순회하며 이 조건을 만족하는 3개 페어가 있는 경우 1을 반환한다.</p><hr><p><code>CHECK</code> : A=[1, 2, 3, 4, 5] 의 배열에서 [3, 4, 5] 만 순회하기</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(A)):</span><br><span class="line"><span class="built_in">print</span>(i) <span class="comment"># Output : 2, 3, 4</span></span><br></pre></td></tr></table></figure><ul><li>range(start, end) : start 인덱스는 포함, end 인덱스는 미포함</li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2021/10/23/codility7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 w Python - (5) 복습하기</title>
      <link>https://katie0809.github.io/2021/10/20/codility6/</link>
      <guid>https://katie0809.github.io/2021/10/20/codility6/</guid>
      <pubDate>Wed, 20 Oct 2021 10:18:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;Codility 문제들 중 이미 풀었던 문제들을 파이썬으로 다시 한번 정리해보기.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Codility 문제들 중 이미 풀었던 문제들을 파이썬으로 다시 한번 정리해보기.</p><span id="more"></span><h2 id="Q1-Binary-Gap-73"><a href="#Q1-Binary-Gap-73" class="headerlink" title="Q1. Binary Gap(73%)"></a>Q1. Binary Gap(73%)</h2><p><a href="https://app.codility.com/demo/results/trainingV8865J-GD2/">https://app.codility.com/demo/results/trainingV8865J-GD2/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="comment"># write your code in Python 3.6</span></span><br><span class="line">    maxcnt, cnt = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        c = N%<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">1</span> <span class="keyword">and</span> flag &gt;= <span class="number">1</span>:</span><br><span class="line">            flag = <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> cnt &gt; maxcnt:</span><br><span class="line">                maxcnt = cnt</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="number">1</span> <span class="keyword">and</span> flag == <span class="number">0</span>:</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(N, c, flag, cnt, maxcnt)</span></span><br><span class="line">        N = N//<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> maxcnt</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="Q2-Cyclic-Rotation"><a href="#Q2-Cyclic-Rotation" class="headerlink" title="Q2. Cyclic Rotation"></a>Q2. Cyclic Rotation</h2><h2 id="Q3-Odd-Occurrences-In-Array"><a href="#Q3-Odd-Occurrences-In-Array" class="headerlink" title="Q3. Odd Occurrences In Array"></a>Q3. Odd Occurrences In Array</h2><p><a href="https://app.codility.com/demo/results/trainingGE7AE2-NNT/">https://app.codility.com/demo/results/trainingGE7AE2-NNT/</a></p><ul><li>각 값은 0 - 1,000,000,000 </li><li>배열은 최대 1,000,000 개의 원소 가질 수 있다.</li><li>배열에서 짝이없는 값 1개 찾아내기</li><li>맨처음 생각한게 정렬해서 앞에서부터 훑는거긴 했다. 느릴것같다 생각했는데 이게 맞는듯?</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    A.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(A)-<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> A[i] != A[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> A[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong><code>POINT</code></strong> 전체를 다 확인하는게 아니고 하나씩 건너뛰면서 확인함으로서 시간 줄이기</p><h2 id="Q4-Frog-Jump"><a href="#Q4-Frog-Jump" class="headerlink" title="Q4. Frog Jump"></a>Q4. Frog Jump</h2><p><a href="https://app.codility.com/demo/results/trainingXGHMFE-PR5/">https://app.codility.com/demo/results/trainingXGHMFE-PR5/</a></p><ul><li>x, y, d 가 주어진다. x -&gt; y 까지 d씩 뛸때 점프횟수</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">X, Y, D</span>):</span></span><br><span class="line">    ret = (Y - X) // D</span><br><span class="line">    <span class="keyword">if</span> (Y - X) % D &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ret + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="Q5-Perm-Missing-Element"><a href="#Q5-Perm-Missing-Element" class="headerlink" title="Q5. Perm Missing Element"></a>Q5. Perm Missing Element</h2><p><a href="https://app.codility.com/demo/results/training9K34BE-NJY/">https://app.codility.com/demo/results/training9K34BE-NJY/</a></p><ul><li>길이 N의 배열 A가 주어진다. N의 범위는 0 ~ 100,000</li><li>배열의 모든 값은 distinct 하다</li><li>배열 A에는 1~N+1 의 값이 들어있다. 빠진 값 하나를 찾아라</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(A) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    A.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> A[i+<span class="number">1</span>] - A[i] != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> A[i]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> A[-<span class="number">1</span>] == <span class="built_in">len</span>(A):</span><br><span class="line">        <span class="keyword">return</span> A[-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> A[<span class="number">0</span>]-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong><code>POINT</code></strong> 값을 정렬후 순회하면서 이전값과 1 차이나는지 비교. 정답이 시작, 끝에 있는경우와 empty array에 대해 처리주의</p><p>=&gt; [1,3], [1,2], [2,3], [] 의 각 케이스의 예상 정답은 2, 3, 1, 1 이다</p><h2 id="Q6-Tape-Equilibrium"><a href="#Q6-Tape-Equilibrium" class="headerlink" title="Q6. Tape Equilibrium"></a>Q6. Tape Equilibrium</h2><p><a href="https://app.codility.com/demo/results/trainingXB9X9R-M53/">https://app.codility.com/demo/results/trainingXB9X9R-M53/</a></p><ul><li>배열이 주어진다. 배열을 2개 파트로 나눴을때 그 차이가 최소가 되는 지점을 찾아 그 값을 반환하라.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="comment"># write your code in Python 3.6</span></span><br><span class="line">    sumarr, mindiff = [<span class="number">0</span>], <span class="number">2e9</span></span><br><span class="line">    <span class="keyword">for</span> i, a <span class="keyword">in</span> <span class="built_in">enumerate</span>(A):</span><br><span class="line">        <span class="comment"># print(i, a, sumarr)</span></span><br><span class="line">        sumarr.append(sumarr[i]+a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> sumarr[<span class="number">0</span>]</span><br><span class="line">    totsum = sumarr[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(sumarr, totsum)</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> sumarr[:<span class="built_in">len</span>(sumarr)-<span class="number">1</span>]:</span><br><span class="line">        diff = <span class="built_in">abs</span>(<span class="number">2</span>*s - totsum)</span><br><span class="line">        <span class="comment"># print(diff)</span></span><br><span class="line">        <span class="keyword">if</span> diff &lt; mindiff:</span><br><span class="line">            mindiff = diff</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mindiff</span><br></pre></td></tr></table></figure><p><strong><code>POINT</code></strong> 배열에 대한 합 배열을 만든다. 합 배열을 순회하며 | arr[i] - (sum - arr[i]) | 의 최소값을 찾는다.</p><h2 id="Q7-PermCheck"><a href="#Q7-PermCheck" class="headerlink" title="Q7. PermCheck"></a>Q7. PermCheck</h2><p><a href="https://app.codility.com/demo/results/training5MS7E7-SQJ/">https://app.codility.com/demo/results/training5MS7E7-SQJ/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="comment"># write your code in Python 3.6</span></span><br><span class="line">    A.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">        <span class="keyword">if</span> A[i] != i+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="Q8-MaxCounters"><a href="#Q8-MaxCounters" class="headerlink" title="Q8. MaxCounters"></a>Q8. MaxCounters</h2><ul><li>길이 M 배열 A와 구분값 N이 주어진다.</li><li>A의 원소는 1 ~ N+1 의 값으로 이루어져 있다.</li><li>A의 값 K가 1 ~ N이면  K번째 값에 +1</li><li>A의 값 K가 N+1이면 전체값을 이때까지의 최대값으로 리셋</li></ul><p><strong><code>POINT</code></strong> Max Counter 연산 후에도 전체 배열의 값이 아닌 해당 위치의 값만 업데이트(A[i] += (1+ prevmax)) 한다. 업데이트 끝나고 최종 Max Value보다 작은 값들은 Max Value 로 다시 업뎃한다. =&gt; O(N<em>M) 을 피하기 위해 O(2</em>N) 의 알고리즘 짜는 것이 핵심</p><h3 id="Try-1-https-app-codility-com-demo-results-training2DCTJV-ZHJ-33"><a href="#Try-1-https-app-codility-com-demo-results-training2DCTJV-ZHJ-33" class="headerlink" title="Try 1 https://app.codility.com/demo/results/training2DCTJV-ZHJ/ (33%)"></a>Try 1 <a href="https://app.codility.com/demo/results/training2DCTJV-ZHJ/">https://app.codility.com/demo/results/training2DCTJV-ZHJ/</a> (33%)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">N, A</span>):</span></span><br><span class="line">    <span class="comment"># write your code in Python 3.6</span></span><br><span class="line">    counter = [<span class="number">0</span>]*N</span><br><span class="line">    prevmax, curmax = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">if</span> a &lt;= N:</span><br><span class="line">            c = counter[a-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> c &lt; prevmax:</span><br><span class="line">                counter[a-<span class="number">1</span>] += prevmax + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counter[a-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">              </span><br><span class="line">            <span class="keyword">if</span> counter[a-<span class="number">1</span>] &gt; curmax:</span><br><span class="line">                curmax = counter[a-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prevmax = curmax</span><br><span class="line">        <span class="comment"># print(a, curmax, prevmax, counter)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">if</span> counter[i] &lt; prevmax:</span><br><span class="line">            counter[i] = prevmax</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure><ul><li>현재값이 이전 max보다 작을때 현재값은 (counter[a-1] + prevmax + 1) 이 아닌 (prevmax + 1) 이다.</li></ul><h3 id="Try-2-다듬은-버전-100"><a href="#Try-2-다듬은-버전-100" class="headerlink" title="Try 2 다듬은 버전(100%)"></a>Try 2 다듬은 버전(100%)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">N, A</span>):</span></span><br><span class="line">    <span class="comment"># write your code in Python 3.6</span></span><br><span class="line">    counter = [<span class="number">0</span>]*N</span><br><span class="line">    prevmax, curmax = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">if</span> a &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> counter[a-<span class="number">1</span>] &lt; prevmax:</span><br><span class="line">                counter[a-<span class="number">1</span>] = prevmax</span><br><span class="line"></span><br><span class="line">            counter[a-<span class="number">1</span>] += <span class="number">1</span>    </span><br><span class="line">            curmax = <span class="built_in">max</span>(curmax, counter[a-<span class="number">1</span>])            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prevmax = curmax</span><br><span class="line">        <span class="comment"># print(a, curmax, prevmax, counter)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">if</span> counter[i] &lt; prevmax:</span><br><span class="line">            counter[i] = prevmax</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure><h2 id="Q9-MissingInteger"><a href="#Q9-MissingInteger" class="headerlink" title="Q9. MissingInteger"></a>Q9. MissingInteger</h2><ul><li>길이 N의 배열 A(N은 1~100,000). 배열의 각 값은 -1,000,000 ~ 1,000,000 이다.</li><li>배열에 없는 0보다 큰 가장 작은 양수를 찾아라</li></ul><h3 id="Try-1-https-app-codility-com-demo-results-trainingQNWXW3-Z9Q-66"><a href="#Try-1-https-app-codility-com-demo-results-trainingQNWXW3-Z9Q-66" class="headerlink" title="Try 1. https://app.codility.com/demo/results/trainingQNWXW3-Z9Q/ (66%)"></a>Try 1. <a href="https://app.codility.com/demo/results/trainingQNWXW3-Z9Q/">https://app.codility.com/demo/results/trainingQNWXW3-Z9Q/</a> (66%)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    </span><br><span class="line">    A.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># max value is smaller than 0</span></span><br><span class="line">    <span class="comment"># min value is bigger than 1</span></span><br><span class="line">    <span class="keyword">if</span> A[-<span class="number">1</span>] &lt;= <span class="number">0</span> <span class="keyword">or</span> A[<span class="number">0</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(A)):</span><br><span class="line">        <span class="comment"># print(i, A[i], A[i-1])</span></span><br><span class="line">        <span class="keyword">if</span> A[i] &gt; A[i-<span class="number">1</span>]+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> A[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> A[-<span class="number">1</span>]+<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><p>음수와 양수가 섞인 케이스에 대해 고려되지 않음</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-44, -3, 4, 5, 2, 6] =&gt; 1</span><br><span class="line">[-4, -3, 0, 1, 2, 3] =&gt; 4</span><br><span class="line">[-4, -3, 0, 1, 1, 1, 2, 3, 6, 7] =&gt; 4</span><br><span class="line">[3, 4, 5, 6] =&gt; 2</span><br></pre></td></tr></table></figure></li></ul><h3 id="Try-2-https-app-codility-com-demo-results-trainingP88B9D-6GM-100"><a href="#Try-2-https-app-codility-com-demo-results-trainingP88B9D-6GM-100" class="headerlink" title="Try 2. https://app.codility.com/demo/results/trainingP88B9D-6GM/ (100%)"></a>Try 2. <a href="https://app.codility.com/demo/results/trainingP88B9D-6GM/">https://app.codility.com/demo/results/trainingP88B9D-6GM/</a> (100%)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    </span><br><span class="line">    A.sort()</span><br><span class="line">    curmin = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">if</span> a &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> curmin == a+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> curmin == a:</span><br><span class="line">            curmin += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> curmin</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> curmin</span><br></pre></td></tr></table></figure><ul><li>현재의 가장 작은 양수값(curmin) 을 저장해두고 정렬된 배열 순회. 해당값 없으면 curmin 반환한다</li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2021/10/20/codility6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[캐글 스터디] Bike Sharing Demand</title>
      <link>https://katie0809.github.io/2021/02/15/kaggle-study1/</link>
      <guid>https://katie0809.github.io/2021/02/15/kaggle-study1/</guid>
      <pubDate>Mon, 15 Feb 2021 12:53:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;캐글 문제풀이. 도시의 자전거 대여 시스템과 관련된 여러 정보를 통해 &lt;code&gt;자전거 대여량 수요&lt;/code&gt;를 예측하도록 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kaggle.com/c/bike-sharing-demand/&quot;&gt;문제 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>캐글 문제풀이. 도시의 자전거 대여 시스템과 관련된 여러 정보를 통해 <code>자전거 대여량 수요</code>를 예측하도록 한다.</p><ul><li><a href="https://www.kaggle.com/c/bike-sharing-demand/">문제 링크</a></li></ul><span id="more"></span><h2 id="1-데이터셋"><a href="#1-데이터셋" class="headerlink" title="1. 데이터셋"></a>1. 데이터셋</h2><p><strong>datetime</strong> - hourly date + timestamp<br><strong>season</strong> -  1 = spring, 2 = summer, 3 = fall, 4 = winter<br><strong>holiday</strong> - whether the day is considered a holiday<br><strong>workingday</strong> - whether the day is neither a weekend nor holiday<br><strong>weather</strong><br>    1: Clear, Few clouds, Partly cloudy, Partly cloudy<br>    2: Mist + Cloudy, Mist + Broken clouds, Mist + Few clouds, Mist<br>    3: Light Snow, Light Rain + Thunderstorm + Scattered clouds, Light Rain + Scattered clouds<br>    4: Heavy Rain + Ice Pallets + Thunderstorm + Mist, Snow + Fog<br><strong>temp</strong> - temperature in Celsius<br><strong>atemp</strong> - “feels like” temperature in Celsius<br><strong>humidity</strong> - relative humidity<br><strong>windspeed</strong> - wind speed<br><strong>casual</strong> - number of non-registered user rentals initiated<br><strong>registered</strong> - number of registered user rentals initiated<br><strong>count</strong> - number of total rentals</p><ul><li>학습 타겟 y는 <strong>count</strong> column이다</li><li>train dataset에는 casual과 registered가 있는데 test dataset에는 없다. 그냥 drop하면 되는것인지 약간 궁금</li></ul><h2 id="2-Baseline-잡기"><a href="#2-Baseline-잡기" class="headerlink" title="2. Baseline 잡기"></a>2. Baseline 잡기</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># csv 파일을 읽어온다</span></span><br><span class="line"><span class="comment"># 파일을 읽어올때 날짜/시간 데이터를 자동으로 파싱한다 : https://rfriend.tistory.com/536</span></span><br><span class="line">train = pd.read_csv(<span class="string">&quot;/kaggle/input/bike-sharing-demand/train.csv&quot;</span>, parse_dates=[<span class="string">&quot;datetime&quot;</span>])</span><br><span class="line">test = pd.read_csv(<span class="string">&quot;/kaggle/input/bike-sharing-demand/test.csv&quot;</span>, parse_dates=[<span class="string">&quot;datetime&quot;</span>])</span><br><span class="line"></span><br><span class="line">display(train, test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 저장해온 데이터셋의 정보를 확인한다.</span></span><br><span class="line">train.info()</span><br><span class="line">test.info()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 10886 entries, 0 to 10885</span><br><span class="line">Data columns (total 12 columns):</span><br><span class="line"> #   Column      Non-Null Count  Dtype         </span><br><span class="line">---  ------      --------------  -----         </span><br><span class="line"> 0   datetime    10886 non-null  datetime64[ns]</span><br><span class="line"> 1   season      10886 non-null  int64         </span><br><span class="line"> 2   holiday     10886 non-null  int64         </span><br><span class="line"> 3   workingday  10886 non-null  int64         </span><br><span class="line"> 4   weather     10886 non-null  int64         </span><br><span class="line"> 5   temp        10886 non-null  float64       </span><br><span class="line"> 6   atemp       10886 non-null  float64       </span><br><span class="line"> 7   humidity    10886 non-null  int64         </span><br><span class="line"> 8   windspeed   10886 non-null  float64       </span><br><span class="line"> 9   casual      10886 non-null  int64         </span><br><span class="line"> 10  registered  10886 non-null  int64         </span><br><span class="line"> 11  count       10886 non-null  int64         </span><br><span class="line">dtypes: datetime64[ns](1), float64(3), int64(8)</span><br><span class="line">memory usage: 1020.7 KB</span><br><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 6493 entries, 0 to 6492</span><br><span class="line">Data columns (total 9 columns):</span><br><span class="line"> #   Column      Non-Null Count  Dtype         </span><br><span class="line">---  ------      --------------  -----         </span><br><span class="line"> 0   datetime    6493 non-null   datetime64[ns]</span><br><span class="line"> 1   season      6493 non-null   int64         </span><br><span class="line"> 2   holiday     6493 non-null   int64         </span><br><span class="line"> 3   workingday  6493 non-null   int64         </span><br><span class="line"> 4   weather     6493 non-null   int64         </span><br><span class="line"> 5   temp        6493 non-null   float64       </span><br><span class="line"> 6   atemp       6493 non-null   float64       </span><br><span class="line"> 7   humidity    6493 non-null   int64         </span><br><span class="line"> 8   windspeed   6493 non-null   float64       </span><br><span class="line">dtypes: datetime64[ns](1), float64(3), int64(5)</span><br><span class="line">memory usage: 456.7 KB</span><br></pre></td></tr></table></figure><ul><li><p>pandas.Series.dt 의 함수를 사용해 datetime 정보를 정제해준다.<br><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.date.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.date.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 날짜 데이터 전처리 진행</span></span><br><span class="line">train[<span class="string">&quot;year&quot;</span>] = train[<span class="string">&quot;datetime&quot;</span>].dt.year</span><br><span class="line">test[<span class="string">&quot;year&quot;</span>] = test[<span class="string">&quot;datetime&quot;</span>].dt.year</span><br><span class="line"></span><br><span class="line">train[<span class="string">&quot;month&quot;</span>] = train[<span class="string">&quot;datetime&quot;</span>].dt.month</span><br><span class="line">test[<span class="string">&quot;month&quot;</span>] = test[<span class="string">&quot;datetime&quot;</span>].dt.month</span><br><span class="line"></span><br><span class="line">train[<span class="string">&quot;day&quot;</span>] = train[<span class="string">&quot;datetime&quot;</span>].dt.weekday</span><br><span class="line">test[<span class="string">&quot;day&quot;</span>] = test[<span class="string">&quot;datetime&quot;</span>].dt.weekday</span><br><span class="line"></span><br><span class="line">train[<span class="string">&quot;hour&quot;</span>] = train[<span class="string">&quot;datetime&quot;</span>].dt.hour</span><br><span class="line">test[<span class="string">&quot;hour&quot;</span>] = test[<span class="string">&quot;datetime&quot;</span>].dt.hour</span><br></pre></td></tr></table></figure></li><li><p>기존의 datetime column을 제거해준다. <code>RandomForestRegressor</code>를 활용해 count에 대해 학습 시킨다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">train2 = train.drop([<span class="string">&quot;count&quot;</span>, <span class="string">&quot;datetime&quot;</span>, <span class="string">&quot;registered&quot;</span>, <span class="string">&quot;casual&quot;</span>], axis=<span class="number">1</span>)</span><br><span class="line">test2 = test.drop([<span class="string">&quot;datetime&quot;</span>], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line">rf = RandomForestRegressor(n_jobs=-<span class="number">1</span>)</span><br><span class="line">rf.fit(train2, train[<span class="string">&quot;count&quot;</span>])</span><br><span class="line">result = rf.predict(test2)</span><br></pre></td></tr></table></figure><p>이렇게 하면 대략 0.46 내외의 점수가 나온다. 리더보드 기준 1000등 가량</p></li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2021/02/15/kaggle-study1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DACON] 심리 성향 예측 AI 경진대회</title>
      <link>https://katie0809.github.io/2020/12/21/tf-study8/</link>
      <guid>https://katie0809.github.io/2020/12/21/tf-study8/</guid>
      <pubDate>Mon, 21 Dec 2020 14:07:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://dacon.io/competitions/official/235647/overview/&quot;&gt;https://dacon.io/competitions/official/235647/overview/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;데이콘에서 종료한 대회의 데이터와 코드를 참고해 알고리즘 제작을 실습해보려 한다. 처음으로 풀 문제는 올해 11월 종료한 &lt;code&gt;심리성향 예측 AI 경진대회&lt;/code&gt; 이다.&lt;/p&gt;
&lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;테스트 참가자의 &lt;u&gt;국가 선거 투표 여부&lt;/u&gt;를 예측한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;사용 가능 언어 : Python, R&lt;/li&gt;
&lt;li&gt;심사기준 : AUC&lt;/li&gt;
&lt;li&gt;외부 데이터 사용불가, pre-trained Model 사용불가&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://dacon.io/competitions/official/235647/overview/">https://dacon.io/competitions/official/235647/overview/</a></p><p>데이콘에서 종료한 대회의 데이터와 코드를 참고해 알고리즘 제작을 실습해보려 한다. 처음으로 풀 문제는 올해 11월 종료한 <code>심리성향 예측 AI 경진대회</code> 이다.</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><blockquote><p>테스트 참가자의 <u>국가 선거 투표 여부</u>를 예측한다.</p></blockquote><ul><li>사용 가능 언어 : Python, R</li><li>심사기준 : AUC</li><li>외부 데이터 사용불가, pre-trained Model 사용불가</li></ul><span id="more"></span><h1 id="데이터-분석"><a href="#데이터-분석" class="headerlink" title="데이터 분석"></a>데이터 분석</h1><p>학습해야할 데이터 파일의 구성은 아래와 같다.</p><ol><li>하나의 행이 한 참가자의 정보를 담고 있다. <strong>최종적으로 예측해야 하는 값</strong>은 해당 참가자의 <code>voted : 지난해 국가 선거 투표여부</code> 이다.</li><li>a~t 까지의 20개의 질문에 대한 답 QnA와 답변에 걸린 시간 QnE 가 주어진다. <ul><li>답변은 <code>1=Disagree, 2=Slightly disagree, 3=Neutral, 4=Slightly agree, 5=Agree</code> 로 주어진다.</li></ul></li><li>스스로의 성격에 대한 평가 질문 7개에 대한 답이 주어진다.<ul><li>I see myself as (Extraverted / Critical / Dependable… )</li></ul></li><li>실존하는 단어 13개에 대한 정의를 아는지 여부에 대한 답변이 <code>1=Yes, 2=No</code>로 주어진다 : wr_(01~13)</li><li>허구하는 단어 3개에 대한 정의를 아는지 여부에 대한 답변이 <code>1=Yes, 2=No</code>로 주어진다 : wt_(01~03)</li><li>기타 해당 참가자에 대한 정보(연령, 교육수준, 모국어, 형제자매 등)가 주어진다.</li></ol><h1 id="데이터-전처리"><a href="#데이터-전처리" class="headerlink" title="데이터 전처리"></a>데이터 전처리</h1><h2 id="구글-드라이브-마운트해서-파일-받아오기"><a href="#구글-드라이브-마운트해서-파일-받아오기" class="headerlink" title="[ 구글 드라이브 마운트해서 파일 받아오기 ]"></a>[ 구글 드라이브 마운트해서 파일 받아오기 ]</h2><p>구글 드라이브에 샘플 csv파일을 올려두고, 데이터 처리를 위해 해당 파일들을 불러온다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 구글 드라이브에 올려둔 학습데이터 가져온다</span></span><br><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> drive</span><br><span class="line">drive.mount(<span class="string">&#x27;/drive&#x27;</span>, force_remount=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 파일 받아온다</span></span><br><span class="line">train_filename = <span class="string">&#x27;/drive/My Drive/DACON/MindType/train.csv&#x27;</span></span><br><span class="line">test_filename = <span class="string">&#x27;/drive/My Drive/DACON/MindType/test_x.csv&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>개인 구글 드라이브 하위에 <code>/DACON/MindType</code> 폴더를 만들어두고 학습 데이터들을 올려두었다.</li><li>드라이브를 마운트하고 파일을 받아온다.</li></ul><h2 id="csv-파일-읽어와-학습변수로-설정하기"><a href="#csv-파일-읽어와-학습변수로-설정하기" class="headerlink" title="[ csv 파일 읽어와 학습변수로 설정하기 ]"></a>[ csv 파일 읽어와 학습변수로 설정하기 ]</h2><blockquote><p>csv 파일 읽어오기</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># csv파일 읽어들인다</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train_raw = pd.read_csv(train_filename)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(train_raw.columns)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Index([&#x27;index&#x27;, &#x27;QaA&#x27;, &#x27;QaE&#x27;, &#x27;QbA&#x27;, &#x27;QbE&#x27;, &#x27;QcA&#x27;, &#x27;QcE&#x27;, &#x27;QdA&#x27;, &#x27;QdE&#x27;, &#x27;QeA&#x27;,</span><br><span class="line">       &#x27;QeE&#x27;, &#x27;QfA&#x27;, &#x27;QfE&#x27;, &#x27;QgA&#x27;, &#x27;QgE&#x27;, &#x27;QhA&#x27;, &#x27;QhE&#x27;, &#x27;QiA&#x27;, &#x27;QiE&#x27;, &#x27;QjA&#x27;,</span><br><span class="line">       &#x27;QjE&#x27;, &#x27;QkA&#x27;, &#x27;QkE&#x27;, &#x27;QlA&#x27;, &#x27;QlE&#x27;, &#x27;QmA&#x27;, &#x27;QmE&#x27;, &#x27;QnA&#x27;, &#x27;QnE&#x27;, &#x27;QoA&#x27;,</span><br><span class="line">       &#x27;QoE&#x27;, &#x27;QpA&#x27;, &#x27;QpE&#x27;, &#x27;QqA&#x27;, &#x27;QqE&#x27;, &#x27;QrA&#x27;, &#x27;QrE&#x27;, &#x27;QsA&#x27;, &#x27;QsE&#x27;, &#x27;QtA&#x27;,</span><br><span class="line">       &#x27;QtE&#x27;, &#x27;age_group&#x27;, &#x27;education&#x27;, &#x27;engnat&#x27;, &#x27;familysize&#x27;, &#x27;gender&#x27;,</span><br><span class="line">       &#x27;hand&#x27;, &#x27;married&#x27;, &#x27;race&#x27;, &#x27;religion&#x27;, &#x27;tp01&#x27;, &#x27;tp02&#x27;, &#x27;tp03&#x27;, &#x27;tp04&#x27;,</span><br><span class="line">       &#x27;tp05&#x27;, &#x27;tp06&#x27;, &#x27;tp07&#x27;, &#x27;tp08&#x27;, &#x27;tp09&#x27;, &#x27;tp10&#x27;, &#x27;urban&#x27;, &#x27;voted&#x27;,</span><br><span class="line">       &#x27;wf_01&#x27;, &#x27;wf_02&#x27;, &#x27;wf_03&#x27;, &#x27;wr_01&#x27;, &#x27;wr_02&#x27;, &#x27;wr_03&#x27;, &#x27;wr_04&#x27;, &#x27;wr_05&#x27;,</span><br><span class="line">       &#x27;wr_06&#x27;, &#x27;wr_07&#x27;, &#x27;wr_08&#x27;, &#x27;wr_09&#x27;, &#x27;wr_10&#x27;, &#x27;wr_11&#x27;, &#x27;wr_12&#x27;, &#x27;wr_13&#x27;],</span><br><span class="line">      dtype=&#x27;object&#x27;)</span><br></pre></td></tr></table></figure><ul><li>파이썬의 pandas 라이브러리를 활용해 csv 파일을 불러온다 : <code>pandas.read_csv()</code> 사용</li><li>csv파일 변수의 <code>.columns</code> 로 추출된 컬럼을 확인할 수 있다. </li></ul><blockquote><p>index column 설정하기</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># csv파일 읽어들인다</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train_raw = pd.read_csv(train_filename, index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(train_raw.columns)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Index([&#x27;QaA&#x27;, &#x27;QaE&#x27;, &#x27;QbA&#x27;, &#x27;QbE&#x27;, &#x27;QcA&#x27;, &#x27;QcE&#x27;, &#x27;QdA&#x27;, &#x27;QdE&#x27;, &#x27;QeA&#x27;, &#x27;QeE&#x27;,</span><br><span class="line">       &#x27;QfA&#x27;, &#x27;QfE&#x27;, &#x27;QgA&#x27;, &#x27;QgE&#x27;, &#x27;QhA&#x27;, &#x27;QhE&#x27;, &#x27;QiA&#x27;, &#x27;QiE&#x27;, &#x27;QjA&#x27;, &#x27;QjE&#x27;,</span><br><span class="line">       &#x27;QkA&#x27;, &#x27;QkE&#x27;, &#x27;QlA&#x27;, &#x27;QlE&#x27;, &#x27;QmA&#x27;, &#x27;QmE&#x27;, &#x27;QnA&#x27;, &#x27;QnE&#x27;, &#x27;QoA&#x27;, &#x27;QoE&#x27;,</span><br><span class="line">       &#x27;QpA&#x27;, &#x27;QpE&#x27;, &#x27;QqA&#x27;, &#x27;QqE&#x27;, &#x27;QrA&#x27;, &#x27;QrE&#x27;, &#x27;QsA&#x27;, &#x27;QsE&#x27;, &#x27;QtA&#x27;, &#x27;QtE&#x27;,</span><br><span class="line">       &#x27;age_group&#x27;, &#x27;education&#x27;, &#x27;engnat&#x27;, &#x27;familysize&#x27;, &#x27;gender&#x27;, &#x27;hand&#x27;,</span><br><span class="line">       &#x27;married&#x27;, &#x27;race&#x27;, &#x27;religion&#x27;, &#x27;tp01&#x27;, &#x27;tp02&#x27;, &#x27;tp03&#x27;, &#x27;tp04&#x27;, &#x27;tp05&#x27;,</span><br><span class="line">       &#x27;tp06&#x27;, &#x27;tp07&#x27;, &#x27;tp08&#x27;, &#x27;tp09&#x27;, &#x27;tp10&#x27;, &#x27;urban&#x27;, &#x27;voted&#x27;, &#x27;wf_01&#x27;,</span><br><span class="line">       &#x27;wf_02&#x27;, &#x27;wf_03&#x27;, &#x27;wr_01&#x27;, &#x27;wr_02&#x27;, &#x27;wr_03&#x27;, &#x27;wr_04&#x27;, &#x27;wr_05&#x27;, &#x27;wr_06&#x27;,</span><br><span class="line">       &#x27;wr_07&#x27;, &#x27;wr_08&#x27;, &#x27;wr_09&#x27;, &#x27;wr_10&#x27;, &#x27;wr_11&#x27;, &#x27;wr_12&#x27;, &#x27;wr_13&#x27;],</span><br><span class="line">      dtype=&#x27;object&#x27;)</span><br></pre></td></tr></table></figure><ul><li>위와 같이 csv파일을 읽어올때 <strong><code>index column을 설정</code></strong>해주면 <u>전처리할 열에서 제외</u>할 수 있다.</li></ul><blockquote><p>“voted” 열을 train_y의 타겟으로 만들기</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_x = train_raw.drop(<span class="string">&#x27;voted&#x27;</span>, axis = <span class="number">1</span>)</span><br><span class="line">train_y = train_raw[<span class="string">&#x27;voted&#x27;</span>]</span><br><span class="line"></span><br><span class="line">train_x.shape</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(45532, 76) # 45532명에 대한 76가지 데이터를 의미한다.</span><br></pre></td></tr></table></figure><ul><li>학습 데이터에서 <code>voted</code> 열만 제외한 데이터를 <strong>train_x</strong>로 저장</li><li>학습 데이터의 <code>voted</code> 열을 따로 뽑아 <strong>train_y</strong>로 저장</li></ul><h2 id="문자열-변수-변환"><a href="#문자열-변수-변환" class="headerlink" title="[ 문자열 변수 변환 ]"></a>[ 문자열 변수 변환 ]</h2><p>값이 문자열로 들어가있는 데이터에 대해 적절한 숫자값으로 변환해주었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gender_list = [<span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Female&#x27;</span>]</span><br><span class="line">race_list = [<span class="string">&#x27;Asian&#x27;</span>, <span class="string">&#x27;Arab&#x27;</span>, <span class="string">&#x27;Black&#x27;</span>, <span class="string">&#x27;Indigenous Australian&#x27;</span>, <span class="string">&#x27;Native American&#x27;</span>, <span class="string">&#x27;White&#x27;</span>, <span class="string">&#x27;Other&#x27;</span>]</span><br><span class="line">religion_list = [<span class="string">&#x27;Agnostic&#x27;</span>, <span class="string">&#x27;Atheist&#x27;</span>, <span class="string">&#x27;Buddhist&#x27;</span>, <span class="string">&#x27;Christian_Catholic&#x27;</span>, <span class="string">&#x27;Christian_Mormon&#x27;</span>, <span class="string">&#x27;Christian_Protestant&#x27;</span>, <span class="string">&#x27;Christian_Other&#x27;</span>, <span class="string">&#x27;Hindu&#x27;</span>, <span class="string">&#x27;Jewish&#x27;</span>, <span class="string">&#x27;Muslim&#x27;</span>, <span class="string">&#x27;Sikh&#x27;</span>, <span class="string">&#x27;Other&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, data <span class="keyword">in</span> train_x.iterrows():</span><br><span class="line">  age_grp = data[<span class="string">&#x27;age_group&#x27;</span>]</span><br><span class="line">  race = data[<span class="string">&#x27;race&#x27;</span>]</span><br><span class="line">  religion = data[<span class="string">&#x27;religion&#x27;</span>]</span><br><span class="line">  gender = data[<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">  </span><br><span class="line">  train_x.loc[idx, <span class="string">&#x27;age_group&#x27;</span>] = age_grp.replace(<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  train_x.loc[idx, <span class="string">&#x27;race&#x27;</span>] = race_list.index(race) + <span class="number">1</span></span><br><span class="line">  train_x.loc[idx, <span class="string">&#x27;religion&#x27;</span>] = religion_list.index(religion) + <span class="number">1</span></span><br><span class="line">  train_x.loc[idx, <span class="string">&#x27;gender&#x27;</span>] = gender_list.index(gender) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(train_x[<span class="string">&#x27;religion&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">index</span><br><span class="line">0        12</span><br><span class="line">1         8</span><br><span class="line">2        12</span><br><span class="line">3         8</span><br><span class="line">4         1</span><br><span class="line">         ..</span><br><span class="line">45527     9</span><br><span class="line">45528     2</span><br><span class="line">45529     7</span><br><span class="line">45530     2</span><br><span class="line">45531     1</span><br><span class="line">Name: religion, Length: 45532, dtype: object</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/12/21/tf-study8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝 기초] </title>
      <link>https://katie0809.github.io/2020/12/09/ai-start7/</link>
      <guid>https://katie0809.github.io/2020/12/09/ai-start7/</guid>
      <pubDate>Tue, 08 Dec 2020 15:23:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;딥러닝을 하기 위한 텐서플로 기초 사용법입니다. 파이썬 numpy array를 활용해 기본적인 텐서를 생성하고, 생성된 텐서의 정보를 확인해보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>딥러닝을 하기 위한 텐서플로 기초 사용법입니다. 파이썬 numpy array를 활용해 기본적인 텐서를 생성하고, 생성된 텐서의 정보를 확인해보자.</p><span id="more"></span><h2 id="Tensor의-생성"><a href="#Tensor의-생성" class="headerlink" title="Tensor의 생성"></a>Tensor의 생성</h2><p>파이썬 numpy를 통해 생성한 배열/튜플/리스트는 텐서플로의 <code>tf.constant()</code> 함수를 통해 텐서로 변환할 수 있다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">tf.constant(arr)</span><br></pre></td></tr></table></figure><h2 id="Tensor-정보-확인"><a href="#Tensor-정보-확인" class="headerlink" title="Tensor 정보 확인"></a>Tensor 정보 확인</h2><ul><li><p><code>tensor.shape</code> : tensor의 shape 확인</p></li><li><p><code>tensor.dtype</code> : tensor의 데이터 타입 확인</p><ul><li><p>텐서 생성시에 데이터 타입을 정의해줄 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor = tf.constant([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=tf.float32)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>tf.cast()</code> : data type 변환</p><ul><li>numpy array는 <code>numpy.astype()</code>을 사용해 데이터 타입 변환한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.cast(tensor, dtype=tf.uint8)</span><br></pre></td></tr></table></figure></li><li><p><code>tensor.numpy()</code>, <code>np.array(tensor)</code>, <code>type(tensor.numpy())</code> : 텐서에서 numpy불러오기</p></li></ul><h2 id="난수-생성하기"><a href="#난수-생성하기" class="headerlink" title="난수 생성하기"></a>난수 생성하기</h2><ul><li><code>numpy.random.rand()</code>, <code>tf.random.normal()</code> : normal distribution의 난수 생성</li><li><code>tf.random.uniform()</code> : uniform distribution의 난수 생성</li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/12/09/ai-start7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝 기초] 그래프 시각화</title>
      <link>https://katie0809.github.io/2020/12/05/ai-start6/</link>
      <guid>https://katie0809.github.io/2020/12/05/ai-start6/</guid>
      <pubDate>Sat, 05 Dec 2020 08:42:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;데이터의 학습과정을 확인하고 분석하기 위해서는 이를 그래프로 시각화하는 과정이 필수적이다.&lt;/p&gt;
&lt;p&gt; &lt;code&gt;matplotlib.pyplot&lt;/code&gt; 라이브러리를 활용해 그래프 시각화 테크닉을 익혀보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>데이터의 학습과정을 확인하고 분석하기 위해서는 이를 그래프로 시각화하는 과정이 필수적이다.</p><p> <code>matplotlib.pyplot</code> 라이브러리를 활용해 그래프 시각화 테크닉을 익혀보자.</p><span id="more"></span><h2 id="패키지-로딩"><a href="#패키지-로딩" class="headerlink" title="패키지 로딩"></a>패키지 로딩</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">%matplotlib inline // jupyter notebook에서만 사용가능. 그래프를 새 창이 아닌 현재 실행중인 창에서 띄워준다.</span><br></pre></td></tr></table></figure><h2 id="점선-기본-그래프-그리기-plt-plot-data"><a href="#점선-기본-그래프-그리기-plt-plot-data" class="headerlink" title="점선 기본 그래프 그리기 : plt.plot(data)"></a>점선 기본 그래프 그리기 : <code>plt.plot(data)</code></h2><p>: numpy array의 각 값들을 선으로 이은 기본 그래프 그린다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.rand(<span class="number">50</span>)</span><br><span class="line">plt.plot(data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="여러-그래프-그리기"><a href="#여러-그래프-그리기" class="headerlink" title="여러 그래프 그리기"></a>여러 그래프 그리기</h2><ul><li><code>pyplot.subplot(행 개수, 열 개수, 그래프 그릴위치 index)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>) // <span class="number">1</span> * <span class="number">2</span>의 판을 만든다. 그 중 첫번째 위치에 그래프를 그린다. </span><br><span class="line">plt.plot(data) // subplot으로 그래프 그릴 위치 정해주고 그래프 그리는 함수로 데이터 그려준다.</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li><code>plot</code>대신 사용가능한 함수 : <code>hist()</code> 히스토그램, <code>scatter()</code> 분산데이터</li></ul><h2 id="그래프-옵션"><a href="#그래프-옵션" class="headerlink" title="그래프 옵션"></a>그래프 옵션</h2><ul><li>색상/마커 등 조절가능 : b, g, r, c, y, k, w / 원, 선, 별표 등 가능</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(data, &#x27;y&#x27;)</span><br></pre></td></tr></table></figure><ul><li><code>pyplot.figure(figsize=(10, 5))</code> : 그래프 가로세로 길이 조절가능하다</li><li><code>pyplot.legend()</code> : 그래프 선 이름을 보여준다.</li><li><code>pyplot.xlabel(&#39;name&#39;)</code>, <code>pyplot.ylabel(&#39;name&#39;)</code> : x/y축 레이블을 보여준다.</li><li><code>pyplot.savefig(&#39;saved_graph.svg&#39;)</code> : 그래프 저장하기 </li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/12/05/ai-start6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝 기초] Tensor의 이해와 Numpy기초</title>
      <link>https://katie0809.github.io/2020/12/05/ai-start5/</link>
      <guid>https://katie0809.github.io/2020/12/05/ai-start5/</guid>
      <pubDate>Sat, 05 Dec 2020 06:36:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;딥러닝의 Tensor =&amp;gt; numpy array로 주로 표현한다. Tensor의 기본에 대해 이해하고 python numpy의 기본 도구들을 익히자&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>딥러닝의 Tensor =&gt; numpy array로 주로 표현한다. Tensor의 기본에 대해 이해하고 python numpy의 기본 도구들을 익히자</p><span id="more"></span><h1 id="Tensor의-이해"><a href="#Tensor의-이해" class="headerlink" title="Tensor의 이해"></a>Tensor의 이해</h1><h2 id="0차원-scalar"><a href="#0차원-scalar" class="headerlink" title="0차원(scalar)"></a>0차원(scalar)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array(<span class="number">5</span>)</span><br><span class="line">arr.shape</span><br><span class="line">arr.ndim</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Out: ()</span><br><span class="line">Out: 0</span><br></pre></td></tr></table></figure><p>스칼라로 들어간 넘파이 배열. shape가 아무것도 없는 것으로 나온다.</p><h2 id="1차원-vector"><a href="#1차원-vector" class="headerlink" title="1차원(vector)"></a>1차원(vector)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">5</span>])</span><br><span class="line">arr.shape</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out: (1,)</span><br></pre></td></tr></table></figure><ul><li>numpy에서 <code>1차원 텐서의 shape을 표현할때 (1)이 아닌 (1, ) 과 같이 표현</code>한다.</li><li>이건 shape이기 때문에 1이라는 값이 들어갔다는게 아니다. 1차원에 1개의 값이 들어갔다는 의미.</li><li>마찬가지로 예를들어 <strong>(3, ) 은 1차원에 3개의 값</strong>이 들어갔다는 의미이다.</li></ul><h2 id="2차원-matrix"><a href="#2차원-matrix" class="headerlink" title="2차원(matrix)"></a>2차원(matrix)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">arr.shape</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out: (2, 3)</span><br></pre></td></tr></table></figure><h2 id="다차원"><a href="#다차원" class="headerlink" title="다차원"></a>다차원</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]], [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]], [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]]])</span><br><span class="line">arr.shape</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out: (3, 3, 1)</span><br></pre></td></tr></table></figure><h1 id="Numpy기초"><a href="#Numpy기초" class="headerlink" title="Numpy기초"></a>Numpy기초</h1><h2 id="0과-1로-채워진-numpy-array만들기"><a href="#0과-1로-채워진-numpy-array만들기" class="headerlink" title="0과 1로 채워진 numpy array만들기"></a>0과 1로 채워진 numpy array만들기</h2><blockquote><p>np.zeros() : 0으로 채워진 numpy array 만들기</p><p>np.ones() : 1으로 채워진 numpy array 만들기</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zeros = np.zeros([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">ones = np.ones([<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">zeros</span><br><span class="line">ones</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([[0., 0., 0.],</span><br><span class="line">       [0., 0., 0.]])</span><br><span class="line">       </span><br><span class="line">array([[1., 1.],</span><br><span class="line">       [1., 1.],</span><br><span class="line">       [1., 1.]])</span><br></pre></td></tr></table></figure><h2 id="특정-범위의-숫자로-채워진-numpy-array만들기"><a href="#특정-범위의-숫자로-채워진-numpy-array만들기" class="headerlink" title="특정 범위의 숫자로 채워진 numpy array만들기"></a>특정 범위의 숫자로 채워진 numpy array만들기</h2><blockquote><p>np.arrange(M, N) : M부터 N-1까지의 수로 채워진 numpy array를 만들어준다</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arrange(<span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([4, 5, 6])</span><br></pre></td></tr></table></figure><h3 id="응용-reshape와-섞어서-쓰기"><a href="#응용-reshape와-섞어서-쓰기" class="headerlink" title="(응용) reshape와 섞어서 쓰기"></a>(응용) reshape와 섞어서 쓰기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arrange(<span class="number">4</span>, <span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([4, 5],</span><br><span class="line">      [6, 7])</span><br></pre></td></tr></table></figure><h3 id="응용-array의-index로-접근하기"><a href="#응용-array의-index로-접근하기" class="headerlink" title="(응용) array의 index로 접근하기"></a>(응용) array의 index로 접근하기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">arr[<span class="number">1</span>]</span><br><span class="line">arr[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">nums[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([6, 7])</span><br><span class="line">6</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><h3 id="응용-index로-slicing하기"><a href="#응용-index로-slicing하기" class="headerlink" title="(응용) index로 slicing하기"></a>(응용) index로 slicing하기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arrange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">arr[<span class="number">1</span>:]</span><br><span class="line">arr[<span class="number">1</span>:, <span class="number">1</span>:]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([3, 4, 5],</span><br><span class="line">      [6, 7, 8])</span><br><span class="line">array([4, 5],</span><br><span class="line">      [7, 8])    </span><br></pre></td></tr></table></figure><h3 id="응용-Boolean-indexing"><a href="#응용-Boolean-indexing" class="headerlink" title="(응용) Boolean indexing"></a>(응용) Boolean indexing</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = np.random().radn(<span class="number">2</span>, <span class="number">2</span>) // 랜덤한 숫자로 <span class="number">2</span>*<span class="number">2</span> 배열 생성</span><br><span class="line">data &lt;= <span class="number">0</span> // <span class="number">0</span>보다 작은 숫자 이렇게 boolean으로 바로 찾을수도 있다.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([ True, False],</span><br><span class="line">      [False, False])</span><br></pre></td></tr></table></figure><h2 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h2><ul><li>연산하려는 행렬의 shape, 값 등을 조정하기 위한 테크닉 알 필요가 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arrange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">arr + <span class="number">3</span> // 모든 값에 <span class="number">3</span>씩 더해준다</span><br><span class="line">arr + np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) // 각 행마다 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]을 더해준다</span><br><span class="line">arr * <span class="number">3</span> // 모든 값에 <span class="number">3</span>을 곱해준다</span><br></pre></td></tr></table></figure><h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><ul><li><p><strong>np.argmax(arr)</strong> : 가장 값이 큰 value의 인덱스를 반환한다. argmin()도 있다.</p></li><li><p><strong>np.unique(arr)</strong> : array안에 있는 unique한 값들을 numpy array형태로 반환해준다.</p></li><li><p><strong>np.dtype()</strong> : array의 data type(dtype)을 반환해준다.</p><ul><li>기본적으로 그냥 [1, 2, 3] 뭐 이렇게 넣으면 알아서 ‘int64’ 타입으로 들어간다.</li><li>배열 생성시에 데이터 타입을 지정해줄 수도 있다 : (예시) <code>np.array([[1., 2, 3], [1, 2, 3]], dtype=np.uint8)</code></li></ul></li><li><p><strong>np.astype(‘data type’)</strong> : 값의 data type을 원하는 타입으로 변환해준다.</p></li><li><p><strong>np.ndim()</strong> : 차원 수를 return</p></li><li><p><strong>np.size()</strong> : size 확인</p></li><li><p><strong>np.reshape()</strong> : resize()와는 다르게 사이즈는 유지하면서 모양/차원만 바꿔준다.</p><ul><li><dl><dt>-1 활용.</dt><dd>차원 바꿔주고싶은데 해당 차원에 몇개 들어가야할지 정확히 모를때 그냥 -1쓰면 알아서 계산해서 바꿔준다. 일종의 물음표라고 생각하면 된다.</dd></dl><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">arr.reshape([<span class="number">6</span>]).shape // (<span class="number">6</span>, ) =&gt; <span class="number">1</span>차원 array로 바뀜</span><br><span class="line">arr.reshape([-<span class="number">1</span>]).shape // (<span class="number">6</span>, ) =&gt; <span class="number">1</span>차원으로 바꿔주는데 몇개인지 모를때 그냥 알아서 <span class="number">1</span>차원으로 바꿔줌</span><br><span class="line">arr.reshape([-<span class="number">1</span>, <span class="number">2</span>]).shape // (<span class="number">3</span>, <span class="number">2</span>) =&gt; (?, <span class="number">2</span>)로 바꿔달라는 말과 동일하며, 알아서 맞춰서 (<span class="number">3</span>, <span class="number">2</span>)의 배열로 변환해준다.</span><br></pre></td></tr></table></figure></li><li><p>사이즈 변동이 없는 선에서 차원을 늘릴 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]) // (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">arr.reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>) // (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>np.random.rand(M, N, …)</strong> : (M, N, …) 차원의 배열을 랜덤한 숫자로 채워 생성한다.</p></li><li><p><strong>np.ravel()</strong> : 차원을 1차원으로 바꿔서 펼쳐준다. Layer의 flatten을 위한 기능이라고 생각하면 된다.</p></li></ul><h2 id="값을-유지하며-차원을-늘리자-np-expand-dims"><a href="#값을-유지하며-차원을-늘리자-np-expand-dims" class="headerlink" title="값을 유지하며 차원을 늘리자 : np.expand_dims()"></a>값을 유지하며 차원을 늘리자 : <code>np.expand_dims()</code></h2><p>: reshape으로도 차원을 늘릴 수는 있지만 동일한 형태 유지하면서 차원만 늘리려면 안에 들어있는 값 개수를 알아야 한다. 개수를 모를때 차원을 늘리기 위해 사용할 수 있는 함수가 <code>expand_dims()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.expand_dims(</span><br><span class="line">                 arr, // 차원을 늘릴 numpy array</span><br><span class="line">                 <span class="number">0</span>// <span class="number">0</span>: 차원을 뒤에 붙임, -<span class="number">1</span>: 차원을 앞에 붙임</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/12/05/ai-start5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Tensorflow 2.0] Subclassing 구현</title>
      <link>https://katie0809.github.io/2020/11/29/tf-study7/</link>
      <guid>https://katie0809.github.io/2020/11/29/tf-study7/</guid>
      <pubDate>Sun, 29 Nov 2020 06:33:21 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;TensorFlow 2.0으로 베우는 딥러닝 입문 강의를 들으며 공부한 내용입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;복습 겸 입문 강의를 쭉 훑으면서 기초를 다시 다져보려 한다. Subclassing 코딩스타일을 익혀보자.&lt;/p&gt;
&lt;p&gt;강의에 사용된 예제 코드는 이전에 다뤄본 MNIST 숫자분류 코드로 깃헙 주소는 아래와 같다. -&amp;gt; &lt;a href=&quot;https://github.com/solaris33/deep-learning-tensorflow-book-code/blob/master/Ch04-Machine_Learning_Basic/mnist_classification_using_softmax_regression_v2_keras.py&quot;&gt;여기!&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li>TensorFlow 2.0으로 베우는 딥러닝 입문 강의를 들으며 공부한 내용입니다.</li></ul><p>복습 겸 입문 강의를 쭉 훑으면서 기초를 다시 다져보려 한다. Subclassing 코딩스타일을 익혀보자.</p><p>강의에 사용된 예제 코드는 이전에 다뤄본 MNIST 숫자분류 코드로 깃헙 주소는 아래와 같다. -&gt; <a href="https://github.com/solaris33/deep-learning-tensorflow-book-code/blob/master/Ch04-Machine_Learning_Basic/mnist_classification_using_softmax_regression_v2_keras.py">여기!</a></p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tf.keras.Model을 이용해서 Softmax Regression 모델을 정의합니다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoftmaxRegression</span>(<span class="params">tf.keras.Model</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(SoftmaxRegression, self).__init__()</span><br><span class="line">    self.softmax_layer = tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="literal">None</span>, kernel_initializer=<span class="string">&#x27;zeros&#x27;</span>, bias_initializer=<span class="string">&#x27;zeros&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    logits = self.softmax_layer(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tf.nn.softmax(logits)</span><br></pre></td></tr></table></figure><ul><li>케라스 서브클래싱 방식을 사용한 코드패턴이다.</li><li>tf.keras.Model을 상속받는 클래스를 하나 정의해준다. </li><li>생성자 init과 호출부 call 로직을 정의해준다. 생성자에서는 super 메서드를 통해 tf.keras.model의 생성자를 상속받는 형태로 정의해준다.</li><li>클래스 변수로 원하는 모델 구조의 API를 선언해준다.</li><li>클래스 호출부 call 메서드에서는 인자값으로 input data x를 받고 생성자 부분에서 정의했던 클래스 변수들(softmax_layer)을 순차적으로 호출한다 =&gt; 전체 모델 구조의 output 반환값을 계산(logits).</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 최적화를 위한 function을 정의합니다.</span></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span>(<span class="params">model, x, y</span>):</span></span><br><span class="line">  <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    y_pred = model(x)</span><br><span class="line">    loss = cross_entropy_loss(y_pred, y)</span><br><span class="line">  gradients = tape.gradient(loss, model.trainable_variables)</span><br><span class="line">  optimizer.apply_gradients(<span class="built_in">zip</span>(gradients, model.trainable_variables))</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.tensorflow.org/guide/autodiff?hl=ko">GradientTape에 대한 공식문서</a></li><li>GradientTape은 자동으로 <code>context 내에서 실행된 모든 연산을 tape에 기록</code> 한다. 이후, <strong>tape.gradient(z, y)</strong> 를 호출하면 GradientTape에 포함된 리소스가 해제되면서 y에 대한 도함수를 계산한다.</li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/11/29/tf-study7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SK 코딩테스트 후기 - String다루기</title>
      <link>https://katie0809.github.io/2020/10/12/codility5/</link>
      <guid>https://katie0809.github.io/2020/10/12/codility5/</guid>
      <pubDate>Mon, 12 Oct 2020 07:23:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;SK 계열사 중 한곳에 지원, 지난 토요일 코딩테스트를 치뤘다. IDE는 후기에서 말한대로 Codility를 사용했다. &lt;/p&gt;
&lt;p&gt;문제는 총 3문제였는데 첫 2개를 30분동안 다 풀고 마지막 1개를 결국 못풀었다… 아쉽다.. 느낌상 셋다 풀고 3번에서 효율성이 떨어지는 정도여야 통과일 것 같아서 마음을 비우고 있는 중이다.&lt;/p&gt;
&lt;p&gt;어쨌든 이번이 첫 지원이니 너무 마음쓰지 않으련다. 다음 시험때 더 잘하면 되지. 그럼 의미에서 문제를 복기하고 헤맨 원인을 찾아보려 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>SK 계열사 중 한곳에 지원, 지난 토요일 코딩테스트를 치뤘다. IDE는 후기에서 말한대로 Codility를 사용했다. </p><p>문제는 총 3문제였는데 첫 2개를 30분동안 다 풀고 마지막 1개를 결국 못풀었다… 아쉽다.. 느낌상 셋다 풀고 3번에서 효율성이 떨어지는 정도여야 통과일 것 같아서 마음을 비우고 있는 중이다.</p><p>어쨌든 이번이 첫 지원이니 너무 마음쓰지 않으련다. 다음 시험때 더 잘하면 되지. 그럼 의미에서 문제를 복기하고 헤맨 원인을 찾아보려 한다.</p><span id="more"></span><h1 id="왜-못풀었는가"><a href="#왜-못풀었는가" class="headerlink" title="왜 못풀었는가"></a>왜 못풀었는가</h1><p>: 사실 이건 어떻게 적든간에 변명밖에 되지 않는다. 내가 좀더 준비되어 있었다면 어떤 방식, 어떤 루트를 취했어도 풀었을 것이다. 일단 문제자체가 “풀이가 어려운” 스타일의 문제가 아니었다. 시험시간 내내 실제 문제를 푸는 로직이 아니라 언어 문법에 얽매어 시간을 허비했던 것이 너무나도 아쉽다. 요리로 비유하자면 요리를 하다 어려워서 시간이 다 간게 아니라 당근을 숟가락으로 썰어야 해서 당근만 썰다 끝난 기분이었다.</p><p>결국 내가 생각한 가장 큰 원인은 바보같이 이 문제를 C++로 풀려 했다는거다. 나는 이 문제를 보고, 로직을 정리하기도 전에 “아 이건 문자열을 엄청나게 다루는 문제구나. 파이썬으로 풀어야지” 뭐 이런 생각을 했어야 했다. 하지만 결국은 내탓이다. 파이썬으로 알고리즘 연습을 많이 하지않아 멈칫했고, 분명 언어를 바꿀까 고민도 했지만 끝내는 바꾸지 못했던거다. 시험 보기전에 딱 한번만이라도 파이썬으로 문제를 풀어보고 치뤘다면 아마 이 문제를 풀 수 있었을거다.</p><p>문제는 간단했다. 대충 파일명들이 하나의 긴 스트링으로 주어지고, 이 파일명에서 특정 정보 A, B를 뽑아내 A로 그루핑한 후 각 그룹내에서 B로 정렬하는거다. 그런데 바보같이 이걸 C++로 풀려 하니깐 세상에 스트링 tokenizer 함수부터 새로 짜야하더라.. 자바스크립트에 너무 익숙해져서 C++이 얼마나 문자열 다루기에 최악이었는지 잊고있었다… 그리고 그걸 시험시간 40분 남겨두고 기억해냈다ㅠ 나는 선택지가 없었다…</p><h1 id="문제-정리"><a href="#문제-정리" class="headerlink" title="문제 정리"></a>문제 정리</h1><h2 id="1-주어지는-파일포멧"><a href="#1-주어지는-파일포멧" class="headerlink" title="1. 주어지는 파일포멧"></a>1. 주어지는 파일포멧</h2><ul><li>이름.확장자, 도시, yyyy-mm-dd hh:mm:ss</li></ul><h2 id="2-정리방법"><a href="#2-정리방법" class="headerlink" title="2. 정리방법"></a>2. 정리방법</h2><ul><li>도시별로 묶는다</li><li>같은 도시에서 찍힌 시간별로 정렬한다</li><li>새 이름은 [도시명] [숫자인덱스].원래확장자<ul><li>숫자 인덱스는 같은 도시그룹의 개수따라 001, 002… 와 같이 leading zero 붙여준다</li></ul></li><li>기존 파일명을 새 파일명으로 바꾼 배열 반환한다.</li></ul><h2 id="3-기타조건"><a href="#3-기타조건" class="headerlink" title="3. 기타조건"></a>3. 기타조건</h2><ul><li>사진 M개, 날짜 2000-2020년</li><li>이름 중복가능, 모두 영어</li><li>동일도시, 동일시간은 없다</li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/12/codility5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 - (4) Prefix Sums</title>
      <link>https://katie0809.github.io/2020/10/09/codility4/</link>
      <guid>https://katie0809.github.io/2020/10/09/codility4/</guid>
      <pubDate>Fri, 09 Oct 2020 05:46:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;prefix sum은 부분합 배열을 의미한다. 개념은 단순하다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;다음과 같은 배열 A가 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A = [ 1, 4, 6, 3, 7, 9 ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;이때 배열 A의 prefix sum, 즉 부분합 배열 K는 아래와 같다&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;K = [ 1, 5, 11, 14, 21, 30 ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;상당히 간단한 개념이다. 고등학교 수학시간에 배웠던 것 같은데. 여튼 prefix sum의 장점은 구간의 부분합을 쉽게 구할 수 있다는 점이다.&lt;/p&gt;
&lt;p&gt;즉, A[3] + A[4] + A[5] = K[5] - K[2]이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>prefix sum은 부분합 배열을 의미한다. 개념은 단순하다</p><ol><li><p>다음과 같은 배열 A가 있다.</p><blockquote><p>A = [ 1, 4, 6, 3, 7, 9 ]</p></blockquote></li><li><p>이때 배열 A의 prefix sum, 즉 부분합 배열 K는 아래와 같다</p></li></ol><blockquote><p>K = [ 1, 5, 11, 14, 21, 30 ]</p></blockquote><p>상당히 간단한 개념이다. 고등학교 수학시간에 배웠던 것 같은데. 여튼 prefix sum의 장점은 구간의 부분합을 쉽게 구할 수 있다는 점이다.</p><p>즉, A[3] + A[4] + A[5] = K[5] - K[2]이다.</p><span id="more"></span><h1 id="Question-1-CountDiv"><a href="#Question-1-CountDiv" class="headerlink" title="Question 1 - CountDiv"></a>Question 1 - CountDiv</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> K)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given three integers A, B and K, returns the number of integers within the range [A..B] that are divisible by K, i.e.:</span><br><span class="line"></span><br><span class="line">&#123; i : A ≤ i ≤ B, i mod K = <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">For example, <span class="keyword">for</span> A = <span class="number">6</span>, B = <span class="number">11</span> and K = <span class="number">2</span>, your function should <span class="keyword">return</span> <span class="number">3</span>, because there are three numbers divisible by <span class="number">2</span> within the range [<span class="number">6.</span><span class="number">.11</span>], namely <span class="number">6</span>, <span class="number">8</span> and <span class="number">10.</span></span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">A and B are integers within the range [<span class="number">0.</span><span class="number">.2</span>,<span class="number">000</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">K is an integer within the range [<span class="number">1.</span><span class="number">.2</span>,<span class="number">000</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">A ≤ B.</span><br></pre></td></tr></table></figure><ul><li>주어진 A와 B 사이의 숫자들 중 K로 나누어질 수 있는 수의 개수를 반환하라.</li><li>나누어 떨어진다의 기준이 X%K == 0 인것이 함정. 0%K == 0이므로 A,B가 0인 경우에 대한 예외처리가 필요했다.</li><li>엄청 간단하다고 생각했는데 내가 늘 그렇듯 자꾸 대충짜서 내니깐 edge case에서 예외가 많이 걸림…</li><li>Codility는 테스트 케이스를 너무 조금준다ㅠㅠ 예외경우도 생각하는게 물론 개발자의 역량이라지만 코딩보다 테스트가 오래걸려서 답답한걸 어카나요..^^ㅠ</li></ul><h2 id="My-Solution-100"><a href="#My-Solution-100" class="headerlink" title="My Solution(100%)"></a>My Solution(100%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(B==K) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(B&lt;K) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        ret += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> Adivisible = (A==<span class="number">0</span>) ? <span class="number">0</span> : (A<span class="number">-1</span>) / K;</span><br><span class="line">    <span class="keyword">int</span> Bdivisible = B / K;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(A==B &amp;&amp; B%K==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret + (Bdivisible - Adivisible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>지금 풀고나니 생각나네 아… 이걸 그냥 부분합으로 풀걸;;;; 개멍청쓰;;</li></ul><h1 id="Question-2-MinDnaSequence"><a href="#Question-2-MinDnaSequence" class="headerlink" title="Question 2 - MinDnaSequence"></a>Question 2 - MinDnaSequence</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">A DNA sequence can be represented as a string consisting of the letters A, C, G and T, which correspond to the types of successive nucleotides in the sequence. Each nucleotide has an impact factor, which is an integer. Nucleotides of types A, C, G and T have impact factors of <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> and <span class="number">4</span>, respectively. You are going to answer several queries of the form: What is the minimal impact factor of nucleotides contained in a particular part of the given DNA sequence?</span><br><span class="line"></span><br><span class="line">The DNA sequence is given as a non-empty string S = S[<span class="number">0</span>]S[<span class="number">1</span>]...S[N-<span class="number">1</span>] consisting of N characters. There are M queries, which are given in non-empty arrays P and Q, each consisting of M integers. The K-<span class="function">th <span class="title">query</span> <span class="params">(<span class="number">0</span> ≤ K &lt; M)</span> <span class="keyword">requires</span> you to find the minimal impact factor of nucleotides contained in the DNA sequence between positions P[K] and Q[K] <span class="params">(inclusive)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">For example, consider string S </span>= CAGCCTA and arrays P, Q such that:</span><br><span class="line"></span><br><span class="line">    P[<span class="number">0</span>] = <span class="number">2</span>    Q[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    P[<span class="number">1</span>] = <span class="number">5</span>    Q[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">    P[<span class="number">2</span>] = <span class="number">0</span>    Q[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">The answers to these M = <span class="number">3</span> queries are as follows:</span><br><span class="line"></span><br><span class="line">The part of the DNA between positions <span class="number">2</span> and <span class="number">4</span> <span class="function">contains nucleotides G and <span class="title">C</span> <span class="params">(twice)</span>, whose impact factors are 3 and 2 respectively, so the answer is 2.</span></span><br><span class="line"><span class="function">The part between positions 5 and 5 contains a single nucleotide T, whose impact factor is 4, so the answer is 4.</span></span><br><span class="line"><span class="function">The part between positions 0 and 6 <span class="params">(the whole string)</span> contains all nucleotides, in particular nucleotide A whose impact factor is 1, so the answer is 1.</span></span><br><span class="line"><span class="function">Write a function:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Solution </span>&#123; <span class="keyword">public</span> <span class="keyword">int</span>[] solution(String S, <span class="keyword">int</span>[] P, <span class="keyword">int</span>[] Q); &#125;</span><br><span class="line"></span><br><span class="line">that, given a non-empty string S consisting of N characters and two non-empty arrays P and Q consisting of M integers, returns an array consisting of M integers specifying the consecutive answers to all queries.</span><br><span class="line"></span><br><span class="line">Result array should be returned as an array of integers.</span><br><span class="line"></span><br><span class="line">For example, given the string S = CAGCCTA and arrays P, Q such that:</span><br><span class="line"></span><br><span class="line">    P[<span class="number">0</span>] = <span class="number">2</span>    Q[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    P[<span class="number">1</span>] = <span class="number">5</span>    Q[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">    P[<span class="number">2</span>] = <span class="number">0</span>    Q[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">the function should <span class="keyword">return</span> the values [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>], as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">1.</span><span class="number">.100</span>,<span class="number">000</span>];</span><br><span class="line">M is an integer within the range [<span class="number">1.</span><span class="number">.50</span>,<span class="number">000</span>];</span><br><span class="line">each element of arrays P, Q is an integer within the range [<span class="number">0.</span>.N − <span class="number">1</span>];</span><br><span class="line">P[K] ≤ Q[K], where <span class="number">0</span> ≤ K &lt; M;</span><br><span class="line">string S consists only of upper-<span class="keyword">case</span> English letters A, C, G, T.</span><br></pre></td></tr></table></figure><ul><li>문제가 엄청길다ㅜㅠ</li><li>Nucleotide는 총 4가지가 있다. 각각은 정수값 impact factor과 매칭된다.<ul><li>A:1, C:2, G:3, T:4</li></ul></li><li>N개의 문자열로 이뤄진 DNA sequence가 있다.</li><li>길이 M의 non-empty array P, Q 가 있다.</li><li>Query K는 다음을 의미한다<ul><li>DNA sequence의 P[K]와 Q[K] 위치 사이의 minical impact factor를 찾아라</li></ul></li></ul><h2 id="My-Solution-67"><a href="#My-Solution-67" class="headerlink" title="My Solution(67%)"></a>My Solution(67%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(string &amp;S, vector&lt;<span class="keyword">int</span>&gt; &amp;P, vector&lt;<span class="keyword">int</span>&gt; &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="comment">// nucleotide A, C, G, T의 DNA Sequence idx별 등장횟수</span></span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">4</span>][<span class="number">55555</span>];</span><br><span class="line">    <span class="comment">// nucleotide의 impact factor</span></span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; impFac = &#123;&#123;<span class="string">&#x27;A&#x27;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>&#125;,&#123;<span class="string">&#x27;G&#x27;</span>, <span class="number">2</span>&#125;,&#123;<span class="string">&#x27;T&#x27;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;S.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> dnaChar = S.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">int</span> impactFactIdx = impFac[dnaChar];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 모든 문자의 등장횟수는 기본적으로 이전 등장횟수</span></span><br><span class="line">        count[<span class="number">0</span>][i] = (i==<span class="number">0</span>) ? <span class="number">0</span> : count[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        count[<span class="number">1</span>][i] = (i==<span class="number">0</span>) ? <span class="number">0</span> : count[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">        count[<span class="number">2</span>][i] = (i==<span class="number">0</span>) ? <span class="number">0</span> : count[<span class="number">2</span>][i<span class="number">-1</span>];</span><br><span class="line">        count[<span class="number">3</span>][i] = (i==<span class="number">0</span>) ? <span class="number">0</span> : count[<span class="number">3</span>][i<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 등장한 문자의 횟수 +1</span></span><br><span class="line">        count[impactFactIdx][i] = (i==<span class="number">0</span>) ? count[impactFactIdx][<span class="number">0</span>]+<span class="number">1</span> : count[impactFactIdx][i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;P.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> queryStartIdx = P[i]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> queryEndIdx = Q[i];</span><br><span class="line">        <span class="keyword">int</span> parDiff[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">            parDiff[j] = queryStartIdx&lt;<span class="number">0</span> ? count[j][queryEndIdx] : count[j][queryEndIdx] - count[j][queryStartIdx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parDiff[j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>로직은 얼추 맞는듯 한데 large dataset에서 런타임 에러가 발생한다. push_back이 너무 느린건가..</li></ul><h1 id="Question-2-MinAvgTwoSlice"><a href="#Question-2-MinAvgTwoSlice" class="headerlink" title="Question 2 - MinAvgTwoSlice"></a>Question 2 - MinAvgTwoSlice</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">A non-empty array A consisting of N integers is given. <span class="function">A pair of <span class="title">integers</span> <span class="params">(P, Q)</span>, such that 0 ≤ P &lt; Q &lt; N, is called a slice of array <span class="title">A</span> <span class="params">(notice that the slice contains at least two elements)</span>. The average of a <span class="title">slice</span> <span class="params">(P, Q)</span> is the sum of A[P] + A[P + 1] + ... + A[Q] divided by the length of the slice. To be precise, the average <span class="title">equals</span> <span class="params">(A[P] + A[P + <span class="number">1</span>] + ... + A[Q])</span> / <span class="params">(Q − P + <span class="number">1</span>)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">For example, array A such that:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    A[<span class="number">0</span>] =</span> <span class="number">4</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    A[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    A[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">    A[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    A[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">    A[<span class="number">6</span>] = <span class="number">8</span></span><br><span class="line">contains the following example slices:</span><br><span class="line"></span><br><span class="line"><span class="built_in">slice</span> (<span class="number">1</span>, <span class="number">2</span>), whose average <span class="built_in">is</span> (<span class="number">2</span> + <span class="number">2</span>) / <span class="number">2</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">slice</span> (<span class="number">3</span>, <span class="number">4</span>), <span class="function">whose average <span class="title">is</span> <span class="params">(<span class="number">5</span> + <span class="number">1</span>)</span> / 2 </span>= <span class="number">3</span>;</span><br><span class="line"><span class="built_in">slice</span> (<span class="number">1</span>, <span class="number">4</span>), <span class="function">whose average <span class="title">is</span> <span class="params">(<span class="number">2</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">1</span>)</span> / 4 </span>= <span class="number">2.5</span>.</span><br><span class="line">The goal is to find the starting position of a slice whose average is minimal.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given a non-empty array A consisting of N integers, returns the starting position of the slice with the minimal average. If there is more than one slice with a minimal average, you should <span class="keyword">return</span> the smallest starting position of such a slice.</span><br><span class="line"></span><br><span class="line">For example, given array A such that:</span><br><span class="line"></span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    A[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    A[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">    A[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    A[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">    A[<span class="number">6</span>] = <span class="number">8</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">1</span>, as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">2.</span><span class="number">.100</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [−<span class="number">10</span>,<span class="number">000.</span><span class="number">.10</span>,<span class="number">000</span>].</span><br></pre></td></tr></table></figure><h2 id="My-Solution-60"><a href="#My-Solution-60" class="headerlink" title="My Solution(60%)"></a>My Solution(60%)</h2><ul><li>memset 사용시에는 string.h 헤더 포함해야 한다.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> N = A.<span class="built_in">size</span>(); <span class="comment">// 배열 A의 길이</span></span><br><span class="line">    <span class="keyword">int</span> parSum[N+<span class="number">1</span>]; <span class="comment">// 부분합 배열</span></span><br><span class="line">    <span class="built_in">memset</span>(parSum, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(N+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 배열 A의 부분합을 구한다.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        parSum[i+<span class="number">1</span>] = parSum[i] + A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 각 부분합에 대해 평균을 구한다. 동시에 부분합의 평균이 최소가 인덱스를 구한다.</span></span><br><span class="line">    <span class="keyword">double</span> min = <span class="number">111111</span>;</span><br><span class="line">    <span class="keyword">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;N; p++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;N; q++)&#123;</span><br><span class="line">            <span class="keyword">double</span> diff = parSum[q+<span class="number">1</span>] - parSum[p];</span><br><span class="line">            <span class="keyword">double</span> avg = diff / (q-p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(avg &lt; min)&#123;</span><br><span class="line">                min = avg;</span><br><span class="line">                minIdx = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>아이디어가 안떠올라서 일단 가장 간단하게 구현한 코드..ㅠ O(N^2 / 2) 이므로 당연하게도 timeout error가 났다.</li><li>구글신의 힘을 빌렸다. 아주 그냥 수학문제다 머리아파;;<br>: <a href="https://nukeguys.tistory.com/175">https://nukeguys.tistory.com/175</a></li></ul><h1 id="Question-3-괄호변환"><a href="#Question-3-괄호변환" class="headerlink" title="Question 3 - 괄호변환"></a>Question 3 - <a href="https://tech.kakao.com/2019/10/02/kakao-blind-recruitment-2020-round1/">괄호변환</a></h1><ul><li>디스크 겹치는거 풀다가 도저히 머리가 이해를 못해서 카카오 신입채용 문제로 급선회</li><li>익숙한 dfs문제이다.</li><li><strong>stack의 top()연산은 stack이 비어있으면 Segmentation fault에러가 발생한다.</strong></li></ul><h2 id="My-Solution-100-1"><a href="#My-Solution-100-1" class="headerlink" title="My Solution(100%)"></a>My Solution(100%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">flip</span><span class="params">(string u)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 첫번째와 마지막 문자를 제거한다.</span></span><br><span class="line">    string parU = u.<span class="built_in">substr</span>(<span class="number">1</span>, u.<span class="built_in">length</span>()<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 괄호방향을 뒤집는다.</span></span><br><span class="line">    string ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;parU.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parU.<span class="built_in">at</span>(i) == <span class="string">&#x27;(&#x27;</span>) ret += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(parU.<span class="built_in">at</span>(i) == <span class="string">&#x27;)&#x27;</span>) ret += <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCorrect</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">solve</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">length</span>() &lt;= <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> wIdx = p.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;p.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = p.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            st += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            st -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st == <span class="number">0</span>)&#123; <span class="comment">// 균형잡힌 문자열 u를 얻음</span></span><br><span class="line">            wIdx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string u = p.<span class="built_in">substr</span>(<span class="number">0</span>, wIdx+<span class="number">1</span>);</span><br><span class="line">    string v = (wIdx == p.<span class="built_in">length</span>()<span class="number">-1</span>) ? <span class="string">&quot;&quot;</span> : <span class="built_in">solve</span>(p.<span class="built_in">substr</span>(wIdx + <span class="number">1</span>, p.<span class="built_in">length</span>()<span class="number">-1</span>-wIdx));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isCorrect</span>(u))&#123; <span class="comment">// u가 올바른 문자열인 경우</span></span><br><span class="line">        <span class="keyword">return</span> u+v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// u가 올바른 문자열이 아닌 경우</span></span><br><span class="line">        string newU = <span class="string">&quot;(&quot;</span>;</span><br><span class="line">        newU += v;</span><br><span class="line">        newU += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        newU += <span class="built_in">flip</span>(u);</span><br><span class="line">        <span class="keyword">return</span> newU;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">solution</span><span class="params">(string p)</span> </span>&#123;</span><br><span class="line">    string answer = <span class="built_in">solve</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/09/codility4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 - (3) Counting Elements</title>
      <link>https://katie0809.github.io/2020/10/09/codility3/</link>
      <guid>https://katie0809.github.io/2020/10/09/codility3/</guid>
      <pubDate>Thu, 08 Oct 2020 16:24:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;Codility사이트는 해당 Lessons관련 이론 pdf파일도 같이 제공해준다. pdf 파일이 굉장히 대학시절 알고리즘 교재에서 본것처럼 생겼다.&lt;/p&gt;
&lt;p&gt;여튼 생짜로 머리에서 아이디어를 꺼내는 것 보다 이 관련 자료를 읽고 힌트를 얻어 문제를 푸는게 훨씬 유용한 것 같다!!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codility.com/media/train/2-CountingElements.pdf&quot;&gt;Counting Elements.pdf&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그룹 A와 B가 있다. 두 그룹에서 하나의 페어를 찾아 바꿈으로서 각 그룹의 총합이 같도록 만들수 있는지를 판별하려면?&lt;/li&gt;
&lt;li&gt;각 그룹의 총합의 차를 구한다. 그룹1의 총합이 10, 그룹2의 총합이 13이라고 해보자. 이때 &lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Codility사이트는 해당 Lessons관련 이론 pdf파일도 같이 제공해준다. pdf 파일이 굉장히 대학시절 알고리즘 교재에서 본것처럼 생겼다.</p><p>여튼 생짜로 머리에서 아이디어를 꺼내는 것 보다 이 관련 자료를 읽고 힌트를 얻어 문제를 푸는게 훨씬 유용한 것 같다!!</p><p><a href="https://codility.com/media/train/2-CountingElements.pdf">Counting Elements.pdf</a></p><ul><li>그룹 A와 B가 있다. 두 그룹에서 하나의 페어를 찾아 바꿈으로서 각 그룹의 총합이 같도록 만들수 있는지를 판별하려면?</li><li>각 그룹의 총합의 차를 구한다. 그룹1의 총합이 10, 그룹2의 총합이 13이라고 해보자. 이때 </li></ul><span id="more"></span><h1 id="Question1-FrogRiverOne"><a href="#Question1-FrogRiverOne" class="headerlink" title="Question1 - FrogRiverOne"></a>Question1 - FrogRiverOne</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">A small frog wants to get to the other side of a river. <span class="function">The frog is initially located on one bank of the <span class="title">river</span> <span class="params">(position <span class="number">0</span>)</span> and wants to get to the opposite <span class="title">bank</span> <span class="params">(position X+<span class="number">1</span>)</span>. Leaves fall from a tree onto the surface of the river.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">You are given an array A consisting of N integers representing the falling leaves. A[K] represents the position where one leaf falls at time K, measured in seconds.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">The goal is to find the earliest time when the frog can jump to the other side of the river. The frog can cross only when leaves appear at every position across the river from 1 to <span class="title">X</span> <span class="params">(that is, we want to find the earliest moment when all the positions from <span class="number">1</span> to X are covered by leaves)</span>. You may assume that the speed of the current in the river is negligibly small, i.e. the leaves <span class="keyword">do</span> not change their positions once they fall in the river.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">For example, you are given integer X </span>= <span class="number">5</span> and array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">  A[<span class="number">4</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">5</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">  A[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line">In second <span class="number">6</span>, a leaf falls into position <span class="number">5.</span> This is the earliest time when leaves appear in every position across the river.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given a non-empty array A consisting of N integers and integer X, returns the earliest time when the frog can jump to the other side of the river.</span><br><span class="line"></span><br><span class="line">If the frog is never able to jump to the other side of the river, the function should <span class="keyword">return</span> −<span class="number">1.</span></span><br><span class="line"></span><br><span class="line">For example, given X = <span class="number">5</span> and array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">  A[<span class="number">4</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">5</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">  A[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">6</span>, as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N and X are integers within the range [<span class="number">1.</span><span class="number">.100</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [<span class="number">1.</span>.X].</span><br></pre></td></tr></table></figure><h2 id="My-Solution-100"><a href="#My-Solution-100" class="headerlink" title="My Solution(100%)"></a>My Solution(100%)</h2><ul><li><a href="https://codingham.tistory.com/158">배열초기화 참고</a></li><li>1-X까지의 합을 구해두고 counting board에 새로운 정수가 등록될 때마다 현재 sum을 구한다. 현재 sum이 1-X까지의 합과 같아지는 순간이 개구리가 뛸 수 있는 순간.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> sum = (<span class="number">1</span> + X) * X / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> countBoard[<span class="number">111111</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(countBoard, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>) * <span class="number">111111</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = A[i];</span><br><span class="line">        <span class="keyword">if</span>(!countBoard[k])&#123;</span><br><span class="line">            <span class="comment">// K never occured before</span></span><br><span class="line">            curSum += k;</span><br><span class="line">            countBoard[k] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curSum == sum) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Question2-Max-Counters"><a href="#Question2-Max-Counters" class="headerlink" title="Question2 - Max Counters"></a>Question2 - Max Counters</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">You are given N counters, initially set to <span class="number">0</span>, <span class="keyword">and</span> you have two possible operations on them:</span><br><span class="line"></span><br><span class="line"><span class="built_in">increase</span>(X) − counter X is increased by <span class="number">1</span>,</span><br><span class="line">max counter − all counters are set to the maximum value of any counter.</span><br><span class="line">A non-empty array A of M integers is given. This array represents consecutive operations:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> A[K] = X, such that <span class="number">1</span> ≤ X ≤ N, then operation K is <span class="built_in">increase</span>(X),</span><br><span class="line"><span class="keyword">if</span> A[K] = N + <span class="number">1</span> then operation K is max counter.</span><br><span class="line">For example, given integer N = <span class="number">5</span> <span class="keyword">and</span> array A such that:</span><br><span class="line"></span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    A[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    A[<span class="number">5</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line">the values of the counters after each consecutive operation will be:</span><br><span class="line"></span><br><span class="line">    (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">    (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    (<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    (<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    (<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">The goal is to calculate the value of every counter after all operations.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line">class Solution &#123; <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="built_in">solution</span>(<span class="keyword">int</span> N, <span class="keyword">int</span>[] A); &#125;</span><br><span class="line"></span><br><span class="line">that, given an integer N <span class="keyword">and</span> a non-empty array A consisting of M integers, returns a sequence of integers representing the values of the counters.</span><br><span class="line"></span><br><span class="line">Result array should be returned as an array of integers.</span><br><span class="line"></span><br><span class="line">For example, given:</span><br><span class="line"></span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    A[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    A[<span class="number">5</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line">the function should <span class="keyword">return</span> [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>], as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N <span class="keyword">and</span> M are integers within the range [<span class="number">1.</span><span class="number">.100</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [<span class="number">1.</span>.N + <span class="number">1</span>].</span><br></pre></td></tr></table></figure><ul><li>길이 N의 카운터 배열이 있다(0으로 초기화됨)</li><li>각 카운터에 대해 어떤 연산을 할지 기준이 되는 연산배열 A가 있다.</li><li>배열A의 값에 따라 카운터 연산이 달라진다(A의 길이는 M)<ul><li>A[k]의 값 X가 1보다 크거나 같고 N보다 작거나 같다면 counter[X]++</li><li>A[k]의 값이 N+1과 같다면 counter배열의 모든 값은 현재 카운터 중 최대값으로 변경</li></ul></li><li>배열A의 모든 값의 범위는 [1, N+1]</li><li>연산이 완료된 이후의 카운터 배열을 반환하라.</li></ul><h2 id="My-Solution1-77"><a href="#My-Solution1-77" class="headerlink" title="My Solution1(77%)"></a>My Solution1(77%)</h2><ul><li>동적 배열할당시에 new와 delete 키워드를 사용한다.</li><li><a href="https://boycoding.tistory.com/205">동적배열 할당 및 해제</a></li><li><code>int *counter</code> 로 전역변수 선언</li><li><code>counter = new int[N]()</code> 길이 N의 배열 동적 생성후 0으로 초기화한다.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max Counter</span></span><br><span class="line"><span class="keyword">int</span> *_counter;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">int</span> maxCounterVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max Counter</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 길이 N의 카운터 배열 생성후 0으로 초기화</span></span><br><span class="line">    <span class="comment">// _counter = new int[N]();</span></span><br><span class="line">    counter.<span class="built_in">resize</span>(N);</span><br><span class="line">    maxCounterVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> K = A[i];</span><br><span class="line">        <span class="keyword">if</span>(K == N+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">fill</span>(counter.<span class="built_in">begin</span>(), counter.<span class="built_in">end</span>(), maxCounterVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            counter[K<span class="number">-1</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(counter[K<span class="number">-1</span>] &gt; maxCounterVal) maxCounterVal = counter[K<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>문제에서 얘기하는 내용을 그대로 정직하게 구현함.</li><li>값은 제대로 반환하지만 large dataset에서 timeout error가 발생한다.</li><li>해당 레슨의 핵심이 Counting Elements인 것에 착안해 좀더 고민을 해봤다. 모든 max 연산이 있을때마다 fill을 수행하는 것이 비효율적이다. 최악의 경우 O(N*M)의 성능을 가진 알고리즘.</li></ul><h2 id="My-Solution2-100"><a href="#My-Solution2-100" class="headerlink" title="My Solution2(100%)"></a>My Solution2(100%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max Counter</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">int</span> maxCounterVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max Counter</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 길이 N의 카운터 배열 생성후 0으로 초기화</span></span><br><span class="line">    counter.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> whatToDo = A[i];</span><br><span class="line">        <span class="keyword">if</span>(whatToDo == N+<span class="number">1</span>)&#123;</span><br><span class="line">            prevMax = curMax;</span><br><span class="line">            <span class="comment">// curMax = 0; // 이부분이 틀렸다.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> idx = whatToDo - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> howOftenAppeared = counter[idx];</span><br><span class="line">            <span class="keyword">if</span>(howOftenAppeared &lt; prevMax)&#123;</span><br><span class="line">                counter[idx] = prevMax+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                counter[idx]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(counter[idx] &gt; curMax) curMax = counter[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;counter.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(counter[i] &lt; prevMax) counter[i] = prevMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>max변환 연산이 나오면 <code>변환연산 기준max</code>를 저장해둔다.</li><li>max변환 연산이 아닌 경우는 해당 원소의 카운트값(howOftenAppeared)이  <code>변환연산 기준max</code>보다 큰지 작은지를 비교해서 현재의  <code>변환연산 기준max</code> + 1이나 그냥 +1 이렇게 두가지로 연산 분리한다.</li><li>현재의 max는 계속 업데이트 하다가 변환연산이 나올때마다  <code>변환연산 기준max</code>에 저장해준다.</li><li>최종적으로 다시 전체 카운터 배열을 순회하면서  <code>변환연산 기준max</code>보다 작은값은 기준max값으로 변환해준다.</li><li>아 머리아파ㅠ</li></ul><h1 id="Question-3-FindSmallestInteger"><a href="#Question-3-FindSmallestInteger" class="headerlink" title="Question 3 - FindSmallestInteger"></a>Question 3 - FindSmallestInteger</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">This is a demo task.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given an array A of N integers, <span class="function">returns the smallest positive <span class="title">integer</span> <span class="params">(greater than <span class="number">0</span>)</span> that does not occur in A.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">For example, given A </span>= [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>], the function should <span class="keyword">return</span> <span class="number">5.</span></span><br><span class="line"></span><br><span class="line">Given A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], the function should <span class="keyword">return</span> <span class="number">4.</span></span><br><span class="line"></span><br><span class="line">Given A = [−<span class="number">1</span>, −<span class="number">3</span>], the function should <span class="keyword">return</span> <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">1.</span><span class="number">.100</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [−<span class="number">1</span>,<span class="number">000</span>,<span class="number">000.</span><span class="number">.1</span>,<span class="number">000</span>,<span class="number">000</span>].</span><br></pre></td></tr></table></figure><ul><li>N개의 정수로 이루어진 배열 A</li><li>A 배열에 없는 가장 작은 정수 X를 찾아라(X&gt;0)</li></ul><h2 id="My-Solution-100-1"><a href="#My-Solution-100-1" class="headerlink" title="My Solution(100%)"></a>My Solution(100%)</h2><ul><li>아무리 고민해도 그냥 배열 여러번 순회하는 아이디어밖에 떠오르지 않았다. 이경우 시간복잡도가 대충 O(2N)정도 될것같아서.. 그냥 가장 간단하게 풀었다. 의외로 통과</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> counter[<span class="number">1111111</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> onePositive = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    counter[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> arrVal = A[i];</span><br><span class="line">        <span class="keyword">if</span>(arrVal &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> onePositive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!counter[arrVal]) counter[arrVal] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!onePositive) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!counter[i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/09/codility3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 - (2) Time complexity</title>
      <link>https://katie0809.github.io/2020/10/08/codility2/</link>
      <guid>https://katie0809.github.io/2020/10/08/codility2/</guid>
      <pubDate>Thu, 08 Oct 2020 05:15:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;Lesson 3은 시간복잡도에 관한 예제들이다. 총 3문제!&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Lesson 3은 시간복잡도에 관한 예제들이다. 총 3문제!</p><span id="more"></span><h1 id="Question1-FrogJmp"><a href="#Question1-FrogJmp" class="headerlink" title="Question1 - FrogJmp"></a>Question1 - FrogJmp</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.</span><br><span class="line"></span><br><span class="line">Count the minimal number of jumps that the small frog must perform to reach its target.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> D)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal to or greater than Y.</span><br><span class="line"></span><br><span class="line">For example, given:</span><br><span class="line"></span><br><span class="line">  X = <span class="number">10</span></span><br><span class="line">  Y = <span class="number">85</span></span><br><span class="line">  D = <span class="number">30</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">3</span>, because the frog will be positioned as follows:</span><br><span class="line"></span><br><span class="line">after the first jump, at position <span class="number">10</span> + <span class="number">30</span> = <span class="number">40</span></span><br><span class="line">after the second jump, at position <span class="number">10</span> + <span class="number">30</span> + <span class="number">30</span> = <span class="number">70</span></span><br><span class="line">after the third jump, at position <span class="number">10</span> + <span class="number">30</span> + <span class="number">30</span> + <span class="number">30</span> = <span class="number">100</span></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">X, Y and D are integers within the range [<span class="number">1.</span><span class="number">.1</span>,<span class="number">000</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">X ≤ Y.</span><br></pre></td></tr></table></figure><ul><li>한번에 D씩 움직이는 개구리가 X에서 Y로 가기위해 몇번 점프해야할까?</li></ul><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> gap = Y - X;</span><br><span class="line">    <span class="keyword">int</span> remainder = gap % D;</span><br><span class="line">    <span class="keyword">int</span> jump = gap / D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(gap == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(remainder == <span class="number">0</span>) <span class="keyword">return</span> jump;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> jump+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Question2-PermMissingElem"><a href="#Question2-PermMissingElem" class="headerlink" title="Question2 - PermMissingElem"></a>Question2 - PermMissingElem</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">An array A consisting of N different integers is given. The array contains integers in the range [<span class="number">1.</span>.(N + <span class="number">1</span>)], which means that exactly one element is missing.</span><br><span class="line"></span><br><span class="line">Your goal is to find that missing element.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given an array A, returns the value of the missing element.</span><br><span class="line"></span><br><span class="line">For example, given array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">4</span>, as it is the missing element.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">0.</span><span class="number">.100</span>,<span class="number">000</span>];</span><br><span class="line">the elements of A are all distinct;</span><br><span class="line">each element of array A is an integer within the range [<span class="number">1.</span>.(N + <span class="number">1</span>)].</span><br></pre></td></tr></table></figure><ul><li>N개의 서로다른 정수로 이루어진 배열 A가 주어진다. </li><li>이 길이 N의 배열 A는 1 ~ N+1 까지의 수로 이뤄진다. 즉, 한개가 빠져있는것.</li><li>빠진놈을 찾아라</li></ul><h2 id="My-Solution-50"><a href="#My-Solution-50" class="headerlink" title="My Solution(50%)"></a>My Solution(50%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 받아온 배열 정렬</span></span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]<span class="number">-1</span> != i) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>왜 이게 50%지? 디버깅이 안되니 불편하다ㅠㅠㅠ 디버깅할 방법을 찾아봐야겠음…</li></ul><h1 id="Question3"><a href="#Question3" class="headerlink" title="Question3 -"></a>Question3 -</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">A non-empty array A consisting of N integers is given. Array A represents numbers on a tape.</span><br><span class="line"></span><br><span class="line">Any integer P, such that <span class="number">0</span> &lt; P &lt; N, splits <span class="keyword">this</span> tape into two non-empty parts: A[<span class="number">0</span>], A[<span class="number">1</span>], ..., A[P − <span class="number">1</span>] and A[P], A[P + <span class="number">1</span>], ..., A[N − <span class="number">1</span>].</span><br><span class="line"></span><br><span class="line">The difference between the two parts is the value of: |(A[<span class="number">0</span>] + A[<span class="number">1</span>] + ... + A[P − <span class="number">1</span>]) − (A[P] + A[P + <span class="number">1</span>] + ... + A[N − <span class="number">1</span>])|</span><br><span class="line"></span><br><span class="line">In other words, it is the absolute difference between the sum of the first part and the sum of the second part.</span><br><span class="line"></span><br><span class="line">For example, consider array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">  A[<span class="number">4</span>] = <span class="number">3</span></span><br><span class="line">We can split <span class="keyword">this</span> tape in four places:</span><br><span class="line"></span><br><span class="line">P = <span class="number">1</span>, difference = |<span class="number">3</span> − <span class="number">10</span>| = <span class="number">7</span></span><br><span class="line">P = <span class="number">2</span>, difference = |<span class="number">4</span> − <span class="number">9</span>| = <span class="number">5</span></span><br><span class="line">P = <span class="number">3</span>, difference = |<span class="number">6</span> − <span class="number">7</span>| = <span class="number">1</span></span><br><span class="line">P = <span class="number">4</span>, difference = |<span class="number">10</span> − <span class="number">3</span>| = <span class="number">7</span></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>;</span><br><span class="line"></span><br><span class="line">that, given a non-empty array A of N integers, returns the minimal difference that can be achieved.</span><br><span class="line"></span><br><span class="line">For example, given:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">  A[<span class="number">4</span>] = <span class="number">3</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">1</span>, as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">2.</span><span class="number">.100</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [−<span class="number">1</span>,<span class="number">000.</span><span class="number">.1</span>,<span class="number">000</span>].</span><br></pre></td></tr></table></figure><ul><li>non-empty array A는 N개의 정수로 이루어짐</li><li>P를 기점으로 배열 A는 0<del>(P-1), P</del>(N-1)의 두개 파트로 나뉜다.</li><li>각 파트의 합의 차이를 최소로 만드는 P를 찾아서 그 최소값을 반환하라(이때 파트간 합의 차는 절대값 씌운다.)</li></ul><h2 id="My-Solution-76"><a href="#My-Solution-76" class="headerlink" title="My Solution(76%)"></a>My Solution(76%)</h2><ul><li>양끝에서 인덱스가 같이 다가오는 아이디어로 풀어봤다. </li><li>왼쪽집합과 오른쪽 집합의 합을 구해가면서 집합의 차가 작아지는 방향으로 계속 움직이도록 한다.</li><li>결과는 76점ㅠㅠ 뭘 빼먹은걸까…</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> startIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> endIdx = A.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sumLeft = A[startIdx];</span><br><span class="line">    <span class="keyword">int</span> sumRight = A[endIdx];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">abs</span>(sumLeft - sumRight);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sumLeft == sumRight)&#123;</span><br><span class="line">            <span class="keyword">if</span>(endIdx - startIdx == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(endIdx - startIdx == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">abs</span>(A[startIdx+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(A[startIdx+<span class="number">1</span>] &lt;= <span class="built_in">abs</span>(A[endIdx<span class="number">-1</span>])))&#123;</span><br><span class="line">                    startIdx++;</span><br><span class="line">                    sumLeft += A[startIdx];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    endIdx--;</span><br><span class="line">                    sumRight += A[endIdx];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 더 값이 큰 집합을 작아지게 만들거나</span></span><br><span class="line">        <span class="comment">// 더 값이 작은 집합을 커지게 만든다</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(startIdx+<span class="number">1</span> &gt;= endIdx)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">abs</span>(sumLeft - sumRight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ifMoveRight = <span class="built_in">abs</span>((sumLeft + A[startIdx+<span class="number">1</span>]) - sumRight);</span><br><span class="line">            <span class="keyword">int</span> ifMoveLeft = <span class="built_in">abs</span>(sumLeft - (sumRight + A[endIdx<span class="number">-1</span>]));</span><br><span class="line">            <span class="keyword">if</span>(ifMoveRight &lt;= ifMoveLeft)&#123;</span><br><span class="line">                startIdx++;</span><br><span class="line">                sumLeft += A[startIdx];   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifMoveRight &gt; ifMoveLeft)&#123;</span><br><span class="line">                endIdx--;</span><br><span class="line">                sumRight += A[endIdx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="My-Solution2-100"><a href="#My-Solution2-100" class="headerlink" title="My Solution2(100%)"></a>My Solution2(100%)</h2><ul><li>배열을 순회하면서 각 인덱스까지의 합을 저장한다. 반대로도 병렬 수행</li><li>전체 배열에 대해 두개 배열의 차를 구한다. 최소값을 같이 구한다. 이렇게하면 아마도 O(2N)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> N = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">moveRightBoard</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">moveLeftBoard</span><span class="params">(N)</span></span>;</span><br><span class="line">    </span><br><span class="line">    moveRightBoard[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">    moveLeftBoard[N<span class="number">-1</span>] = A[N<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">abs</span>(A[<span class="number">0</span>] - A[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=N<span class="number">-2</span>; i&lt;A.<span class="built_in">size</span>(); i++, j--)&#123;</span><br><span class="line">        moveRightBoard[i] = moveRightBoard[i<span class="number">-1</span>] + A[i];</span><br><span class="line">        moveLeftBoard[j] = moveLeftBoard[j+<span class="number">1</span>] + A[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">9999999999999999</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="built_in">abs</span>(moveRightBoard[i] - moveLeftBoard[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; min)&#123;</span><br><span class="line">            min = diff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/08/codility2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 - (1) Arrays</title>
      <link>https://katie0809.github.io/2020/10/08/codility1/</link>
      <guid>https://katie0809.github.io/2020/10/08/codility1/</guid>
      <pubDate>Wed, 07 Oct 2020 23:43:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;코딩테스트를 준비할 일이 생겼다. Codility를 통해 공부하자. 어제 아주 기본적인 문제를 풀었는데 정확도가 80%밖에 되지 않았다 제길ㅠ 한창 코테 준비할땐 그래도 나쁘지 않았던 것 같은데… 계속하지 않으면 금방 까먹는 듯 하다.&lt;/p&gt;
&lt;p&gt;난이도별로 여러개의 예제가 엄선되어 있어서 좋다. 백준의 경우에는 너무 많은 예제가 중구난방으로 있어서 뭘 풀어야 할지 감을 잡기 어려운데 그런면에서 훨씬 잘되어 있는 것 같다. 알고리즘에는 역시 C지! 익숙한 C언어로 풀어보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>코딩테스트를 준비할 일이 생겼다. Codility를 통해 공부하자. 어제 아주 기본적인 문제를 풀었는데 정확도가 80%밖에 되지 않았다 제길ㅠ 한창 코테 준비할땐 그래도 나쁘지 않았던 것 같은데… 계속하지 않으면 금방 까먹는 듯 하다.</p><p>난이도별로 여러개의 예제가 엄선되어 있어서 좋다. 백준의 경우에는 너무 많은 예제가 중구난방으로 있어서 뭘 풀어야 할지 감을 잡기 어려운데 그런면에서 훨씬 잘되어 있는 것 같다. 알고리즘에는 역시 C지! 익숙한 C언어로 풀어보자.</p><span id="more"></span><h1 id="Question1-Cyclic-Rotation"><a href="#Question1-Cyclic-Rotation" class="headerlink" title="Question1 - Cyclic Rotation"></a>Question1 - Cyclic Rotation</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>] is [<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>] (elements are shifted right by one index and <span class="number">6</span> is moved to the first place).</span><br><span class="line"></span><br><span class="line">The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K); &#125;</span><br><span class="line"></span><br><span class="line">that, given an array A consisting of N integers and an integer K, returns the array A rotated K times.</span><br><span class="line"></span><br><span class="line">For example, given</span><br><span class="line"></span><br><span class="line">    A = [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">    K = <span class="number">3</span></span><br><span class="line">the function should <span class="keyword">return</span> [<span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>]. Three rotations were made:</span><br><span class="line"></span><br><span class="line">    [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>] -&gt; [<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line">    [<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>] -&gt; [<span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>] -&gt; [<span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>]</span><br><span class="line">For another example, given</span><br><span class="line"></span><br><span class="line">    A = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    K = <span class="number">1</span></span><br><span class="line">the function should <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">Given</span><br><span class="line"></span><br><span class="line">    A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    K = <span class="number">4</span></span><br><span class="line">the function should <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">Assume that:</span><br><span class="line"></span><br><span class="line">N and K are integers within the range [<span class="number">0.</span><span class="number">.100</span>];</span><br><span class="line">each element of array A is an integer within the range [−<span class="number">1</span>,<span class="number">000.</span><span class="number">.1</span>,<span class="number">000</span>].</span><br><span class="line">In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.</span><br></pre></td></tr></table></figure><ul><li>Array를 받는다</li><li>Array를 Rotate 한다는것은 오른쪽으로 한칸 미는것을 의미 -&gt; 바보같이 왼쪽으로 한칸 미는걸로 풀어서 헤맸다</li><li>Array를 K번  Rotate한 결과를 리턴한다.</li></ul><p>문제 solution에서 vector array를 사용한다. 오랜만에 vector를 보니 잘 기억나지 않아서 정리!</p><p><a href="http://www.cplusplus.com/reference/vector/vector/">http://www.cplusplus.com/reference/vector/vector/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 벡터의 선언 */</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;        <span class="comment">//int형 백터 생성</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">v</span>(<span class="number">4</span>);    <span class="comment">//int형 백터 생성 후 크기를 4로 할당(모든 백터요소 0으로 초기화)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;        <span class="comment">//int형 백터 생성 후 1, 2, 3 으로 초기화</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v[] = &#123;&#123; <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;        <span class="comment">//int형 백터 배열 생성(행은 가변이지만 열은 고정)</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;        <span class="comment">//2차원 백터 생성(행과 열 모두 가변)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;        </span><br><span class="line">v.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="number">10</span>);    <span class="comment">//백터 범위를 5로 지정하고 정수 10으로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 벡터의 사용 */</span></span><br><span class="line">v.<span class="built_in">begin</span>();<span class="comment">//벡터 시작점의 주소값 반환(Start index of an array)</span></span><br><span class="line">v.<span class="built_in">end</span>();<span class="comment">//벡터 끝부분+1의 주소값 반환(Length of an array)</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> arrLen = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> startIdx = arrLen - K;</span><br><span class="line">    <span class="keyword">int</span> endIdx = arrLen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(arrLen == <span class="number">0</span>) <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(arrLen &lt; K) &#123;</span><br><span class="line">        startIdx = arrLen - (K % arrLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startIdx; i&lt;=endIdx; i++)&#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;startIdx; j++)&#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(A[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>인덱스만 찾는다</li><li><code>empty array</code>에 대한 예외처리 잊지말자!</li></ul><h1 id="Question-2-Odd-occurencies-in-array"><a href="#Question-2-Odd-occurencies-in-array" class="headerlink" title="Question 2 - Odd occurencies in array"></a>Question 2 - Odd occurencies in array</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">A non-empty array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except <span class="keyword">for</span> one element that is left unpaired.</span><br><span class="line"></span><br><span class="line">For example, in array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">9</span>  A[<span class="number">1</span>] = <span class="number">3</span>  A[<span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">3</span>  A[<span class="number">4</span>] = <span class="number">9</span>  A[<span class="number">5</span>] = <span class="number">7</span></span><br><span class="line">  A[<span class="number">6</span>] = <span class="number">9</span></span><br><span class="line">the elements at indexes <span class="number">0</span> and <span class="number">2</span> have value <span class="number">9</span>,</span><br><span class="line">the elements at indexes <span class="number">1</span> and <span class="number">3</span> have value <span class="number">3</span>,</span><br><span class="line">the elements at indexes <span class="number">4</span> and <span class="number">6</span> have value <span class="number">9</span>,</span><br><span class="line">the element at index <span class="number">5</span> has value <span class="number">7</span> and is unpaired.</span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element.</span><br><span class="line"></span><br><span class="line">For example, given array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">9</span>  A[<span class="number">1</span>] = <span class="number">3</span>  A[<span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">3</span>  A[<span class="number">4</span>] = <span class="number">9</span>  A[<span class="number">5</span>] = <span class="number">7</span></span><br><span class="line">  A[<span class="number">6</span>] = <span class="number">9</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">7</span>, as explained in the example above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an odd integer within the range [<span class="number">1.</span><span class="number">.1</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [<span class="number">1.</span><span class="number">.1</span>,<span class="number">000</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">all but one of the values in A occur an even number of times.</span><br></pre></td></tr></table></figure><ul><li>non-empty array는 N개의 원소로 이루어져있다.</li><li>N개의 원소는 각자 짝이 있다</li><li>짝이 없는 원소 한개를 찾아라</li></ul><h2 id="My-Solution-67"><a href="#My-Solution-67" class="headerlink" title="My Solution(67%)"></a>My Solution(67%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="comment">// Unpaired value일 확률이 있는 값들의 집합</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; unpaired;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 숫자 k, k의 등장횟수</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = A[i];</span><br><span class="line">        memory[k]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memory[k] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// odd occurency</span></span><br><span class="line">            unpaired.<span class="built_in">push_back</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            unpaired.<span class="built_in">erase</span>(<span class="built_in">remove</span>(unpaired.<span class="built_in">begin</span>(), unpaired.<span class="built_in">end</span>(), k), unpaired.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unpaired[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>로직 자체는 맞지만 원소개수가 많아지면 타임아웃에러 발생. O(N**2)</li></ul><h2 id="Other-Solution-100"><a href="#Other-Solution-100" class="headerlink" title="Other Solution(100%)"></a>Other Solution(100%)</h2><ul><li>아이디어가 좋네..</li><li>받아온 배열을 정렬한다. 정렬한 배열은 인덱스 0에서부터 2개씩 건너뛰며 루프를 돌린다. </li><li>현재 값이 다음값과 다르면 얘는 홀수개인놈. 얘 이후로는 쭉 인덱스가 깨져서 짝수개로 pair가 나뉘지 않는다.</li><li>현재값이 마지막 값이면 얘가 홀수개인놈.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(A) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> A[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    A = <span class="built_in">sorted</span>(A)</span><br><span class="line">    <span class="built_in">print</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(A), <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> == <span class="built_in">len</span>(A):</span><br><span class="line">            <span class="keyword">return</span> A[i]</span><br><span class="line">        <span class="keyword">if</span> A[i] != A[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> A[i]</span><br><span class="line"></span><br><span class="line">test3([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h2 id="My-Solution-2-100"><a href="#My-Solution-2-100" class="headerlink" title="My Solution 2(100%)"></a>My Solution 2(100%)</h2><ul><li>c++의 sort함수는 기본적으로 오름차순 정렬을 수행한다. </li><li>sort(배열 시작주소, 배열 마지막주소 + 1)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == A.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> A[i];</span><br><span class="line">        <span class="keyword">if</span>(A[i] != A[i+<span class="number">1</span>]) <span class="keyword">return</span> A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/08/codility1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ES6 문법정리</title>
      <link>https://katie0809.github.io/2020/08/19/js-study1/</link>
      <guid>https://katie0809.github.io/2020/08/19/js-study1/</guid>
      <pubDate>Wed, 19 Aug 2020 11:22:42 GMT</pubDate>
      <description>
      
        &lt;p&gt;노드 공부하면서 ES6문법도 같이 공부하련다.&lt;/p&gt;
&lt;p&gt;노드6부터 ES6문법을 사용할 수 있다. 인터넷 익스플로러같은 낡은 브라우저에서도 사용할 수 있도록 문법을 변환해주는 babel같은 도구도 있다!!&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>노드 공부하면서 ES6문법도 같이 공부하련다.</p><p>노드6부터 ES6문법을 사용할 수 있다. 인터넷 익스플로러같은 낡은 브라우저에서도 사용할 수 있도록 문법을 변환해주는 babel같은 도구도 있다!!</p><span id="more"></span><ol><li><p>var는 이제 <code>const</code> 와 <code>let</code> 이 대체한다.</p></li><li><p>템플릿 문자열</p><ul><li>큰/작은 따옴표로 감싸는 기존 문자열과 다르게 ``(백틱)` 으로 감싼다. </li><li><strong>문자열 안에 변수를 넣을 수 있다.</strong> 이거 편하더라.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존</span></span><br><span class="line"><span class="keyword">var</span> string = num1 + <span class="string">&#x27; 더하기 &#x27;</span> + num2 + <span class="string">&#x27; 는 &#x27;</span> + result</span><br><span class="line"></span><br><span class="line"><span class="comment">// 신규</span></span><br><span class="line"><span class="keyword">const</span> string2 = <span class="string">`<span class="subst">$&#123;num1&#125;</span> 더하기 <span class="subst">$&#123;num2&#125;</span>는 <span class="subst">$&#123;result&#125;</span>`</span></span><br></pre></td></tr></table></figure></li><li><p>Arrow function</p><ul><li>this binding 방식이 약간 달라짐. Arrow function 내의 this는 상위 스코프의 this를 그대로 물려받는다.</li></ul></li><li><p>Object destructuring</p></li><li><p>클래스</p><ul><li>기존 prototype 기반 문법을 예뻐보이게 클래스로 바꾼것.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존</span></span><br><span class="line"><span class="keyword">var</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = type || <span class="string">&#x27;human&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Human.isHuman = <span class="function"><span class="keyword">function</span>(<span class="params">human</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> human <span class="keyword">instanceof</span> Human;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Human.prototype.breathe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;h-a-a-a-m&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Zero = <span class="function"><span class="keyword">function</span>(<span class="params">type, firstName, lastName</span>) </span>&#123;</span><br><span class="line">  Human.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Zero.prototype = <span class="built_in">Object</span>.create(Human.prototype);</span><br><span class="line">Zero.prototype.constructor = Zero; <span class="comment">// 상속하는 부분</span></span><br><span class="line">Zero.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> oldZero = <span class="keyword">new</span> Zero(<span class="string">&#x27;human&#x27;</span>, <span class="string">&#x27;Zero&#x27;</span>, <span class="string">&#x27;Cho&#x27;</span>);</span><br><span class="line">Human.isHuman(oldZero); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 신규</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type = <span class="string">&#x27;human&#x27;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 클래스 함수의 키워드 static으로 바뀜</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">isHuman</span>(<span class="params">human</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> human <span class="keyword">instanceof</span> Human;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">breathe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;h-a-a-a-m&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zero</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type, firstName, lastName</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(type);</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.breathe();</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newZero = <span class="keyword">new</span> Zero(<span class="string">&#x27;human&#x27;</span>, <span class="string">&#x27;Zero&#x27;</span>, <span class="string">&#x27;Cho&#x27;</span>);</span><br><span class="line">Human.isHuman(newZero); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Promise 패턴</p><ul><li>자바스크립트와 노드의 API들이 콜백 대신 Promise를 사용한다!</li><li>콜백 지옥을 해결</li><li>Promise는 객체다. 생성된 promise객체는 성공했을때 <code>resolve(result)</code> 로, 실패했을때 <code>reject(error)</code> 로 결과를 전달한다.</li><li>전달된 결과는 <code>then</code> 과 <code>catch</code> 로 받는다.<img src="/image/ES2015.png" alt="_ECMAScript__ES2015_ES6__Promise_-_ZeroCho_Blog"></li><li><a href="https://www.zerocho.com/category/ECMAScript/post/5770c27e6a8e09150013f0f7">Promise의 이해</a></li><li>이때 문제는 Promise.then().catch().then().catch() 뭐 이런식으로 구성했을때 에러가 나면 <code>에러가 난 위치보다 뒤에 붙여놓은 모든 catch들에서도 에러가 발생</code> 한다.</li><li><strong><code>Promise.all</code></strong> 을 사용하면 여러 프로미스 객체들을 한번에 모아서 처리할 수 있다. 모드 프로미스가 성공하면 then, 하나라도 실패하면 catch로 연결된다.’</li><li><strong><code>Promise.race</code></strong> 는 여러 프로미스 객채 중 가장 빨리 성공하거나 실패한 애를 보여준다.</li></ul></li><li><p>async/await</p><ul><li>노드 7.6버전부터 지원되는 기능. 아하.. async/await이 promise보다 상위문법이었구낭!</li><li><strong>비동기 코드를 동기식으로 표현해서 간단하게 만든다.</strong></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/08/19/js-study1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>노드 시작하기</title>
      <link>https://katie0809.github.io/2020/08/19/node-study1/</link>
      <guid>https://katie0809.github.io/2020/08/19/node-study1/</guid>
      <pubDate>Wed, 19 Aug 2020 11:02:29 GMT</pubDate>
      <description>
      
        &lt;p&gt;노드 서버를 만들 일이 생겼습니다. 700페이지짜리 두껍고 무서운 책을 한권 샀습니다. 이름도 무려 Node.js 교과서. &lt;/p&gt;
&lt;p&gt;그래도 뷰 공부할때보다는 확실히 덜 막막하고, 서버는 처음 개발해보는거라 약간 설레는 마음이 있습니다.&lt;/p&gt;
&lt;p&gt;구입한 책은 &lt;a href=&quot;http://www.yes24.com/Product/Goods/62597864&quot;&gt;Node.js 교과서 - 길벗출판사&lt;/a&gt; .&lt;/p&gt;
&lt;h1 id=&quot;노드란&quot;&gt;&lt;a href=&quot;#노드란&quot; class=&quot;headerlink&quot; title=&quot;노드란?&quot;&gt;&lt;/a&gt;노드란?&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Node.js는 Chrome V8 Javascript엔진으로 빌드된 &lt;code&gt;Javascript 런타임&lt;/code&gt;이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;서버로서의-노드&quot;&gt;&lt;a href=&quot;#서버로서의-노드&quot; class=&quot;headerlink&quot; title=&quot;서버로서의 노드&quot;&gt;&lt;/a&gt;서버로서의 노드&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;노드의 가장 큰 특징 : 1) 싱글스레드 2) 논-블로킹 모델&lt;/li&gt;
&lt;li&gt;노드를 서버로 사용할때의 장단점&lt;ul&gt;
&lt;li&gt;노드는 IO 처리를 잘한다(논블로킹 방식으로 처리).&lt;/li&gt;
&lt;li&gt;하지만 노드는 &lt;strong&gt;CPU부하가 큰 작업에는 적합하지 않다.&lt;/strong&gt; &amp;gt;&amp;gt; 작성한 코드 전체가 &lt;code&gt;스레드 하나에서 처리&lt;/code&gt;되기 때문&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;따라서 노드는 &lt;code&gt;개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데에&lt;/code&gt; 적합하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;+) 노드에서 멀티스레드 사용이 불가능한건 아닌듯. 노드12에서 안정화된 워커스레드 기능으로 멀티스레딩 작업 가능하다고 한다.&lt;/p&gt;
&lt;p&gt;+) 당연히 그래도 그냥 C++, Ruby, Go에 비해선 느리다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>노드 서버를 만들 일이 생겼습니다. 700페이지짜리 두껍고 무서운 책을 한권 샀습니다. 이름도 무려 Node.js 교과서. </p><p>그래도 뷰 공부할때보다는 확실히 덜 막막하고, 서버는 처음 개발해보는거라 약간 설레는 마음이 있습니다.</p><p>구입한 책은 <a href="http://www.yes24.com/Product/Goods/62597864">Node.js 교과서 - 길벗출판사</a> .</p><h1 id="노드란"><a href="#노드란" class="headerlink" title="노드란?"></a>노드란?</h1><blockquote><p>Node.js는 Chrome V8 Javascript엔진으로 빌드된 <code>Javascript 런타임</code>이다.</p></blockquote><h1 id="서버로서의-노드"><a href="#서버로서의-노드" class="headerlink" title="서버로서의 노드"></a>서버로서의 노드</h1><ul><li>노드의 가장 큰 특징 : 1) 싱글스레드 2) 논-블로킹 모델</li><li>노드를 서버로 사용할때의 장단점<ul><li>노드는 IO 처리를 잘한다(논블로킹 방식으로 처리).</li><li>하지만 노드는 <strong>CPU부하가 큰 작업에는 적합하지 않다.</strong> &gt;&gt; 작성한 코드 전체가 <code>스레드 하나에서 처리</code>되기 때문</li></ul></li></ul><blockquote><p>따라서 노드는 <code>개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데에</code> 적합하다.</p></blockquote><p>+) 노드에서 멀티스레드 사용이 불가능한건 아닌듯. 노드12에서 안정화된 워커스레드 기능으로 멀티스레딩 작업 가능하다고 한다.</p><p>+) 당연히 그래도 그냥 C++, Ruby, Go에 비해선 느리다.</p><span id="more"></span><ul><li>노드에는 웹서버가 내장되어 있다. 따라서 nginx, Apache와 같은 별도 웹서버를 설치할 필요가 없이 그냥 내장 웹서버 사용할 수 있다.</li><li>물론 나중에 서버 규모가 커지면 nginx같은 <em>별도 웹서버를 노드 서버와 연결</em>해야 한다.</li></ul><h1 id="REPL"><a href="#REPL" class="headerlink" title="REPL"></a>REPL</h1><ul><li>입력한 코드를 읽고, 해석하고, 결과를 반환하고, 종료할때까지 반복한다고 해서 REPL(Read Eval Print Loop) 라고 부른다.</li><li>node의 REPL도 간단하게 터미널에 node 쳐서 실행해볼 수 있다.</li><li>종료하려면 ctrl+c 두번, 혹은 .exit 입력하면 된다.</li></ul><h1 id="모듈화"><a href="#모듈화" class="headerlink" title="모듈화"></a>모듈화</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var.js</span></span><br><span class="line"><span class="keyword">const</span> odd = <span class="string">&#x27;odd num&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> even = <span class="string">&#x27;even num&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">odd, even</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>module.exports로 파일의 객체들을 모듈화 후 export함으로써, var.js 파일은 모듈로서 기능한다.</p></li><li><p><code>require</code> 함수로 불러온다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; odd, even &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./var&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chkNum</span>(<span class="params">n</span>) =&gt; </span>&#123; <span class="keyword">return</span> n % <span class="number">2</span> ? odd : even &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = chkNum;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; odd, even &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./var&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> chkNum = <span class="built_in">require</span>(<span class="string">&#x27;./func&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chkStrNum</span>(<span class="params">s</span>) =&gt; </span>&#123; <span class="keyword">return</span> s.length % <span class="number">2</span> ? odd : even &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(chkNum(<span class="number">10</span>)); <span class="comment">// even num 출력</span></span><br><span class="line"><span class="built_in">console</span>.log(chkStrNum(<span class="string">&#x27;hello&#x27;</span>)); <span class="comment">// odd num 출력</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="노드-내장객체"><a href="#노드-내장객체" class="headerlink" title="노드 내장객체"></a>노드 내장객체</h1><blockquote><p>노드는 내장객체로 window와 document가 없다!</p></blockquote><ol><li>global</li><li>console</li><li>타이머</li><li>module, exports, require</li><li>process</li></ol><h1 id="노드-내장모듈"><a href="#노드-내장모듈" class="headerlink" title="노드 내장모듈"></a>노드 내장모듈</h1><ol><li>os : 운영체제 정보를 가져온다</li><li>path : 폴더와 파일 경로를 조작한다</li><li><code>url</code> : 인터넷 주소를 조작한다</li><li><code>querystring</code> : url의 쿼리부분을 사용하기 쉽게 객체로 만드는 모듈</li><li><code>crypto</code> : 다양한 방식의 암호화를 도와주는 모듈</li><li><code>util</code> : 다양한 편의 기능을 모아둔 모듈</li><li><code>fs</code> : 파일시스템에 접근하는 모듈</li></ol>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/08/19/node-study1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Tensorflow 개발자 자격증 준비하기(6)</title>
      <link>https://katie0809.github.io/2020/07/25/tf-study6/</link>
      <guid>https://katie0809.github.io/2020/07/25/tf-study6/</guid>
      <pubDate>Sat, 25 Jul 2020 07:14:25 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Image-Classification-Tensorflow-dataset&quot;&gt;&lt;a href=&quot;#Image-Classification-Tensorflow-dataset&quot; class=&quot;headerlink&quot; title=&quot;Image Classification : Tensorflow dataset&quot;&gt;&lt;/a&gt;Image Classification : Tensorflow dataset&lt;/h2&gt;&lt;p&gt;3번 유형의 문제를 몇개 더 찾아보았다. 개/고양이 사진을 분류하는 문제를 풀어보았다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Image-Classification-Tensorflow-dataset"><a href="#Image-Classification-Tensorflow-dataset" class="headerlink" title="Image Classification : Tensorflow dataset"></a>Image Classification : Tensorflow dataset</h2><p>3번 유형의 문제를 몇개 더 찾아보았다. 개/고양이 사진을 분류하는 문제를 풀어보았다.</p><span id="more"></span><h2 id="1-문제"><a href="#1-문제" class="headerlink" title="1. 문제"></a>1. 문제</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># using the Cats v Dogs dataset from TFDS.</span></span><br><span class="line"><span class="comment"># The testing infrastructre will resize all images to 224x224 </span></span><br><span class="line"><span class="comment"># with 3 bytes of color depth. Make sure your input layer trains</span></span><br><span class="line"><span class="comment"># images to that specification, or the tests will fail.</span></span><br><span class="line"><span class="keyword">import</span> tensorflow_datasets <span class="keyword">as</span> tfds</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset_name = <span class="string">&#x27;cats_vs_dogs&#x27;</span></span><br><span class="line">dataset, info = tfds.load(name=dataset_name, split=tfds.Split.TRAIN, with_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span>(<span class="params">features</span>):</span></span><br><span class="line">    <span class="comment"># YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution_model</span>():</span></span><br><span class="line">    train_dataset = dataset.<span class="built_in">map</span>(preprocess).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    model = <span class="comment"># YOUR CODE HERE, BUT MAKE SURE YOUR LAST LAYER HAS 2 NEURONS ACTIVATED BY SOFTMAX</span></span><br><span class="line">        tf.keras.layers.Dense(<span class="number">2</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    model = solution_model()</span><br><span class="line">    model.save(<span class="string">&quot;mymodel.h5&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>tensorflow dataset 클래스의 개/고양이 컬러사진 데이터를 모델 학습에 사용한다.</li><li>최종 레이어는 softmax로 2개 종류로 분류하는 Dense layer<ul><li>label값은 0 or 1인 1차원 텐서다</li><li>label을 one hot encoding 하면 categorical cross entropy, 안하면 sparse categorical crossentropy를 사용하자.</li></ul></li></ul><h2 id="2-데이터-전처리"><a href="#2-데이터-전처리" class="headerlink" title="2. 데이터 전처리"></a>2. 데이터 전처리</h2><p>아.. 일단 데이터 다운로드 받는 것 부터가 난관이었다ㅋㅋ 오랜 고군분투 끝에 알아낸 방법은 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">test_dataset, train_dataset = tfds.load(name=<span class="string">&#x27;cats_vs_dogs&#x27;</span></span><br><span class="line">                                        , split=(<span class="string">&#x27;train[:35%]&#x27;</span>, <span class="string">&#x27;train[20%:]&#x27;</span>)</span><br><span class="line">                                        , as_supervised=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li><code>with_info</code> 옵션을 주면 <u>데이터셋의 정보를 같이 반환</u>한다. </li><li><code>split</code> 옵션설정을 통해 데이터를 앞에서부터 30%, 나머지 80%로 분할해서 반환하도록 했다.</li><li><code>as_supervised</code> 옵션을 <strong>True</strong>로 주면 데이터가 <u>튜플로 반환</u>된다. <strong>False</strong>일 경우 <u>dictionary 형태로 반환</u>된다. =&gt; default 값은 False.</li></ul><p>받아온 데이터를 전처리한다. 별건 없고 일단은 그냥 (1)이미지 값을 0-1 사이로 조정하고, (2)이미지 사이즈를 (224, 224)로 줄인다.</p><p>간단한 전처리 함수는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span>(<span class="params">img, lbl</span>):</span></span><br><span class="line">    _img = tf.cast(img, tf.float32)</span><br><span class="line">    _img = tf.divide(_img, <span class="number">255</span>)</span><br><span class="line">    _img = tf.image.resize(_img, (<span class="number">224</span>, <span class="number">224</span>))  <span class="comment"># 이미지 사이즈를 얜 224, 아래는 244로 해둬서 한참해멤...ㅋㅋ</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _img, lbl</span><br></pre></td></tr></table></figure><p>이제 전처리된 데이터셋으로 배치를 생성한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_databatch = train_dataset.<span class="built_in">map</span>(preprocess).batch(BATCH_SZ).repeat()</span><br><span class="line">    test_databatch = test_dataset.<span class="built_in">map</span>(preprocess).batch(BATCH_SZ).repeat()</span><br></pre></td></tr></table></figure><ol><li><code>map()</code> : 데이터셋의 모든 원소에 preprocess 함수로 지정한 변환을 한다</li><li><code>batch(BATCH_SZ)</code> : BATCH_SZ개씩 원소를 가져와서 데이터셋에 저장한다.<br>데이터셋 원소 개수는 데이터셋원소개수/BATCH_SZ(나머지있으면 +1)이다.</li><li><code>repeat()</code> : 이걸 넣어줘야 반복적으로 데이터셋의 모든 데이터에 대해 배치가 생긴다.</li></ol><h2 id="3-모델-구성"><a href="#3-모델-구성" class="headerlink" title="3. 모델 구성"></a>3. 모델 구성</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">model = Sequential([</span><br><span class="line">  Conv2D(<span class="number">16</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>)),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Conv2D(<span class="number">16</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Flatten(), </span><br><span class="line">  Dropout(<span class="number">0.5</span>),</span><br><span class="line">  Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">  Dense(<span class="number">2</span>, activation=<span class="string">&#x27;softmax&#x27;</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;acc&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="4-모델-학습"><a href="#4-모델-학습" class="headerlink" title="4. 모델 학습"></a>4. 모델 학습</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">checkpointPath = <span class="string">&#x27;catDogBest.ckpt&#x27;</span></span><br><span class="line">mc = ModelCheckpoint(checkpointPath,</span><br><span class="line">      monitor = <span class="string">&#x27;val_loss&#x27;</span>, </span><br><span class="line">      verbose = <span class="number">1</span>, </span><br><span class="line">      save_weights_only=<span class="literal">True</span>,</span><br><span class="line">      save_best_only = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model.fit(</span><br><span class="line">      train_databatch, </span><br><span class="line">      steps_per_epoch=(train_len/BATCH_SZ),</span><br><span class="line">      epochs=<span class="number">50</span>,</span><br><span class="line">      validation_data=(test_databatch),</span><br><span class="line">      validation_steps=(test_len/BATCH_SZ),</span><br><span class="line">      callbacks=[mc])</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Epoch 00028: val_loss improved from 0.16154 to 0.14961, saving model to catDogBest.ckpt</span><br><span class="line">582/581 [==============================] - 25s 43ms/step - loss: 0.1320 - acc: 0.9513 - val_loss: 0.1496 - val_acc: 0.9445</span><br></pre></td></tr></table></figure><h3 id="알게된-점"><a href="#알게된-점" class="headerlink" title="+ 알게된 점"></a>+ 알게된 점</h3><ul><li><p>train_dataset과 test_dataset의 비율을 조정하는 것 만으로도 모델의 성능을 높일 수 있다.</p></li><li><p>기존에 train_data랑 test_data를 걍 암생각없이 2 : 8로 나눴는데, 이를 3.5 : 8로 비율 조정한 것 만으로 모델 성능이 확 올라갔다.</p></li></ul><p>​    </p>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/07/25/tf-study6/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
