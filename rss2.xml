<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Dailycrush</title>
    <link>https://katie0809.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 21 Dec 2020 23:47:55 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[DACON] 심리 성향 예측 AI 경진대회</title>
      <link>https://katie0809.github.io/2020/12/21/tf-study8/</link>
      <guid>https://katie0809.github.io/2020/12/21/tf-study8/</guid>
      <pubDate>Mon, 21 Dec 2020 14:07:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://dacon.io/competitions/official/235647/overview/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://dacon.io/competitions/official/235647/overview/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;데이콘에서 종료한 대회의 데이터와 코드를 참고해 알고리즘 제작을 실습해보려 한다. 처음으로 풀 문제는 올해 11월 종료한 &lt;code&gt;심리성향 예측 AI 경진대회&lt;/code&gt; 이다.&lt;/p&gt;
&lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;테스트 참가자의 &lt;u&gt;국가 선거 투표 여부&lt;/u&gt;를 예측한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;사용 가능 언어 : Python, R&lt;/li&gt;
&lt;li&gt;심사기준 : AUC&lt;/li&gt;
&lt;li&gt;외부 데이터 사용불가, pre-trained Model 사용불가&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://dacon.io/competitions/official/235647/overview/" rel="external nofollow noopener noreferrer" target="_blank">https://dacon.io/competitions/official/235647/overview/</a></p><p>데이콘에서 종료한 대회의 데이터와 코드를 참고해 알고리즘 제작을 실습해보려 한다. 처음으로 풀 문제는 올해 11월 종료한 <code>심리성향 예측 AI 경진대회</code> 이다.</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><blockquote><p>테스트 참가자의 <u>국가 선거 투표 여부</u>를 예측한다.</p></blockquote><ul><li>사용 가능 언어 : Python, R</li><li>심사기준 : AUC</li><li>외부 데이터 사용불가, pre-trained Model 사용불가</li></ul><a id="more"></a><h1 id="데이터-분석"><a href="#데이터-분석" class="headerlink" title="데이터 분석"></a>데이터 분석</h1><p>학습해야할 데이터 파일의 구성은 아래와 같다.</p><ol><li>하나의 행이 한 참가자의 정보를 담고 있다. <strong>최종적으로 예측해야 하는 값</strong>은 해당 참가자의 <code>voted : 지난해 국가 선거 투표여부</code> 이다.</li><li>a~t 까지의 20개의 질문에 대한 답 QnA와 답변에 걸린 시간 QnE 가 주어진다. <ul><li>답변은 <code>1=Disagree, 2=Slightly disagree, 3=Neutral, 4=Slightly agree, 5=Agree</code> 로 주어진다.</li></ul></li><li>스스로의 성격에 대한 평가 질문 7개에 대한 답이 주어진다.<ul><li>I see myself as (Extraverted / Critical / Dependable… )</li></ul></li><li>실존하는 단어 13개에 대한 정의를 아는지 여부에 대한 답변이 <code>1=Yes, 2=No</code>로 주어진다 : wr_(01~13)</li><li>허구하는 단어 3개에 대한 정의를 아는지 여부에 대한 답변이 <code>1=Yes, 2=No</code>로 주어진다 : wt_(01~03)</li><li>기타 해당 참가자에 대한 정보(연령, 교육수준, 모국어, 형제자매 등)가 주어진다.</li></ol><h1 id="데이터-전처리"><a href="#데이터-전처리" class="headerlink" title="데이터 전처리"></a>데이터 전처리</h1><h2 id="구글-드라이브-마운트해서-파일-받아오기"><a href="#구글-드라이브-마운트해서-파일-받아오기" class="headerlink" title="[ 구글 드라이브 마운트해서 파일 받아오기 ]"></a>[ 구글 드라이브 마운트해서 파일 받아오기 ]</h2><p>구글 드라이브에 샘플 csv파일을 올려두고, 데이터 처리를 위해 해당 파일들을 불러온다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 구글 드라이브에 올려둔 학습데이터 가져온다</span></span><br><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> drive</span><br><span class="line">drive.mount(<span class="string">'/drive'</span>, force_remount=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 파일 받아온다</span></span><br><span class="line">train_filename = <span class="string">'/drive/My Drive/DACON/MindType/train.csv'</span></span><br><span class="line">test_filename = <span class="string">'/drive/My Drive/DACON/MindType/test_x.csv'</span></span><br></pre></td></tr></table></figure><ul><li>개인 구글 드라이브 하위에 <code>/DACON/MindType</code> 폴더를 만들어두고 학습 데이터들을 올려두었다.</li><li>드라이브를 마운트하고 파일을 받아온다.</li></ul><h2 id="csv-파일-읽어와-학습변수로-설정하기"><a href="#csv-파일-읽어와-학습변수로-설정하기" class="headerlink" title="[ csv 파일 읽어와 학습변수로 설정하기 ]"></a>[ csv 파일 읽어와 학습변수로 설정하기 ]</h2><blockquote><p>csv 파일 읽어오기</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># csv파일 읽어들인다</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train_raw = pd.read_csv(train_filename)</span><br><span class="line"></span><br><span class="line">print(train_raw.columns)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Index([&#39;index&#39;, &#39;QaA&#39;, &#39;QaE&#39;, &#39;QbA&#39;, &#39;QbE&#39;, &#39;QcA&#39;, &#39;QcE&#39;, &#39;QdA&#39;, &#39;QdE&#39;, &#39;QeA&#39;,</span><br><span class="line">       &#39;QeE&#39;, &#39;QfA&#39;, &#39;QfE&#39;, &#39;QgA&#39;, &#39;QgE&#39;, &#39;QhA&#39;, &#39;QhE&#39;, &#39;QiA&#39;, &#39;QiE&#39;, &#39;QjA&#39;,</span><br><span class="line">       &#39;QjE&#39;, &#39;QkA&#39;, &#39;QkE&#39;, &#39;QlA&#39;, &#39;QlE&#39;, &#39;QmA&#39;, &#39;QmE&#39;, &#39;QnA&#39;, &#39;QnE&#39;, &#39;QoA&#39;,</span><br><span class="line">       &#39;QoE&#39;, &#39;QpA&#39;, &#39;QpE&#39;, &#39;QqA&#39;, &#39;QqE&#39;, &#39;QrA&#39;, &#39;QrE&#39;, &#39;QsA&#39;, &#39;QsE&#39;, &#39;QtA&#39;,</span><br><span class="line">       &#39;QtE&#39;, &#39;age_group&#39;, &#39;education&#39;, &#39;engnat&#39;, &#39;familysize&#39;, &#39;gender&#39;,</span><br><span class="line">       &#39;hand&#39;, &#39;married&#39;, &#39;race&#39;, &#39;religion&#39;, &#39;tp01&#39;, &#39;tp02&#39;, &#39;tp03&#39;, &#39;tp04&#39;,</span><br><span class="line">       &#39;tp05&#39;, &#39;tp06&#39;, &#39;tp07&#39;, &#39;tp08&#39;, &#39;tp09&#39;, &#39;tp10&#39;, &#39;urban&#39;, &#39;voted&#39;,</span><br><span class="line">       &#39;wf_01&#39;, &#39;wf_02&#39;, &#39;wf_03&#39;, &#39;wr_01&#39;, &#39;wr_02&#39;, &#39;wr_03&#39;, &#39;wr_04&#39;, &#39;wr_05&#39;,</span><br><span class="line">       &#39;wr_06&#39;, &#39;wr_07&#39;, &#39;wr_08&#39;, &#39;wr_09&#39;, &#39;wr_10&#39;, &#39;wr_11&#39;, &#39;wr_12&#39;, &#39;wr_13&#39;],</span><br><span class="line">      dtype&#x3D;&#39;object&#39;)</span><br></pre></td></tr></table></figure><ul><li>파이썬의 pandas 라이브러리를 활용해 csv 파일을 불러온다 : <code>pandas.read_csv()</code> 사용</li><li>csv파일 변수의 <code>.columns</code> 로 추출된 컬럼을 확인할 수 있다. </li></ul><blockquote><p>index column 설정하기</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># csv파일 읽어들인다</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train_raw = pd.read_csv(train_filename, index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(train_raw.columns)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Index([&#39;QaA&#39;, &#39;QaE&#39;, &#39;QbA&#39;, &#39;QbE&#39;, &#39;QcA&#39;, &#39;QcE&#39;, &#39;QdA&#39;, &#39;QdE&#39;, &#39;QeA&#39;, &#39;QeE&#39;,</span><br><span class="line">       &#39;QfA&#39;, &#39;QfE&#39;, &#39;QgA&#39;, &#39;QgE&#39;, &#39;QhA&#39;, &#39;QhE&#39;, &#39;QiA&#39;, &#39;QiE&#39;, &#39;QjA&#39;, &#39;QjE&#39;,</span><br><span class="line">       &#39;QkA&#39;, &#39;QkE&#39;, &#39;QlA&#39;, &#39;QlE&#39;, &#39;QmA&#39;, &#39;QmE&#39;, &#39;QnA&#39;, &#39;QnE&#39;, &#39;QoA&#39;, &#39;QoE&#39;,</span><br><span class="line">       &#39;QpA&#39;, &#39;QpE&#39;, &#39;QqA&#39;, &#39;QqE&#39;, &#39;QrA&#39;, &#39;QrE&#39;, &#39;QsA&#39;, &#39;QsE&#39;, &#39;QtA&#39;, &#39;QtE&#39;,</span><br><span class="line">       &#39;age_group&#39;, &#39;education&#39;, &#39;engnat&#39;, &#39;familysize&#39;, &#39;gender&#39;, &#39;hand&#39;,</span><br><span class="line">       &#39;married&#39;, &#39;race&#39;, &#39;religion&#39;, &#39;tp01&#39;, &#39;tp02&#39;, &#39;tp03&#39;, &#39;tp04&#39;, &#39;tp05&#39;,</span><br><span class="line">       &#39;tp06&#39;, &#39;tp07&#39;, &#39;tp08&#39;, &#39;tp09&#39;, &#39;tp10&#39;, &#39;urban&#39;, &#39;voted&#39;, &#39;wf_01&#39;,</span><br><span class="line">       &#39;wf_02&#39;, &#39;wf_03&#39;, &#39;wr_01&#39;, &#39;wr_02&#39;, &#39;wr_03&#39;, &#39;wr_04&#39;, &#39;wr_05&#39;, &#39;wr_06&#39;,</span><br><span class="line">       &#39;wr_07&#39;, &#39;wr_08&#39;, &#39;wr_09&#39;, &#39;wr_10&#39;, &#39;wr_11&#39;, &#39;wr_12&#39;, &#39;wr_13&#39;],</span><br><span class="line">      dtype&#x3D;&#39;object&#39;)</span><br></pre></td></tr></table></figure><ul><li>위와 같이 csv파일을 읽어올때 <strong><code>index column을 설정</code></strong>해주면 <u>전처리할 열에서 제외</u>할 수 있다.</li></ul><blockquote><p>“voted” 열을 train_y의 타겟으로 만들기</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_x = train_raw.drop(<span class="string">'voted'</span>, axis = <span class="number">1</span>)</span><br><span class="line">train_y = train_raw[<span class="string">'voted'</span>]</span><br><span class="line"></span><br><span class="line">train_x.shape</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(45532, 76) # 45532명에 대한 76가지 데이터를 의미한다.</span><br></pre></td></tr></table></figure><ul><li>학습 데이터에서 <code>voted</code> 열만 제외한 데이터를 <strong>train_x</strong>로 저장</li><li>학습 데이터의 <code>voted</code> 열을 따로 뽑아 <strong>train_y</strong>로 저장</li></ul><h2 id="문자열-변수-변환"><a href="#문자열-변수-변환" class="headerlink" title="[ 문자열 변수 변환 ]"></a>[ 문자열 변수 변환 ]</h2><p>값이 문자열로 들어가있는 데이터에 대해 적절한 숫자값으로 변환해주었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gender_list = [<span class="string">'Male'</span>, <span class="string">'Female'</span>]</span><br><span class="line">race_list = [<span class="string">'Asian'</span>, <span class="string">'Arab'</span>, <span class="string">'Black'</span>, <span class="string">'Indigenous Australian'</span>, <span class="string">'Native American'</span>, <span class="string">'White'</span>, <span class="string">'Other'</span>]</span><br><span class="line">religion_list = [<span class="string">'Agnostic'</span>, <span class="string">'Atheist'</span>, <span class="string">'Buddhist'</span>, <span class="string">'Christian_Catholic'</span>, <span class="string">'Christian_Mormon'</span>, <span class="string">'Christian_Protestant'</span>, <span class="string">'Christian_Other'</span>, <span class="string">'Hindu'</span>, <span class="string">'Jewish'</span>, <span class="string">'Muslim'</span>, <span class="string">'Sikh'</span>, <span class="string">'Other'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, data <span class="keyword">in</span> train_x.iterrows():</span><br><span class="line">  age_grp = data[<span class="string">'age_group'</span>]</span><br><span class="line">  race = data[<span class="string">'race'</span>]</span><br><span class="line">  religion = data[<span class="string">'religion'</span>]</span><br><span class="line">  gender = data[<span class="string">'gender'</span>]</span><br><span class="line">  </span><br><span class="line">  train_x.loc[idx, <span class="string">'age_group'</span>] = age_grp.replace(<span class="string">'s'</span>, <span class="string">''</span>)</span><br><span class="line">  train_x.loc[idx, <span class="string">'race'</span>] = race_list.index(race) + <span class="number">1</span></span><br><span class="line">  train_x.loc[idx, <span class="string">'religion'</span>] = religion_list.index(religion) + <span class="number">1</span></span><br><span class="line">  train_x.loc[idx, <span class="string">'gender'</span>] = gender_list.index(gender) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(train_x[<span class="string">'religion'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">index</span><br><span class="line">0        12</span><br><span class="line">1         8</span><br><span class="line">2        12</span><br><span class="line">3         8</span><br><span class="line">4         1</span><br><span class="line">         ..</span><br><span class="line">45527     9</span><br><span class="line">45528     2</span><br><span class="line">45529     7</span><br><span class="line">45530     2</span><br><span class="line">45531     1</span><br><span class="line">Name: religion, Length: 45532, dtype: object</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/12/21/tf-study8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝 기초] </title>
      <link>https://katie0809.github.io/2020/12/09/ai-start7/</link>
      <guid>https://katie0809.github.io/2020/12/09/ai-start7/</guid>
      <pubDate>Tue, 08 Dec 2020 15:23:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;딥러닝을 하기 위한 텐서플로 기초 사용법입니다. 파이썬 numpy array를 활용해 기본적인 텐서를 생성하고, 생성된 텐서의 정보를 확인해보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>딥러닝을 하기 위한 텐서플로 기초 사용법입니다. 파이썬 numpy array를 활용해 기본적인 텐서를 생성하고, 생성된 텐서의 정보를 확인해보자.</p><a id="more"></a><h2 id="Tensor의-생성"><a href="#Tensor의-생성" class="headerlink" title="Tensor의 생성"></a>Tensor의 생성</h2><p>파이썬 numpy를 통해 생성한 배열/튜플/리스트는 텐서플로의 <code>tf.constant()</code> 함수를 통해 텐서로 변환할 수 있다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">tf.constant(arr)</span><br></pre></td></tr></table></figure><h2 id="Tensor-정보-확인"><a href="#Tensor-정보-확인" class="headerlink" title="Tensor 정보 확인"></a>Tensor 정보 확인</h2><ul><li><p><code>tensor.shape</code> : tensor의 shape 확인</p></li><li><p><code>tensor.dtype</code> : tensor의 데이터 타입 확인</p><ul><li><p>텐서 생성시에 데이터 타입을 정의해줄 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor = tf.constant([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=tf.float32)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>tf.cast()</code> : data type 변환</p><ul><li>numpy array는 <code>numpy.astype()</code>을 사용해 데이터 타입 변환한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.cast(tensor, dtype=tf.uint8)</span><br></pre></td></tr></table></figure></li><li><p><code>tensor.numpy()</code>, <code>np.array(tensor)</code>, <code>type(tensor.numpy())</code> : 텐서에서 numpy불러오기</p></li></ul><h2 id="난수-생성하기"><a href="#난수-생성하기" class="headerlink" title="난수 생성하기"></a>난수 생성하기</h2><ul><li><code>numpy.random.rand()</code>, <code>tf.random.normal()</code> : normal distribution의 난수 생성</li><li><code>tf.random.uniform()</code> : uniform distribution의 난수 생성</li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/12/09/ai-start7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝 기초] 그래프 시각화</title>
      <link>https://katie0809.github.io/2020/12/05/ai-start6/</link>
      <guid>https://katie0809.github.io/2020/12/05/ai-start6/</guid>
      <pubDate>Sat, 05 Dec 2020 08:42:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;데이터의 학습과정을 확인하고 분석하기 위해서는 이를 그래프로 시각화하는 과정이 필수적이다.&lt;/p&gt;
&lt;p&gt; &lt;code&gt;matplotlib.pyplot&lt;/code&gt; 라이브러리를 활용해 그래프 시각화 테크닉을 익혀보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>데이터의 학습과정을 확인하고 분석하기 위해서는 이를 그래프로 시각화하는 과정이 필수적이다.</p><p> <code>matplotlib.pyplot</code> 라이브러리를 활용해 그래프 시각화 테크닉을 익혀보자.</p><a id="more"></a><h2 id="패키지-로딩"><a href="#패키지-로딩" class="headerlink" title="패키지 로딩"></a>패키지 로딩</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">%matplotlib inline // jupyter notebook에서만 사용가능. 그래프를 새 창이 아닌 현재 실행중인 창에서 띄워준다.</span><br></pre></td></tr></table></figure><h2 id="점선-기본-그래프-그리기-plt-plot-data"><a href="#점선-기본-그래프-그리기-plt-plot-data" class="headerlink" title="점선 기본 그래프 그리기 : plt.plot(data)"></a>점선 기본 그래프 그리기 : <code>plt.plot(data)</code></h2><p>: numpy array의 각 값들을 선으로 이은 기본 그래프 그린다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.rand(<span class="number">50</span>)</span><br><span class="line">plt.plot(data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="여러-그래프-그리기"><a href="#여러-그래프-그리기" class="headerlink" title="여러 그래프 그리기"></a>여러 그래프 그리기</h2><ul><li><code>pyplot.subplot(행 개수, 열 개수, 그래프 그릴위치 index)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>) // <span class="number">1</span> * <span class="number">2</span>의 판을 만든다. 그 중 첫번째 위치에 그래프를 그린다. </span><br><span class="line">plt.plot(data) // subplot으로 그래프 그릴 위치 정해주고 그래프 그리는 함수로 데이터 그려준다.</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li><code>plot</code>대신 사용가능한 함수 : <code>hist()</code> 히스토그램, <code>scatter()</code> 분산데이터</li></ul><h2 id="그래프-옵션"><a href="#그래프-옵션" class="headerlink" title="그래프 옵션"></a>그래프 옵션</h2><ul><li>색상/마커 등 조절가능 : b, g, r, c, y, k, w / 원, 선, 별표 등 가능</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(data, &#39;y&#39;)</span><br></pre></td></tr></table></figure><ul><li><code>pyplot.figure(figsize=(10, 5))</code> : 그래프 가로세로 길이 조절가능하다</li><li><code>pyplot.legend()</code> : 그래프 선 이름을 보여준다.</li><li><code>pyplot.xlabel(&#39;name&#39;)</code>, <code>pyplot.ylabel(&#39;name&#39;)</code> : x/y축 레이블을 보여준다.</li><li><code>pyplot.savefig(&#39;saved_graph.svg&#39;)</code> : 그래프 저장하기 </li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/12/05/ai-start6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝 기초] Tensor의 이해와 Numpy기초</title>
      <link>https://katie0809.github.io/2020/12/05/ai-start5/</link>
      <guid>https://katie0809.github.io/2020/12/05/ai-start5/</guid>
      <pubDate>Sat, 05 Dec 2020 06:36:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;딥러닝의 Tensor =&amp;gt; numpy array로 주로 표현한다. Tensor의 기본에 대해 이해하고 python numpy의 기본 도구들을 익히자&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>딥러닝의 Tensor =&gt; numpy array로 주로 표현한다. Tensor의 기본에 대해 이해하고 python numpy의 기본 도구들을 익히자</p><a id="more"></a><h1 id="Tensor의-이해"><a href="#Tensor의-이해" class="headerlink" title="Tensor의 이해"></a>Tensor의 이해</h1><h2 id="0차원-scalar"><a href="#0차원-scalar" class="headerlink" title="0차원(scalar)"></a>0차원(scalar)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array(<span class="number">5</span>)</span><br><span class="line">arr.shape</span><br><span class="line">arr.ndim</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Out: ()</span><br><span class="line">Out: 0</span><br></pre></td></tr></table></figure><p>스칼라로 들어간 넘파이 배열. shape가 아무것도 없는 것으로 나온다.</p><h2 id="1차원-vector"><a href="#1차원-vector" class="headerlink" title="1차원(vector)"></a>1차원(vector)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">5</span>])</span><br><span class="line">arr.shape</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out: (1,)</span><br></pre></td></tr></table></figure><ul><li>numpy에서 <code>1차원 텐서의 shape을 표현할때 (1)이 아닌 (1, ) 과 같이 표현</code>한다.</li><li>이건 shape이기 때문에 1이라는 값이 들어갔다는게 아니다. 1차원에 1개의 값이 들어갔다는 의미.</li><li>마찬가지로 예를들어 <strong>(3, ) 은 1차원에 3개의 값</strong>이 들어갔다는 의미이다.</li></ul><h2 id="2차원-matrix"><a href="#2차원-matrix" class="headerlink" title="2차원(matrix)"></a>2차원(matrix)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">arr.shape</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out: (2, 3)</span><br></pre></td></tr></table></figure><h2 id="다차원"><a href="#다차원" class="headerlink" title="다차원"></a>다차원</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]], [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]], [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]]])</span><br><span class="line">arr.shape</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out: (3, 3, 1)</span><br></pre></td></tr></table></figure><h1 id="Numpy기초"><a href="#Numpy기초" class="headerlink" title="Numpy기초"></a>Numpy기초</h1><h2 id="0과-1로-채워진-numpy-array만들기"><a href="#0과-1로-채워진-numpy-array만들기" class="headerlink" title="0과 1로 채워진 numpy array만들기"></a>0과 1로 채워진 numpy array만들기</h2><blockquote><p>np.zeros() : 0으로 채워진 numpy array 만들기</p><p>np.ones() : 1으로 채워진 numpy array 만들기</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zeros = np.zeros([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">ones = np.ones([<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">zeros</span><br><span class="line">ones</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([[0., 0., 0.],</span><br><span class="line">       [0., 0., 0.]])</span><br><span class="line">       </span><br><span class="line">array([[1., 1.],</span><br><span class="line">       [1., 1.],</span><br><span class="line">       [1., 1.]])</span><br></pre></td></tr></table></figure><h2 id="특정-범위의-숫자로-채워진-numpy-array만들기"><a href="#특정-범위의-숫자로-채워진-numpy-array만들기" class="headerlink" title="특정 범위의 숫자로 채워진 numpy array만들기"></a>특정 범위의 숫자로 채워진 numpy array만들기</h2><blockquote><p>np.arrange(M, N) : M부터 N-1까지의 수로 채워진 numpy array를 만들어준다</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arrange(<span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([4, 5, 6])</span><br></pre></td></tr></table></figure><h3 id="응용-reshape와-섞어서-쓰기"><a href="#응용-reshape와-섞어서-쓰기" class="headerlink" title="(응용) reshape와 섞어서 쓰기"></a>(응용) reshape와 섞어서 쓰기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arrange(<span class="number">4</span>, <span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([4, 5],</span><br><span class="line">      [6, 7])</span><br></pre></td></tr></table></figure><h3 id="응용-array의-index로-접근하기"><a href="#응용-array의-index로-접근하기" class="headerlink" title="(응용) array의 index로 접근하기"></a>(응용) array의 index로 접근하기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">arr[<span class="number">1</span>]</span><br><span class="line">arr[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">nums[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([6, 7])</span><br><span class="line">6</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><h3 id="응용-index로-slicing하기"><a href="#응용-index로-slicing하기" class="headerlink" title="(응용) index로 slicing하기"></a>(응용) index로 slicing하기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arrange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">arr[<span class="number">1</span>:]</span><br><span class="line">arr[<span class="number">1</span>:, <span class="number">1</span>:]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([3, 4, 5],</span><br><span class="line">      [6, 7, 8])</span><br><span class="line">array([4, 5],</span><br><span class="line">      [7, 8])</span><br></pre></td></tr></table></figure><h3 id="응용-Boolean-indexing"><a href="#응용-Boolean-indexing" class="headerlink" title="(응용) Boolean indexing"></a>(응용) Boolean indexing</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = np.random().radn(<span class="number">2</span>, <span class="number">2</span>) // 랜덤한 숫자로 <span class="number">2</span>*<span class="number">2</span> 배열 생성</span><br><span class="line">data &lt;= <span class="number">0</span> // <span class="number">0</span>보다 작은 숫자 이렇게 boolean으로 바로 찾을수도 있다.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([ True, False],</span><br><span class="line">      [False, False])</span><br></pre></td></tr></table></figure><h2 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h2><ul><li>연산하려는 행렬의 shape, 값 등을 조정하기 위한 테크닉 알 필요가 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arrange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">arr + <span class="number">3</span> // 모든 값에 <span class="number">3</span>씩 더해준다</span><br><span class="line">arr + np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) // 각 행마다 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]을 더해준다</span><br><span class="line">arr * <span class="number">3</span> // 모든 값에 <span class="number">3</span>을 곱해준다</span><br></pre></td></tr></table></figure><h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><ul><li><p><strong>np.argmax(arr)</strong> : 가장 값이 큰 value의 인덱스를 반환한다. argmin()도 있다.</p></li><li><p><strong>np.unique(arr)</strong> : array안에 있는 unique한 값들을 numpy array형태로 반환해준다.</p></li><li><p><strong>np.dtype()</strong> : array의 data type(dtype)을 반환해준다.</p><ul><li>기본적으로 그냥 [1, 2, 3] 뭐 이렇게 넣으면 알아서 ‘int64’ 타입으로 들어간다.</li><li>배열 생성시에 데이터 타입을 지정해줄 수도 있다 : (예시) <code>np.array([[1., 2, 3], [1, 2, 3]], dtype=np.uint8)</code></li></ul></li><li><p><strong>np.astype(‘data type’)</strong> : 값의 data type을 원하는 타입으로 변환해준다.</p></li><li><p><strong>np.ndim()</strong> : 차원 수를 return</p></li><li><p><strong>np.size()</strong> : size 확인</p></li><li><p><strong>np.reshape()</strong> : resize()와는 다르게 사이즈는 유지하면서 모양/차원만 바꿔준다.</p><ul><li><dl><dt>-1 활용.</dt><dd>차원 바꿔주고싶은데 해당 차원에 몇개 들어가야할지 정확히 모를때 그냥 -1쓰면 알아서 계산해서 바꿔준다. 일종의 물음표라고 생각하면 된다.</dd></dl><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">arr.reshape([6]).shape // (6, ) =&gt; 1차원 array로 바뀜</span><br><span class="line">arr.reshape([-1]).shape // (6, ) =&gt; 1차원으로 바꿔주는데 몇개인지 모를때 그냥 알아서 1차원으로 바꿔줌</span><br><span class="line">arr.reshape([-1, 2]).shape // (3, 2) =&gt; (?, 2)로 바꿔달라는 말과 동일하며, 알아서 맞춰서 (3, 2)의 배열로 변환해준다.</span><br></pre></td></tr></table></figure></li><li><p>사이즈 변동이 없는 선에서 차원을 늘릴 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]) // (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">arr.reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>) // (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>np.random.rand(M, N, …)</strong> : (M, N, …) 차원의 배열을 랜덤한 숫자로 채워 생성한다.</p></li><li><p><strong>np.ravel()</strong> : 차원을 1차원으로 바꿔서 펼쳐준다. Layer의 flatten을 위한 기능이라고 생각하면 된다.</p></li></ul><h2 id="값을-유지하며-차원을-늘리자-np-expand-dims"><a href="#값을-유지하며-차원을-늘리자-np-expand-dims" class="headerlink" title="값을 유지하며 차원을 늘리자 : np.expand_dims()"></a>값을 유지하며 차원을 늘리자 : <code>np.expand_dims()</code></h2><p>: reshape으로도 차원을 늘릴 수는 있지만 동일한 형태 유지하면서 차원만 늘리려면 안에 들어있는 값 개수를 알아야 한다. 개수를 모를때 차원을 늘리기 위해 사용할 수 있는 함수가 <code>expand_dims()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.expand_dims(</span><br><span class="line">                 arr, // 차원을 늘릴 numpy array</span><br><span class="line">                 <span class="number">0</span>// <span class="number">0</span>: 차원을 뒤에 붙임, <span class="number">-1</span>: 차원을 앞에 붙임</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/12/05/ai-start5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Tensorflow 2.0] Subclassing 구현</title>
      <link>https://katie0809.github.io/2020/11/29/tf-study7/</link>
      <guid>https://katie0809.github.io/2020/11/29/tf-study7/</guid>
      <pubDate>Sun, 29 Nov 2020 06:33:21 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;TensorFlow 2.0으로 베우는 딥러닝 입문 강의를 들으며 공부한 내용입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;복습 겸 입문 강의를 쭉 훑으면서 기초를 다시 다져보려 한다. Subclassing 코딩스타일을 익혀보자.&lt;/p&gt;
&lt;p&gt;강의에 사용된 예제 코드는 이전에 다뤄본 MNIST 숫자분류 코드로 깃헙 주소는 아래와 같다. -&amp;gt; &lt;a href=&quot;https://github.com/solaris33/deep-learning-tensorflow-book-code/blob/master/Ch04-Machine_Learning_Basic/mnist_classification_using_softmax_regression_v2_keras.py&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;여기!&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li>TensorFlow 2.0으로 베우는 딥러닝 입문 강의를 들으며 공부한 내용입니다.</li></ul><p>복습 겸 입문 강의를 쭉 훑으면서 기초를 다시 다져보려 한다. Subclassing 코딩스타일을 익혀보자.</p><p>강의에 사용된 예제 코드는 이전에 다뤄본 MNIST 숫자분류 코드로 깃헙 주소는 아래와 같다. -&gt; <a href="https://github.com/solaris33/deep-learning-tensorflow-book-code/blob/master/Ch04-Machine_Learning_Basic/mnist_classification_using_softmax_regression_v2_keras.py" rel="external nofollow noopener noreferrer" target="_blank">여기!</a></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tf.keras.Model을 이용해서 Softmax Regression 모델을 정의합니다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoftmaxRegression</span><span class="params">(tf.keras.Model)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    super(SoftmaxRegression, self).__init__()</span><br><span class="line">    self.softmax_layer = tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="literal">None</span>, kernel_initializer=<span class="string">'zeros'</span>, bias_initializer=<span class="string">'zeros'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    logits = self.softmax_layer(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tf.nn.softmax(logits)</span><br></pre></td></tr></table></figure><ul><li>케라스 서브클래싱 방식을 사용한 코드패턴이다.</li><li>tf.keras.Model을 상속받는 클래스를 하나 정의해준다. </li><li>생성자 init과 호출부 call 로직을 정의해준다. 생성자에서는 super 메서드를 통해 tf.keras.model의 생성자를 상속받는 형태로 정의해준다.</li><li>클래스 변수로 원하는 모델 구조의 API를 선언해준다.</li><li>클래스 호출부 call 메서드에서는 인자값으로 input data x를 받고 생성자 부분에서 정의했던 클래스 변수들(softmax_layer)을 순차적으로 호출한다 =&gt; 전체 모델 구조의 output 반환값을 계산(logits).</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 최적화를 위한 function을 정의합니다.</span></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(model, x, y)</span>:</span></span><br><span class="line">  <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    y_pred = model(x)</span><br><span class="line">    loss = cross_entropy_loss(y_pred, y)</span><br><span class="line">  gradients = tape.gradient(loss, model.trainable_variables)</span><br><span class="line">  optimizer.apply_gradients(zip(gradients, model.trainable_variables))</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.tensorflow.org/guide/autodiff?hl=ko" rel="external nofollow noopener noreferrer" target="_blank">GradientTape에 대한 공식문서</a></li><li>GradientTape은 자동으로 <code>context 내에서 실행된 모든 연산을 tape에 기록</code> 한다. 이후, <strong>tape.gradient(z, y)</strong> 를 호출하면 GradientTape에 포함된 리소스가 해제되면서 y에 대한 도함수를 계산한다.</li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/11/29/tf-study7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SK 코딩테스트 후기 - String다루기</title>
      <link>https://katie0809.github.io/2020/10/12/codility5/</link>
      <guid>https://katie0809.github.io/2020/10/12/codility5/</guid>
      <pubDate>Mon, 12 Oct 2020 07:23:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;SK 계열사 중 한곳에 지원, 지난 토요일 코딩테스트를 치뤘다. IDE는 후기에서 말한대로 Codility를 사용했다. &lt;/p&gt;
&lt;p&gt;문제는 총 3문제였는데 첫 2개를 30분동안 다 풀고 마지막 1개를 결국 못풀었다… 아쉽다.. 느낌상 셋다 풀고 3번에서 효율성이 떨어지는 정도여야 통과일 것 같아서 마음을 비우고 있는 중이다.&lt;/p&gt;
&lt;p&gt;어쨌든 이번이 첫 지원이니 너무 마음쓰지 않으련다. 다음 시험때 더 잘하면 되지. 그럼 의미에서 문제를 복기하고 헤맨 원인을 찾아보려 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>SK 계열사 중 한곳에 지원, 지난 토요일 코딩테스트를 치뤘다. IDE는 후기에서 말한대로 Codility를 사용했다. </p><p>문제는 총 3문제였는데 첫 2개를 30분동안 다 풀고 마지막 1개를 결국 못풀었다… 아쉽다.. 느낌상 셋다 풀고 3번에서 효율성이 떨어지는 정도여야 통과일 것 같아서 마음을 비우고 있는 중이다.</p><p>어쨌든 이번이 첫 지원이니 너무 마음쓰지 않으련다. 다음 시험때 더 잘하면 되지. 그럼 의미에서 문제를 복기하고 헤맨 원인을 찾아보려 한다.</p><a id="more"></a><h1 id="왜-못풀었는가"><a href="#왜-못풀었는가" class="headerlink" title="왜 못풀었는가"></a>왜 못풀었는가</h1><p>: 사실 이건 어떻게 적든간에 변명밖에 되지 않는다. 내가 좀더 준비되어 있었다면 어떤 방식, 어떤 루트를 취했어도 풀었을 것이다. 일단 문제자체가 “풀이가 어려운” 스타일의 문제가 아니었다. 시험시간 내내 실제 문제를 푸는 로직이 아니라 언어 문법에 얽매어 시간을 허비했던 것이 너무나도 아쉽다. 요리로 비유하자면 요리를 하다 어려워서 시간이 다 간게 아니라 당근을 숟가락으로 썰어야 해서 당근만 썰다 끝난 기분이었다.</p><p>결국 내가 생각한 가장 큰 원인은 바보같이 이 문제를 C++로 풀려 했다는거다. 나는 이 문제를 보고, 로직을 정리하기도 전에 “아 이건 문자열을 엄청나게 다루는 문제구나. 파이썬으로 풀어야지” 뭐 이런 생각을 했어야 했다. 하지만 결국은 내탓이다. 파이썬으로 알고리즘 연습을 많이 하지않아 멈칫했고, 분명 언어를 바꿀까 고민도 했지만 끝내는 바꾸지 못했던거다. 시험 보기전에 딱 한번만이라도 파이썬으로 문제를 풀어보고 치뤘다면 아마 이 문제를 풀 수 있었을거다.</p><p>문제는 간단했다. 대충 파일명들이 하나의 긴 스트링으로 주어지고, 이 파일명에서 특정 정보 A, B를 뽑아내 A로 그루핑한 후 각 그룹내에서 B로 정렬하는거다. 그런데 바보같이 이걸 C++로 풀려 하니깐 세상에 스트링 tokenizer 함수부터 새로 짜야하더라.. 자바스크립트에 너무 익숙해져서 C++이 얼마나 문자열 다루기에 최악이었는지 잊고있었다… 그리고 그걸 시험시간 40분 남겨두고 기억해냈다ㅠ 나는 선택지가 없었다…</p><h1 id="문제-정리"><a href="#문제-정리" class="headerlink" title="문제 정리"></a>문제 정리</h1><h2 id="1-주어지는-파일포멧"><a href="#1-주어지는-파일포멧" class="headerlink" title="1. 주어지는 파일포멧"></a>1. 주어지는 파일포멧</h2><ul><li>이름.확장자, 도시, yyyy-mm-dd hh:mm:ss</li></ul><h2 id="2-정리방법"><a href="#2-정리방법" class="headerlink" title="2. 정리방법"></a>2. 정리방법</h2><ul><li>도시별로 묶는다</li><li>같은 도시에서 찍힌 시간별로 정렬한다</li><li>새 이름은 [도시명] [숫자인덱스].원래확장자<ul><li>숫자 인덱스는 같은 도시그룹의 개수따라 001, 002… 와 같이 leading zero 붙여준다</li></ul></li><li>기존 파일명을 새 파일명으로 바꾼 배열 반환한다.</li></ul><h2 id="3-기타조건"><a href="#3-기타조건" class="headerlink" title="3. 기타조건"></a>3. 기타조건</h2><ul><li>사진 M개, 날짜 2000-2020년</li><li>이름 중복가능, 모두 영어</li><li>동일도시, 동일시간은 없다</li></ul>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/12/codility5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 - (4) Prefix Sums</title>
      <link>https://katie0809.github.io/2020/10/09/codility4/</link>
      <guid>https://katie0809.github.io/2020/10/09/codility4/</guid>
      <pubDate>Fri, 09 Oct 2020 05:46:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;prefix sum은 부분합 배열을 의미한다. 개념은 단순하다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;다음과 같은 배열 A가 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A = [ 1, 4, 6, 3, 7, 9 ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;이때 배열 A의 prefix sum, 즉 부분합 배열 K는 아래와 같다&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;K = [ 1, 5, 11, 14, 21, 30 ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;상당히 간단한 개념이다. 고등학교 수학시간에 배웠던 것 같은데. 여튼 prefix sum의 장점은 구간의 부분합을 쉽게 구할 수 있다는 점이다.&lt;/p&gt;
&lt;p&gt;즉, A[3] + A[4] + A[5] = K[5] - K[2]이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>prefix sum은 부분합 배열을 의미한다. 개념은 단순하다</p><ol><li><p>다음과 같은 배열 A가 있다.</p><blockquote><p>A = [ 1, 4, 6, 3, 7, 9 ]</p></blockquote></li><li><p>이때 배열 A의 prefix sum, 즉 부분합 배열 K는 아래와 같다</p></li></ol><blockquote><p>K = [ 1, 5, 11, 14, 21, 30 ]</p></blockquote><p>상당히 간단한 개념이다. 고등학교 수학시간에 배웠던 것 같은데. 여튼 prefix sum의 장점은 구간의 부분합을 쉽게 구할 수 있다는 점이다.</p><p>즉, A[3] + A[4] + A[5] = K[5] - K[2]이다.</p><a id="more"></a><h1 id="Question-1-CountDiv"><a href="#Question-1-CountDiv" class="headerlink" title="Question 1 - CountDiv"></a>Question 1 - CountDiv</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> K)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given three integers A, B and K, returns the number of integers within the range [A..B] that are divisible by K, i.e.:</span><br><span class="line"></span><br><span class="line">&#123; i : A ≤ i ≤ B, i mod K = <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">For example, <span class="keyword">for</span> A = <span class="number">6</span>, B = <span class="number">11</span> and K = <span class="number">2</span>, your function should <span class="keyword">return</span> <span class="number">3</span>, because there are three numbers divisible by <span class="number">2</span> within the range [<span class="number">6</span>..<span class="number">11</span>], namely <span class="number">6</span>, <span class="number">8</span> and <span class="number">10</span>.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">A and B are integers within the range [<span class="number">0</span>..<span class="number">2</span>,<span class="number">000</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">K is an integer within the range [<span class="number">1</span>..<span class="number">2</span>,<span class="number">000</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">A ≤ B.</span><br></pre></td></tr></table></figure><ul><li>주어진 A와 B 사이의 숫자들 중 K로 나누어질 수 있는 수의 개수를 반환하라.</li><li>나누어 떨어진다의 기준이 X%K == 0 인것이 함정. 0%K == 0이므로 A,B가 0인 경우에 대한 예외처리가 필요했다.</li><li>엄청 간단하다고 생각했는데 내가 늘 그렇듯 자꾸 대충짜서 내니깐 edge case에서 예외가 많이 걸림…</li><li>Codility는 테스트 케이스를 너무 조금준다ㅠㅠ 예외경우도 생각하는게 물론 개발자의 역량이라지만 코딩보다 테스트가 오래걸려서 답답한걸 어카나요..^^ㅠ</li></ul><h2 id="My-Solution-100"><a href="#My-Solution-100" class="headerlink" title="My Solution(100%)"></a>My Solution(100%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; "this is a debug message" &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(B==K) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(B&lt;K) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        ret += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> Adivisible = (A==<span class="number">0</span>) ? <span class="number">0</span> : (A<span class="number">-1</span>) / K;</span><br><span class="line">    <span class="keyword">int</span> Bdivisible = B / K;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(A==B &amp;&amp; B%K==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret + (Bdivisible - Adivisible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>지금 풀고나니 생각나네 아… 이걸 그냥 부분합으로 풀걸;;;; 개멍청쓰;;</li></ul><h1 id="Question-2-MinDnaSequence"><a href="#Question-2-MinDnaSequence" class="headerlink" title="Question 2 - MinDnaSequence"></a>Question 2 - MinDnaSequence</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">A DNA sequence can be represented as a string consisting of the letters A, C, G and T, which correspond to the types of successive nucleotides in the sequence. Each nucleotide has an impact factor, which is an integer. Nucleotides of types A, C, G and T have impact factors of <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> and <span class="number">4</span>, respectively. You are going to answer several queries of the form: What is the minimal impact factor of nucleotides contained in a particular part of the given DNA sequence?</span><br><span class="line"></span><br><span class="line">The DNA sequence is given as a non-empty string S = S[<span class="number">0</span>]S[<span class="number">1</span>]...S[N-<span class="number">1</span>] consisting of N characters. There are M queries, which are given in non-empty arrays P and Q, each consisting of M integers. The K-<span class="function">th <span class="title">query</span> <span class="params">(<span class="number">0</span> ≤ K &lt; M)</span> <span class="keyword">requires</span> you to find the minimal impact factor of nucleotides contained in the DNA sequence between positions P[K] and Q[K] <span class="params">(inclusive)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">For example, consider string S </span>= CAGCCTA and arrays P, Q such that:</span><br><span class="line"></span><br><span class="line">    P[<span class="number">0</span>] = <span class="number">2</span>    Q[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    P[<span class="number">1</span>] = <span class="number">5</span>    Q[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">    P[<span class="number">2</span>] = <span class="number">0</span>    Q[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">The answers to these M = <span class="number">3</span> queries are as follows:</span><br><span class="line"></span><br><span class="line">The part of the DNA between positions <span class="number">2</span> and <span class="number">4</span> <span class="function">contains nucleotides G and <span class="title">C</span> <span class="params">(twice)</span>, whose impact factors are 3 and 2 respectively, so the answer is 2.</span></span><br><span class="line"><span class="function">The part between positions 5 and 5 contains a single nucleotide T, whose impact factor is 4, so the answer is 4.</span></span><br><span class="line"><span class="function">The part between positions 0 and 6 <span class="params">(the whole string)</span> contains all nucleotides, in particular nucleotide A whose impact factor is 1, so the answer is 1.</span></span><br><span class="line"><span class="function">Write a function:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Solution </span>&#123; <span class="keyword">public</span> <span class="keyword">int</span>[] solution(String S, <span class="keyword">int</span>[] P, <span class="keyword">int</span>[] Q); &#125;</span><br><span class="line"></span><br><span class="line">that, given a non-empty string S consisting of N characters and two non-empty arrays P and Q consisting of M integers, returns an array consisting of M integers specifying the consecutive answers to all queries.</span><br><span class="line"></span><br><span class="line">Result array should be returned as an array of integers.</span><br><span class="line"></span><br><span class="line">For example, given the string S = CAGCCTA and arrays P, Q such that:</span><br><span class="line"></span><br><span class="line">    P[<span class="number">0</span>] = <span class="number">2</span>    Q[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    P[<span class="number">1</span>] = <span class="number">5</span>    Q[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">    P[<span class="number">2</span>] = <span class="number">0</span>    Q[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">the function should <span class="keyword">return</span> the values [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>], as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">1</span>..<span class="number">100</span>,<span class="number">000</span>];</span><br><span class="line">M is an integer within the range [<span class="number">1</span>..<span class="number">50</span>,<span class="number">000</span>];</span><br><span class="line">each element of arrays P, Q is an integer within the range [<span class="number">0</span>..N − <span class="number">1</span>];</span><br><span class="line">P[K] ≤ Q[K], where <span class="number">0</span> ≤ K &lt; M;</span><br><span class="line">string S consists only of upper-<span class="keyword">case</span> English letters A, C, G, T.</span><br></pre></td></tr></table></figure><ul><li>문제가 엄청길다ㅜㅠ</li><li>Nucleotide는 총 4가지가 있다. 각각은 정수값 impact factor과 매칭된다.<ul><li>A:1, C:2, G:3, T:4</li></ul></li><li>N개의 문자열로 이뤄진 DNA sequence가 있다.</li><li>길이 M의 non-empty array P, Q 가 있다.</li><li>Query K는 다음을 의미한다<ul><li>DNA sequence의 P[K]와 Q[K] 위치 사이의 minical impact factor를 찾아라</li></ul></li></ul><h2 id="My-Solution-67"><a href="#My-Solution-67" class="headerlink" title="My Solution(67%)"></a>My Solution(67%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(<span class="built_in">string</span> &amp;S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;P, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="comment">// nucleotide A, C, G, T의 DNA Sequence idx별 등장횟수</span></span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">4</span>][<span class="number">55555</span>];</span><br><span class="line">    <span class="comment">// nucleotide의 impact factor</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; impFac = &#123;&#123;<span class="string">'A'</span>, <span class="number">0</span>&#125;,&#123;<span class="string">'C'</span>, <span class="number">1</span>&#125;,&#123;<span class="string">'G'</span>, <span class="number">2</span>&#125;,&#123;<span class="string">'T'</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;S.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> dnaChar = S.at(i);</span><br><span class="line">        <span class="keyword">int</span> impactFactIdx = impFac[dnaChar];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 모든 문자의 등장횟수는 기본적으로 이전 등장횟수</span></span><br><span class="line">        count[<span class="number">0</span>][i] = (i==<span class="number">0</span>) ? <span class="number">0</span> : count[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        count[<span class="number">1</span>][i] = (i==<span class="number">0</span>) ? <span class="number">0</span> : count[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">        count[<span class="number">2</span>][i] = (i==<span class="number">0</span>) ? <span class="number">0</span> : count[<span class="number">2</span>][i<span class="number">-1</span>];</span><br><span class="line">        count[<span class="number">3</span>][i] = (i==<span class="number">0</span>) ? <span class="number">0</span> : count[<span class="number">3</span>][i<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 등장한 문자의 횟수 +1</span></span><br><span class="line">        count[impactFactIdx][i] = (i==<span class="number">0</span>) ? count[impactFactIdx][<span class="number">0</span>]+<span class="number">1</span> : count[impactFactIdx][i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;P.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> queryStartIdx = P[i]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> queryEndIdx = Q[i];</span><br><span class="line">        <span class="keyword">int</span> parDiff[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">            parDiff[j] = queryStartIdx&lt;<span class="number">0</span> ? count[j][queryEndIdx] : count[j][queryEndIdx] - count[j][queryStartIdx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parDiff[j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                ret.push_back(j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>로직은 얼추 맞는듯 한데 large dataset에서 런타임 에러가 발생한다. push_back이 너무 느린건가..</li></ul><h1 id="Question-2-MinAvgTwoSlice"><a href="#Question-2-MinAvgTwoSlice" class="headerlink" title="Question 2 - MinAvgTwoSlice"></a>Question 2 - MinAvgTwoSlice</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">A non-empty array A consisting of N integers is given. A pair of integers (P, Q), such that 0 ≤ P &lt; Q &lt; N, is called a slice of array A (notice that the slice contains at least two elements). The average of a slice (P, Q) is the sum of A[P] + A[P + 1] + ... + A[Q] divided by the length of the slice. To be precise, the average equals (A[P] + A[P + 1] + ... + A[Q]) / (Q − P + 1).</span><br><span class="line"></span><br><span class="line">For example, <span class="built_in">array</span> A such that:</span><br><span class="line"></span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    A[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    A[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">    A[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    A[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">    A[<span class="number">6</span>] = <span class="number">8</span></span><br><span class="line">contains the following example slices:</span><br><span class="line"></span><br><span class="line">slice (<span class="number">1</span>, <span class="number">2</span>), whose average is (<span class="number">2</span> + <span class="number">2</span>) / <span class="number">2</span> = <span class="number">2</span>;</span><br><span class="line">slice (3, 4), whose average is (5 + 1) / 2 = 3;</span><br><span class="line">slice (1, 4), whose average is (2 + 2 + 5 + 1) / 4 = 2.5.</span><br><span class="line">The goal is to <span class="built_in">find</span> the starting <span class="built_in">position</span> of a slice whose average is minimal.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given a non-empty <span class="built_in">array</span> A consisting of N integers, returns the starting <span class="built_in">position</span> of the slice with the minimal average. If there is more than one slice with a minimal average, you should <span class="keyword">return</span> the smallest starting <span class="built_in">position</span> of such a slice.</span><br><span class="line"></span><br><span class="line">For example, given <span class="built_in">array</span> A such that:</span><br><span class="line"></span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    A[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    A[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">    A[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    A[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">    A[<span class="number">6</span>] = <span class="number">8</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">1</span>, as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">2.</span><span class="number">.100</span>,<span class="number">000</span>];</span><br><span class="line">each element of <span class="built_in">array</span> A is an integer within the range [−<span class="number">10</span>,<span class="number">000.</span><span class="number">.10</span>,<span class="number">000</span>].</span><br></pre></td></tr></table></figure><h2 id="My-Solution-60"><a href="#My-Solution-60" class="headerlink" title="My Solution(60%)"></a>My Solution(60%)</h2><ul><li>memset 사용시에는 string.h 헤더 포함해야 한다.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> N = A.<span class="built_in">size</span>(); <span class="comment">// 배열 A의 길이</span></span><br><span class="line">    <span class="keyword">int</span> parSum[N+<span class="number">1</span>]; <span class="comment">// 부분합 배열</span></span><br><span class="line">    <span class="built_in">memset</span>(parSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(N+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 배열 A의 부분합을 구한다.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        parSum[i+<span class="number">1</span>] = parSum[i] + A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 각 부분합에 대해 평균을 구한다. 동시에 부분합의 평균이 최소가 인덱스를 구한다.</span></span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">min</span> = <span class="number">111111</span>;</span><br><span class="line">    <span class="keyword">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;N; p++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;N; q++)&#123;</span><br><span class="line">            <span class="keyword">double</span> diff = parSum[q+<span class="number">1</span>] - parSum[p];</span><br><span class="line">            <span class="keyword">double</span> avg = diff / (q-p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(avg &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">                <span class="built_in">min</span> = avg;</span><br><span class="line">                minIdx = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>아이디어가 안떠올라서 일단 가장 간단하게 구현한 코드..ㅠ O(N^2 / 2) 이므로 당연하게도 timeout error가 났다.</li><li>구글신의 힘을 빌렸다. 아주 그냥 수학문제다 머리아파;;<br>: <a href="https://nukeguys.tistory.com/175" rel="external nofollow noopener noreferrer" target="_blank">https://nukeguys.tistory.com/175</a></li></ul><h1 id="Question-3-괄호변환"><a href="#Question-3-괄호변환" class="headerlink" title="Question 3 - 괄호변환"></a>Question 3 - <a href="https://tech.kakao.com/2019/10/02/kakao-blind-recruitment-2020-round1/" rel="external nofollow noopener noreferrer" target="_blank">괄호변환</a></h1><ul><li>디스크 겹치는거 풀다가 도저히 머리가 이해를 못해서 카카오 신입채용 문제로 급선회</li><li>익숙한 dfs문제이다.</li><li><strong>stack의 top()연산은 stack이 비어있으면 Segmentation fault에러가 발생한다.</strong></li></ul><h2 id="My-Solution-100-1"><a href="#My-Solution-100-1" class="headerlink" title="My Solution(100%)"></a>My Solution(100%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">flip</span><span class="params">(<span class="built_in">string</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 첫번째와 마지막 문자를 제거한다.</span></span><br><span class="line">    <span class="built_in">string</span> parU = u.substr(<span class="number">1</span>, u.length()<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 괄호방향을 뒤집는다.</span></span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;parU.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parU.at(i) == <span class="string">'('</span>) ret += <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(parU.at(i) == <span class="string">')'</span>) ret += <span class="string">"("</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCorrect</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.at(i);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</span><br><span class="line">            st.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty() &amp;&amp; st.top() == <span class="string">'('</span>) st.pop();</span><br><span class="line">            <span class="keyword">else</span> st.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> wIdx = p.length()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;p.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = p.at(i);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</span><br><span class="line">            st += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">            st -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st == <span class="number">0</span>)&#123; <span class="comment">// 균형잡힌 문자열 u를 얻음</span></span><br><span class="line">            wIdx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> u = p.substr(<span class="number">0</span>, wIdx+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">string</span> v = (wIdx == p.length()<span class="number">-1</span>) ? <span class="string">""</span> : solve(p.substr(wIdx + <span class="number">1</span>, p.length()<span class="number">-1</span>-wIdx));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(isCorrect(u))&#123; <span class="comment">// u가 올바른 문자열인 경우</span></span><br><span class="line">        <span class="keyword">return</span> u+v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// u가 올바른 문자열이 아닌 경우</span></span><br><span class="line">        <span class="built_in">string</span> newU = <span class="string">"("</span>;</span><br><span class="line">        newU += v;</span><br><span class="line">        newU += <span class="string">")"</span>;</span><br><span class="line">        newU += flip(u);</span><br><span class="line">        <span class="keyword">return</span> newU;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solution</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> answer = solve(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/09/codility4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 - (3) Counting Elements</title>
      <link>https://katie0809.github.io/2020/10/09/codility3/</link>
      <guid>https://katie0809.github.io/2020/10/09/codility3/</guid>
      <pubDate>Thu, 08 Oct 2020 16:24:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;Codility사이트는 해당 Lessons관련 이론 pdf파일도 같이 제공해준다. pdf 파일이 굉장히 대학시절 알고리즘 교재에서 본것처럼 생겼다.&lt;/p&gt;
&lt;p&gt;여튼 생짜로 머리에서 아이디어를 꺼내는 것 보다 이 관련 자료를 읽고 힌트를 얻어 문제를 푸는게 훨씬 유용한 것 같다!!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codility.com/media/train/2-CountingElements.pdf&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Counting Elements.pdf&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그룹 A와 B가 있다. 두 그룹에서 하나의 페어를 찾아 바꿈으로서 각 그룹의 총합이 같도록 만들수 있는지를 판별하려면?&lt;/li&gt;
&lt;li&gt;각 그룹의 총합의 차를 구한다. 그룹1의 총합이 10, 그룹2의 총합이 13이라고 해보자. 이때 &lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Codility사이트는 해당 Lessons관련 이론 pdf파일도 같이 제공해준다. pdf 파일이 굉장히 대학시절 알고리즘 교재에서 본것처럼 생겼다.</p><p>여튼 생짜로 머리에서 아이디어를 꺼내는 것 보다 이 관련 자료를 읽고 힌트를 얻어 문제를 푸는게 훨씬 유용한 것 같다!!</p><p><a href="https://codility.com/media/train/2-CountingElements.pdf" rel="external nofollow noopener noreferrer" target="_blank">Counting Elements.pdf</a></p><ul><li>그룹 A와 B가 있다. 두 그룹에서 하나의 페어를 찾아 바꿈으로서 각 그룹의 총합이 같도록 만들수 있는지를 판별하려면?</li><li>각 그룹의 총합의 차를 구한다. 그룹1의 총합이 10, 그룹2의 총합이 13이라고 해보자. 이때 </li></ul><a id="more"></a><h1 id="Question1-FrogRiverOne"><a href="#Question1-FrogRiverOne" class="headerlink" title="Question1 - FrogRiverOne"></a>Question1 - FrogRiverOne</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">A small frog wants to get to the other side of a river. <span class="function">The frog is initially located on one bank of the <span class="title">river</span> <span class="params">(position <span class="number">0</span>)</span> and wants to get to the opposite <span class="title">bank</span> <span class="params">(position X+<span class="number">1</span>)</span>. Leaves fall from a tree onto the surface of the river.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">You are given an array A consisting of N integers representing the falling leaves. A[K] represents the position where one leaf falls at time K, measured in seconds.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">The goal is to find the earliest time when the frog can jump to the other side of the river. The frog can cross only when leaves appear at every position across the river from 1 to <span class="title">X</span> <span class="params">(that is, we want to find the earliest moment when all the positions from <span class="number">1</span> to X are covered by leaves)</span>. You may assume that the speed of the current in the river is negligibly small, i.e. the leaves <span class="keyword">do</span> not change their positions once they fall in the river.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">For example, you are given integer X </span>= <span class="number">5</span> and array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">  A[<span class="number">4</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">5</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">  A[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line">In second <span class="number">6</span>, a leaf falls into position <span class="number">5</span>. This is the earliest time when leaves appear in every position across the river.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given a non-empty array A consisting of N integers and integer X, returns the earliest time when the frog can jump to the other side of the river.</span><br><span class="line"></span><br><span class="line">If the frog is never able to jump to the other side of the river, the function should <span class="keyword">return</span> −<span class="number">1</span>.</span><br><span class="line"></span><br><span class="line">For example, given X = <span class="number">5</span> and array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">  A[<span class="number">4</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">5</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">  A[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">6</span>, as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N and X are integers within the range [<span class="number">1</span>..<span class="number">100</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [<span class="number">1</span>..X].</span><br></pre></td></tr></table></figure><h2 id="My-Solution-100"><a href="#My-Solution-100" class="headerlink" title="My Solution(100%)"></a>My Solution(100%)</h2><ul><li><a href="https://codingham.tistory.com/158" rel="external nofollow noopener noreferrer" target="_blank">배열초기화 참고</a></li><li>1-X까지의 합을 구해두고 counting board에 새로운 정수가 등록될 때마다 현재 sum을 구한다. 현재 sum이 1-X까지의 합과 같아지는 순간이 개구리가 뛸 수 있는 순간.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> sum = (<span class="number">1</span> + X) * X / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> countBoard[<span class="number">111111</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(countBoard, <span class="literal">false</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * <span class="number">111111</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = A[i];</span><br><span class="line">        <span class="keyword">if</span>(!countBoard[k])&#123;</span><br><span class="line">            <span class="comment">// K never occured before</span></span><br><span class="line">            curSum += k;</span><br><span class="line">            countBoard[k] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curSum == sum) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Question2-Max-Counters"><a href="#Question2-Max-Counters" class="headerlink" title="Question2 - Max Counters"></a>Question2 - Max Counters</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">You are given N counters, initially <span class="built_in">set</span> to <span class="number">0</span>, <span class="keyword">and</span> you have two possible operations on them:</span><br><span class="line"></span><br><span class="line">increase(X) − counter X is increased by <span class="number">1</span>,</span><br><span class="line"><span class="built_in">max</span> counter − all counters are <span class="built_in">set</span> to the maximum value of any counter.</span><br><span class="line">A non-empty <span class="built_in">array</span> A of M integers is given. This <span class="built_in">array</span> represents consecutive operations:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> A[K] = X, such that <span class="number">1</span> ≤ X ≤ N, then operation K is increase(X),</span><br><span class="line"><span class="keyword">if</span> A[K] = N + <span class="number">1</span> then operation K is <span class="built_in">max</span> counter.</span><br><span class="line">For example, given integer N = <span class="number">5</span> <span class="keyword">and</span> <span class="built_in">array</span> A such that:</span><br><span class="line"></span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    A[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    A[<span class="number">5</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line">the values of the counters after each consecutive operation will be:</span><br><span class="line"></span><br><span class="line">    (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">    (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    (<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    (<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    (<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">The goal is to calculate the value of every counter after all operations.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line">class Solution &#123; <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span> N, <span class="keyword">int</span>[] A); &#125;</span><br><span class="line"></span><br><span class="line">that, given an integer N <span class="keyword">and</span> a non-empty <span class="built_in">array</span> A consisting of M integers, returns a sequence of integers representing the values of the counters.</span><br><span class="line"></span><br><span class="line">Result <span class="built_in">array</span> should be returned as an <span class="built_in">array</span> of integers.</span><br><span class="line"></span><br><span class="line">For example, given:</span><br><span class="line"></span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    A[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    A[<span class="number">5</span>] = <span class="number">4</span></span><br><span class="line">    A[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line">the function should <span class="keyword">return</span> [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>], as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N <span class="keyword">and</span> M are integers within the range [<span class="number">1.</span><span class="number">.100</span>,<span class="number">000</span>];</span><br><span class="line">each element of <span class="built_in">array</span> A is an integer within the range [<span class="number">1.</span>.N + <span class="number">1</span>].</span><br></pre></td></tr></table></figure><ul><li>길이 N의 카운터 배열이 있다(0으로 초기화됨)</li><li>각 카운터에 대해 어떤 연산을 할지 기준이 되는 연산배열 A가 있다.</li><li>배열A의 값에 따라 카운터 연산이 달라진다(A의 길이는 M)<ul><li>A[k]의 값 X가 1보다 크거나 같고 N보다 작거나 같다면 counter[X]++</li><li>A[k]의 값이 N+1과 같다면 counter배열의 모든 값은 현재 카운터 중 최대값으로 변경</li></ul></li><li>배열A의 모든 값의 범위는 [1, N+1]</li><li>연산이 완료된 이후의 카운터 배열을 반환하라.</li></ul><h2 id="My-Solution1-77"><a href="#My-Solution1-77" class="headerlink" title="My Solution1(77%)"></a>My Solution1(77%)</h2><ul><li>동적 배열할당시에 new와 delete 키워드를 사용한다.</li><li><a href="https://boycoding.tistory.com/205" rel="external nofollow noopener noreferrer" target="_blank">동적배열 할당 및 해제</a></li><li><code>int *counter</code> 로 전역변수 선언</li><li><code>counter = new int[N]()</code> 길이 N의 배열 동적 생성후 0으로 초기화한다.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max Counter</span></span><br><span class="line"><span class="keyword">int</span> *_counter;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">int</span> maxCounterVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max Counter</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 길이 N의 카운터 배열 생성후 0으로 초기화</span></span><br><span class="line">    <span class="comment">// _counter = new int[N]();</span></span><br><span class="line">    counter.resize(N);</span><br><span class="line">    maxCounterVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> K = A[i];</span><br><span class="line">        <span class="keyword">if</span>(K == N+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">fill</span>(counter.<span class="built_in">begin</span>(), counter.<span class="built_in">end</span>(), maxCounterVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            counter[K<span class="number">-1</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(counter[K<span class="number">-1</span>] &gt; maxCounterVal) maxCounterVal = counter[K<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>문제에서 얘기하는 내용을 그대로 정직하게 구현함.</li><li>값은 제대로 반환하지만 large dataset에서 timeout error가 발생한다.</li><li>해당 레슨의 핵심이 Counting Elements인 것에 착안해 좀더 고민을 해봤다. 모든 max 연산이 있을때마다 fill을 수행하는 것이 비효율적이다. 최악의 경우 O(N*M)의 성능을 가진 알고리즘.</li></ul><h2 id="My-Solution2-100"><a href="#My-Solution2-100" class="headerlink" title="My Solution2(100%)"></a>My Solution2(100%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max Counter</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">int</span> maxCounterVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max Counter</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 길이 N의 카운터 배열 생성후 0으로 초기화</span></span><br><span class="line">    counter.resize(N);</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> whatToDo = A[i];</span><br><span class="line">        <span class="keyword">if</span>(whatToDo == N+<span class="number">1</span>)&#123;</span><br><span class="line">            prevMax = curMax;</span><br><span class="line">            <span class="comment">// curMax = 0; // 이부분이 틀렸다.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> idx = whatToDo - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> howOftenAppeared = counter[idx];</span><br><span class="line">            <span class="keyword">if</span>(howOftenAppeared &lt; prevMax)&#123;</span><br><span class="line">                counter[idx] = prevMax+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                counter[idx]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(counter[idx] &gt; curMax) curMax = counter[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;counter.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(counter[i] &lt; prevMax) counter[i] = prevMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>max변환 연산이 나오면 <code>변환연산 기준max</code>를 저장해둔다.</li><li>max변환 연산이 아닌 경우는 해당 원소의 카운트값(howOftenAppeared)이  <code>변환연산 기준max</code>보다 큰지 작은지를 비교해서 현재의  <code>변환연산 기준max</code> + 1이나 그냥 +1 이렇게 두가지로 연산 분리한다.</li><li>현재의 max는 계속 업데이트 하다가 변환연산이 나올때마다  <code>변환연산 기준max</code>에 저장해준다.</li><li>최종적으로 다시 전체 카운터 배열을 순회하면서  <code>변환연산 기준max</code>보다 작은값은 기준max값으로 변환해준다.</li><li>아 머리아파ㅠ</li></ul><h1 id="Question-3-FindSmallestInteger"><a href="#Question-3-FindSmallestInteger" class="headerlink" title="Question 3 - FindSmallestInteger"></a>Question 3 - FindSmallestInteger</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">This is a demo task.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given an array A of N integers, <span class="function">returns the smallest positive <span class="title">integer</span> <span class="params">(greater than <span class="number">0</span>)</span> that does not occur in A.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">For example, given A </span>= [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>], the function should <span class="keyword">return</span> <span class="number">5</span>.</span><br><span class="line"></span><br><span class="line">Given A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], the function should <span class="keyword">return</span> <span class="number">4</span>.</span><br><span class="line"></span><br><span class="line">Given A = [−<span class="number">1</span>, −<span class="number">3</span>], the function should <span class="keyword">return</span> <span class="number">1</span>.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">1</span>..<span class="number">100</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [−<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span>..<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span>].</span><br></pre></td></tr></table></figure><ul><li>N개의 정수로 이루어진 배열 A</li><li>A 배열에 없는 가장 작은 정수 X를 찾아라(X&gt;0)</li></ul><h2 id="My-Solution-100-1"><a href="#My-Solution-100-1" class="headerlink" title="My Solution(100%)"></a>My Solution(100%)</h2><ul><li>아무리 고민해도 그냥 배열 여러번 순회하는 아이디어밖에 떠오르지 않았다. 이경우 시간복잡도가 대충 O(2N)정도 될것같아서.. 그냥 가장 간단하게 풀었다. 의외로 통과</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> counter[<span class="number">1111111</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> onePositive = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    counter[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> arrVal = A[i];</span><br><span class="line">        <span class="keyword">if</span>(arrVal &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> onePositive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!counter[arrVal]) counter[arrVal] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!onePositive) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!counter[i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/09/codility3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 - (2) Time complexity</title>
      <link>https://katie0809.github.io/2020/10/08/codility2/</link>
      <guid>https://katie0809.github.io/2020/10/08/codility2/</guid>
      <pubDate>Thu, 08 Oct 2020 05:15:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;Lesson 3은 시간복잡도에 관한 예제들이다. 총 3문제!&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Lesson 3은 시간복잡도에 관한 예제들이다. 총 3문제!</p><a id="more"></a><h1 id="Question1-FrogJmp"><a href="#Question1-FrogJmp" class="headerlink" title="Question1 - FrogJmp"></a>Question1 - FrogJmp</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.</span><br><span class="line"></span><br><span class="line">Count the minimal number of jumps that the small frog must perform to reach its target.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> D)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal to or greater than Y.</span><br><span class="line"></span><br><span class="line">For example, given:</span><br><span class="line"></span><br><span class="line">  X = <span class="number">10</span></span><br><span class="line">  Y = <span class="number">85</span></span><br><span class="line">  D = <span class="number">30</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">3</span>, because the frog will be positioned as follows:</span><br><span class="line"></span><br><span class="line">after the first jump, at position <span class="number">10</span> + <span class="number">30</span> = <span class="number">40</span></span><br><span class="line">after the second jump, at position <span class="number">10</span> + <span class="number">30</span> + <span class="number">30</span> = <span class="number">70</span></span><br><span class="line">after the third jump, at position <span class="number">10</span> + <span class="number">30</span> + <span class="number">30</span> + <span class="number">30</span> = <span class="number">100</span></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">X, Y and D are integers within the range [<span class="number">1</span>..<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">X ≤ Y.</span><br></pre></td></tr></table></figure><ul><li>한번에 D씩 움직이는 개구리가 X에서 Y로 가기위해 몇번 점프해야할까?</li></ul><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> gap = Y - X;</span><br><span class="line">    <span class="keyword">int</span> remainder = gap % D;</span><br><span class="line">    <span class="keyword">int</span> jump = gap / D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(gap == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(remainder == <span class="number">0</span>) <span class="keyword">return</span> jump;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> jump+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Question2-PermMissingElem"><a href="#Question2-PermMissingElem" class="headerlink" title="Question2 - PermMissingElem"></a>Question2 - PermMissingElem</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">An array A consisting of N different integers is given. The array contains integers in the range [<span class="number">1</span>..(N + <span class="number">1</span>)], which means that exactly one element is missing.</span><br><span class="line"></span><br><span class="line">Your goal is to find that missing element.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given an array A, returns the value of the missing element.</span><br><span class="line"></span><br><span class="line">For example, given array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">4</span>, as it is the missing element.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">0</span>..<span class="number">100</span>,<span class="number">000</span>];</span><br><span class="line">the elements of A are all distinct;</span><br><span class="line">each element of array A is an integer within the range [<span class="number">1</span>..(N + <span class="number">1</span>)].</span><br></pre></td></tr></table></figure><ul><li>N개의 서로다른 정수로 이루어진 배열 A가 주어진다. </li><li>이 길이 N의 배열 A는 1 ~ N+1 까지의 수로 이뤄진다. 즉, 한개가 빠져있는것.</li><li>빠진놈을 찾아라</li></ul><h2 id="My-Solution-50"><a href="#My-Solution-50" class="headerlink" title="My Solution(50%)"></a>My Solution(50%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 받아온 배열 정렬</span></span><br><span class="line">    sort(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]<span class="number">-1</span> != i) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>왜 이게 50%지? 디버깅이 안되니 불편하다ㅠㅠㅠ 디버깅할 방법을 찾아봐야겠음…</li></ul><h1 id="Question3"><a href="#Question3" class="headerlink" title="Question3 -"></a>Question3 -</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">A non-empty array A consisting of N integers is given. Array A represents numbers on a tape.</span><br><span class="line"></span><br><span class="line">Any integer P, such that <span class="number">0</span> &lt; P &lt; N, splits <span class="keyword">this</span> tape into two non-empty parts: A[<span class="number">0</span>], A[<span class="number">1</span>], ..., A[P − <span class="number">1</span>] and A[P], A[P + <span class="number">1</span>], ..., A[N − <span class="number">1</span>].</span><br><span class="line"></span><br><span class="line">The difference between the two parts is the value of: |(A[<span class="number">0</span>] + A[<span class="number">1</span>] + ... + A[P − <span class="number">1</span>]) − (A[P] + A[P + <span class="number">1</span>] + ... + A[N − <span class="number">1</span>])|</span><br><span class="line"></span><br><span class="line">In other words, it is the absolute difference between the sum of the first part and the sum of the second part.</span><br><span class="line"></span><br><span class="line">For example, consider array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">  A[<span class="number">4</span>] = <span class="number">3</span></span><br><span class="line">We can split <span class="keyword">this</span> tape in four places:</span><br><span class="line"></span><br><span class="line">P = <span class="number">1</span>, difference = |<span class="number">3</span> − <span class="number">10</span>| = <span class="number">7</span></span><br><span class="line">P = <span class="number">2</span>, difference = |<span class="number">4</span> − <span class="number">9</span>| = <span class="number">5</span></span><br><span class="line">P = <span class="number">3</span>, difference = |<span class="number">6</span> − <span class="number">7</span>| = <span class="number">1</span></span><br><span class="line">P = <span class="number">4</span>, difference = |<span class="number">10</span> − <span class="number">3</span>| = <span class="number">7</span></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>;</span><br><span class="line"></span><br><span class="line">that, given a non-empty array A of N integers, returns the minimal difference that can be achieved.</span><br><span class="line"></span><br><span class="line">For example, given:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">  A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  A[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">  A[<span class="number">4</span>] = <span class="number">3</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">1</span>, as explained above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an integer within the range [<span class="number">2</span>..<span class="number">100</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [−<span class="number">1</span>,<span class="number">000</span>..<span class="number">1</span>,<span class="number">000</span>].</span><br></pre></td></tr></table></figure><ul><li>non-empty array A는 N개의 정수로 이루어짐</li><li>P를 기점으로 배열 A는 0<del>(P-1), P</del>(N-1)의 두개 파트로 나뉜다.</li><li>각 파트의 합의 차이를 최소로 만드는 P를 찾아서 그 최소값을 반환하라(이때 파트간 합의 차는 절대값 씌운다.)</li></ul><h2 id="My-Solution-76"><a href="#My-Solution-76" class="headerlink" title="My Solution(76%)"></a>My Solution(76%)</h2><ul><li>양끝에서 인덱스가 같이 다가오는 아이디어로 풀어봤다. </li><li>왼쪽집합과 오른쪽 집합의 합을 구해가면서 집합의 차가 작아지는 방향으로 계속 움직이도록 한다.</li><li>결과는 76점ㅠㅠ 뭘 빼먹은걸까…</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; "this is a debug message" &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> startIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> endIdx = A.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sumLeft = A[startIdx];</span><br><span class="line">    <span class="keyword">int</span> sumRight = A[endIdx];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">abs</span>(sumLeft - sumRight);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sumLeft == sumRight)&#123;</span><br><span class="line">            <span class="keyword">if</span>(endIdx - startIdx == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(endIdx - startIdx == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">abs</span>(A[startIdx+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(A[startIdx+<span class="number">1</span>] &lt;= <span class="built_in">abs</span>(A[endIdx<span class="number">-1</span>])))&#123;</span><br><span class="line">                    startIdx++;</span><br><span class="line">                    sumLeft += A[startIdx];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    endIdx--;</span><br><span class="line">                    sumRight += A[endIdx];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 더 값이 큰 집합을 작아지게 만들거나</span></span><br><span class="line">        <span class="comment">// 더 값이 작은 집합을 커지게 만든다</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(startIdx+<span class="number">1</span> &gt;= endIdx)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">abs</span>(sumLeft - sumRight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ifMoveRight = <span class="built_in">abs</span>((sumLeft + A[startIdx+<span class="number">1</span>]) - sumRight);</span><br><span class="line">            <span class="keyword">int</span> ifMoveLeft = <span class="built_in">abs</span>(sumLeft - (sumRight + A[endIdx<span class="number">-1</span>]));</span><br><span class="line">            <span class="keyword">if</span>(ifMoveRight &lt;= ifMoveLeft)&#123;</span><br><span class="line">                startIdx++;</span><br><span class="line">                sumLeft += A[startIdx];   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifMoveRight &gt; ifMoveLeft)&#123;</span><br><span class="line">                endIdx--;</span><br><span class="line">                sumRight += A[endIdx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="My-Solution2-100"><a href="#My-Solution2-100" class="headerlink" title="My Solution2(100%)"></a>My Solution2(100%)</h2><ul><li>배열을 순회하면서 각 인덱스까지의 합을 저장한다. 반대로도 병렬 수행</li><li>전체 배열에 대해 두개 배열의 차를 구한다. 최소값을 같이 구한다. 이렇게하면 아마도 O(2N)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> N = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">moveRightBoard</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">moveLeftBoard</span><span class="params">(N)</span></span>;</span><br><span class="line">    </span><br><span class="line">    moveRightBoard[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">    moveLeftBoard[N<span class="number">-1</span>] = A[N<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">abs</span>(A[<span class="number">0</span>] - A[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=N<span class="number">-2</span>; i&lt;A.<span class="built_in">size</span>(); i++, j--)&#123;</span><br><span class="line">        moveRightBoard[i] = moveRightBoard[i<span class="number">-1</span>] + A[i];</span><br><span class="line">        moveLeftBoard[j] = moveLeftBoard[j+<span class="number">1</span>] + A[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">9999999999999999</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="built_in">abs</span>(moveRightBoard[i] - moveLeftBoard[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">            <span class="built_in">min</span> = diff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/08/codility2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코딩테스트 준비하기 - (1) Arrays</title>
      <link>https://katie0809.github.io/2020/10/08/codility1/</link>
      <guid>https://katie0809.github.io/2020/10/08/codility1/</guid>
      <pubDate>Wed, 07 Oct 2020 23:43:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;코딩테스트를 준비할 일이 생겼다. Codility를 통해 공부하자. 어제 아주 기본적인 문제를 풀었는데 정확도가 80%밖에 되지 않았다 제길ㅠ 한창 코테 준비할땐 그래도 나쁘지 않았던 것 같은데… 계속하지 않으면 금방 까먹는 듯 하다.&lt;/p&gt;
&lt;p&gt;난이도별로 여러개의 예제가 엄선되어 있어서 좋다. 백준의 경우에는 너무 많은 예제가 중구난방으로 있어서 뭘 풀어야 할지 감을 잡기 어려운데 그런면에서 훨씬 잘되어 있는 것 같다. 알고리즘에는 역시 C지! 익숙한 C언어로 풀어보자.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>코딩테스트를 준비할 일이 생겼다. Codility를 통해 공부하자. 어제 아주 기본적인 문제를 풀었는데 정확도가 80%밖에 되지 않았다 제길ㅠ 한창 코테 준비할땐 그래도 나쁘지 않았던 것 같은데… 계속하지 않으면 금방 까먹는 듯 하다.</p><p>난이도별로 여러개의 예제가 엄선되어 있어서 좋다. 백준의 경우에는 너무 많은 예제가 중구난방으로 있어서 뭘 풀어야 할지 감을 잡기 어려운데 그런면에서 훨씬 잘되어 있는 것 같다. 알고리즘에는 역시 C지! 익숙한 C언어로 풀어보자.</p><a id="more"></a><h1 id="Question1-Cyclic-Rotation"><a href="#Question1-Cyclic-Rotation" class="headerlink" title="Question1 - Cyclic Rotation"></a>Question1 - Cyclic Rotation</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>] is [<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>] (elements are shifted right by one index and <span class="number">6</span> is moved to the first place).</span><br><span class="line"></span><br><span class="line">The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.</span><br><span class="line"></span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K); &#125;</span><br><span class="line"></span><br><span class="line">that, given an array A consisting of N integers and an integer K, returns the array A rotated K times.</span><br><span class="line"></span><br><span class="line">For example, given</span><br><span class="line"></span><br><span class="line">    A = [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">    K = <span class="number">3</span></span><br><span class="line">the function should <span class="keyword">return</span> [<span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>]. Three rotations were made:</span><br><span class="line"></span><br><span class="line">    [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>] -&gt; [<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line">    [<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>] -&gt; [<span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>] -&gt; [<span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>]</span><br><span class="line">For another example, given</span><br><span class="line"></span><br><span class="line">    A = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    K = <span class="number">1</span></span><br><span class="line">the function should <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">Given</span><br><span class="line"></span><br><span class="line">    A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    K = <span class="number">4</span></span><br><span class="line">the function should <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">Assume that:</span><br><span class="line"></span><br><span class="line">N and K are integers within the range [<span class="number">0</span>..<span class="number">100</span>];</span><br><span class="line">each element of array A is an integer within the range [−<span class="number">1</span>,<span class="number">000</span>..<span class="number">1</span>,<span class="number">000</span>].</span><br><span class="line">In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.</span><br></pre></td></tr></table></figure><ul><li>Array를 받는다</li><li>Array를 Rotate 한다는것은 오른쪽으로 한칸 미는것을 의미 -&gt; 바보같이 왼쪽으로 한칸 미는걸로 풀어서 헤맸다</li><li>Array를 K번  Rotate한 결과를 리턴한다.</li></ul><p>문제 solution에서 vector array를 사용한다. 오랜만에 vector를 보니 잘 기억나지 않아서 정리!</p><p><a href="http://www.cplusplus.com/reference/vector/vector/" rel="external nofollow noopener noreferrer" target="_blank">http://www.cplusplus.com/reference/vector/vector/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 벡터의 선언 */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;        <span class="comment">//int형 백터 생성</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="number">4</span>);    <span class="comment">//int형 백터 생성 후 크기를 4로 할당(모든 백터요소 0으로 초기화)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;        <span class="comment">//int형 백터 생성 후 1, 2, 3 으로 초기화</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[] = &#123;&#123; <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;        <span class="comment">//int형 백터 배열 생성(행은 가변이지만 열은 고정)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;        <span class="comment">//2차원 백터 생성(행과 열 모두 가변)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;        </span><br><span class="line">v.assign(<span class="number">5</span>, <span class="number">10</span>);    <span class="comment">//백터 범위를 5로 지정하고 정수 10으로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 벡터의 사용 */</span></span><br><span class="line">v.<span class="built_in">begin</span>();<span class="comment">//벡터 시작점의 주소값 반환(Start index of an array)</span></span><br><span class="line">v.<span class="built_in">end</span>();<span class="comment">//벡터 끝부분+1의 주소값 반환(Length of an array)</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> arrLen = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> startIdx = arrLen - K;</span><br><span class="line">    <span class="keyword">int</span> endIdx = arrLen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(arrLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(arrLen &lt; K) &#123;</span><br><span class="line">        startIdx = arrLen - (K % arrLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startIdx; i&lt;=endIdx; i++)&#123;</span><br><span class="line">        ret.push_back(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;startIdx; j++)&#123;</span><br><span class="line">        ret.push_back(A[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>인덱스만 찾는다</li><li><code>empty array</code>에 대한 예외처리 잊지말자!</li></ul><h1 id="Question-2-Odd-occurencies-in-array"><a href="#Question-2-Odd-occurencies-in-array" class="headerlink" title="Question 2 - Odd occurencies in array"></a>Question 2 - Odd occurencies in array</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">A non-empty array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except <span class="keyword">for</span> one element that is left unpaired.</span><br><span class="line"></span><br><span class="line">For example, in array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">9</span>  A[<span class="number">1</span>] = <span class="number">3</span>  A[<span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">3</span>  A[<span class="number">4</span>] = <span class="number">9</span>  A[<span class="number">5</span>] = <span class="number">7</span></span><br><span class="line">  A[<span class="number">6</span>] = <span class="number">9</span></span><br><span class="line">the elements at indexes <span class="number">0</span> and <span class="number">2</span> have value <span class="number">9</span>,</span><br><span class="line">the elements at indexes <span class="number">1</span> and <span class="number">3</span> have value <span class="number">3</span>,</span><br><span class="line">the elements at indexes <span class="number">4</span> and <span class="number">6</span> have value <span class="number">9</span>,</span><br><span class="line">the element at index <span class="number">5</span> has value <span class="number">7</span> and is unpaired.</span><br><span class="line">Write a function:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">that, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element.</span><br><span class="line"></span><br><span class="line">For example, given array A such that:</span><br><span class="line"></span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">9</span>  A[<span class="number">1</span>] = <span class="number">3</span>  A[<span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">  A[<span class="number">3</span>] = <span class="number">3</span>  A[<span class="number">4</span>] = <span class="number">9</span>  A[<span class="number">5</span>] = <span class="number">7</span></span><br><span class="line">  A[<span class="number">6</span>] = <span class="number">9</span></span><br><span class="line">the function should <span class="keyword">return</span> <span class="number">7</span>, as explained in the example above.</span><br><span class="line"></span><br><span class="line">Write an efficient algorithm <span class="keyword">for</span> the following assumptions:</span><br><span class="line"></span><br><span class="line">N is an odd integer within the range [<span class="number">1</span>..<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">each element of array A is an integer within the range [<span class="number">1</span>..<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span>,<span class="number">000</span>];</span><br><span class="line">all but one of the values in A occur an even number of times.</span><br></pre></td></tr></table></figure><ul><li>non-empty array는 N개의 원소로 이루어져있다.</li><li>N개의 원소는 각자 짝이 있다</li><li>짝이 없는 원소 한개를 찾아라</li></ul><h2 id="My-Solution-67"><a href="#My-Solution-67" class="headerlink" title="My Solution(67%)"></a>My Solution(67%)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="comment">// Unpaired value일 확률이 있는 값들의 집합</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unpaired;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 숫자 k, k의 등장횟수</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = A[i];</span><br><span class="line">        memory[k]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memory[k] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// odd occurency</span></span><br><span class="line">            unpaired.push_back(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            unpaired.erase(<span class="built_in">remove</span>(unpaired.<span class="built_in">begin</span>(), unpaired.<span class="built_in">end</span>(), k), unpaired.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unpaired[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>로직 자체는 맞지만 원소개수가 많아지면 타임아웃에러 발생. O(N**2)</li></ul><h2 id="Other-Solution-100"><a href="#Other-Solution-100" class="headerlink" title="Other Solution(100%)"></a>Other Solution(100%)</h2><ul><li>아이디어가 좋네..</li><li>받아온 배열을 정렬한다. 정렬한 배열은 인덱스 0에서부터 2개씩 건너뛰며 루프를 돌린다. </li><li>현재 값이 다음값과 다르면 얘는 홀수개인놈. 얘 이후로는 쭉 인덱스가 깨져서 짝수개로 pair가 나뉘지 않는다.</li><li>현재값이 마지막 값이면 얘가 홀수개인놈.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> A[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    A = sorted(A)</span><br><span class="line">    print(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A), <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> == len(A):</span><br><span class="line">            <span class="keyword">return</span> A[i]</span><br><span class="line">        <span class="keyword">if</span> A[i] != A[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> A[i]</span><br><span class="line"></span><br><span class="line">test3([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h2 id="My-Solution-2-100"><a href="#My-Solution-2-100" class="headerlink" title="My Solution 2(100%)"></a>My Solution 2(100%)</h2><ul><li>c++의 sort함수는 기본적으로 오름차순 정렬을 수행한다. </li><li>sort(배열 시작주소, 배열 마지막주소 + 1)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">    sort(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == A.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> A[i];</span><br><span class="line">        <span class="keyword">if</span>(A[i] != A[i+<span class="number">1</span>]) <span class="keyword">return</span> A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/10/08/codility1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ES6 문법정리</title>
      <link>https://katie0809.github.io/2020/08/19/js-study1/</link>
      <guid>https://katie0809.github.io/2020/08/19/js-study1/</guid>
      <pubDate>Wed, 19 Aug 2020 11:22:42 GMT</pubDate>
      <description>
      
        &lt;p&gt;노드 공부하면서 ES6문법도 같이 공부하련다.&lt;/p&gt;
&lt;p&gt;노드6부터 ES6문법을 사용할 수 있다. 인터넷 익스플로러같은 낡은 브라우저에서도 사용할 수 있도록 문법을 변환해주는 babel같은 도구도 있다!!&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>노드 공부하면서 ES6문법도 같이 공부하련다.</p><p>노드6부터 ES6문법을 사용할 수 있다. 인터넷 익스플로러같은 낡은 브라우저에서도 사용할 수 있도록 문법을 변환해주는 babel같은 도구도 있다!!</p><a id="more"></a><ol><li><p>var는 이제 <code>const</code> 와 <code>let</code> 이 대체한다.</p></li><li><p>템플릿 문자열</p><ul><li>큰/작은 따옴표로 감싸는 기존 문자열과 다르게 ``(백틱)` 으로 감싼다. </li><li><strong>문자열 안에 변수를 넣을 수 있다.</strong> 이거 편하더라.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존</span></span><br><span class="line"><span class="keyword">var</span> string = num1 + <span class="string">' 더하기 '</span> + num2 + <span class="string">' 는 '</span> + result</span><br><span class="line"></span><br><span class="line"><span class="comment">// 신규</span></span><br><span class="line"><span class="keyword">const</span> string2 = <span class="string">`<span class="subst">$&#123;num1&#125;</span> 더하기 <span class="subst">$&#123;num2&#125;</span>는 <span class="subst">$&#123;result&#125;</span>`</span></span><br></pre></td></tr></table></figure></li><li><p>Arrow function</p><ul><li>this binding 방식이 약간 달라짐. Arrow function 내의 this는 상위 스코프의 this를 그대로 물려받는다.</li></ul></li><li><p>Object destructuring</p></li><li><p>클래스</p><ul><li>기존 prototype 기반 문법을 예뻐보이게 클래스로 바꾼것.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존</span></span><br><span class="line"><span class="keyword">var</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type || <span class="string">'human'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Human.isHuman = <span class="function"><span class="keyword">function</span>(<span class="params">human</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> human <span class="keyword">instanceof</span> Human;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Human.prototype.breathe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'h-a-a-a-m'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Zero = <span class="function"><span class="keyword">function</span>(<span class="params">type, firstName, lastName</span>) </span>&#123;</span><br><span class="line">  Human.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Zero.prototype = <span class="built_in">Object</span>.create(Human.prototype);</span><br><span class="line">Zero.prototype.constructor = Zero; <span class="comment">// 상속하는 부분</span></span><br><span class="line">Zero.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> oldZero = <span class="keyword">new</span> Zero(<span class="string">'human'</span>, <span class="string">'Zero'</span>, <span class="string">'Cho'</span>);</span><br><span class="line">Human.isHuman(oldZero); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 신규</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type = 'human') &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 클래스 함수의 키워드 static으로 바뀜</span></span><br><span class="line">  <span class="keyword">static</span> isHuman(human) &#123;</span><br><span class="line">    <span class="keyword">return</span> human <span class="keyword">instanceof</span> Human;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  breathe() &#123;</span><br><span class="line">    alert(<span class="string">'h-a-a-a-m'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zero</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type, firstName, lastName) &#123;</span><br><span class="line">    <span class="keyword">super</span>(type);</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="keyword">super</span>.breathe();</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newZero = <span class="keyword">new</span> Zero(<span class="string">'human'</span>, <span class="string">'Zero'</span>, <span class="string">'Cho'</span>);</span><br><span class="line">Human.isHuman(newZero); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Promise 패턴</p><ul><li>자바스크립트와 노드의 API들이 콜백 대신 Promise를 사용한다!</li><li>콜백 지옥을 해결</li><li>Promise는 객체다. 생성된 promise객체는 성공했을때 <code>resolve(result)</code> 로, 실패했을때 <code>reject(error)</code> 로 결과를 전달한다.</li><li>전달된 결과는 <code>then</code> 과 <code>catch</code> 로 받는다.<img src="/image/ES2015.png" alt="_ECMAScript__ES2015_ES6__Promise_-_ZeroCho_Blog"></li><li><a href="https://www.zerocho.com/category/ECMAScript/post/5770c27e6a8e09150013f0f7" rel="external nofollow noopener noreferrer" target="_blank">Promise의 이해</a></li><li>이때 문제는 Promise.then().catch().then().catch() 뭐 이런식으로 구성했을때 에러가 나면 <code>에러가 난 위치보다 뒤에 붙여놓은 모든 catch들에서도 에러가 발생</code> 한다.</li><li><strong><code>Promise.all</code></strong> 을 사용하면 여러 프로미스 객체들을 한번에 모아서 처리할 수 있다. 모드 프로미스가 성공하면 then, 하나라도 실패하면 catch로 연결된다.’</li><li><strong><code>Promise.race</code></strong> 는 여러 프로미스 객채 중 가장 빨리 성공하거나 실패한 애를 보여준다.</li></ul></li><li><p>async/await</p><ul><li>노드 7.6버전부터 지원되는 기능. 아하.. async/await이 promise보다 상위문법이었구낭!</li><li><strong>비동기 코드를 동기식으로 표현해서 간단하게 만든다.</strong></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/08/19/js-study1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>노드 시작하기</title>
      <link>https://katie0809.github.io/2020/08/19/node-study1/</link>
      <guid>https://katie0809.github.io/2020/08/19/node-study1/</guid>
      <pubDate>Wed, 19 Aug 2020 11:02:29 GMT</pubDate>
      <description>
      
        &lt;p&gt;노드 서버를 만들 일이 생겼습니다. 700페이지짜리 두껍고 무서운 책을 한권 샀습니다. 이름도 무려 Node.js 교과서. &lt;/p&gt;
&lt;p&gt;그래도 뷰 공부할때보다는 확실히 덜 막막하고, 서버는 처음 개발해보는거라 약간 설레는 마음이 있습니다.&lt;/p&gt;
&lt;p&gt;구입한 책은 &lt;a href=&quot;http://www.yes24.com/Product/Goods/62597864&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Node.js 교과서 - 길벗출판사&lt;/a&gt; .&lt;/p&gt;
&lt;h1 id=&quot;노드란&quot;&gt;&lt;a href=&quot;#노드란&quot; class=&quot;headerlink&quot; title=&quot;노드란?&quot;&gt;&lt;/a&gt;노드란?&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Node.js는 Chrome V8 Javascript엔진으로 빌드된 &lt;code&gt;Javascript 런타임&lt;/code&gt;이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;서버로서의-노드&quot;&gt;&lt;a href=&quot;#서버로서의-노드&quot; class=&quot;headerlink&quot; title=&quot;서버로서의 노드&quot;&gt;&lt;/a&gt;서버로서의 노드&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;노드의 가장 큰 특징 : 1) 싱글스레드 2) 논-블로킹 모델&lt;/li&gt;
&lt;li&gt;노드를 서버로 사용할때의 장단점&lt;ul&gt;
&lt;li&gt;노드는 IO 처리를 잘한다(논블로킹 방식으로 처리).&lt;/li&gt;
&lt;li&gt;하지만 노드는 &lt;strong&gt;CPU부하가 큰 작업에는 적합하지 않다.&lt;/strong&gt; &amp;gt;&amp;gt; 작성한 코드 전체가 &lt;code&gt;스레드 하나에서 처리&lt;/code&gt;되기 때문&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;따라서 노드는 &lt;code&gt;개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데에&lt;/code&gt; 적합하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;+) 노드에서 멀티스레드 사용이 불가능한건 아닌듯. 노드12에서 안정화된 워커스레드 기능으로 멀티스레딩 작업 가능하다고 한다.&lt;/p&gt;
&lt;p&gt;+) 당연히 그래도 그냥 C++, Ruby, Go에 비해선 느리다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>노드 서버를 만들 일이 생겼습니다. 700페이지짜리 두껍고 무서운 책을 한권 샀습니다. 이름도 무려 Node.js 교과서. </p><p>그래도 뷰 공부할때보다는 확실히 덜 막막하고, 서버는 처음 개발해보는거라 약간 설레는 마음이 있습니다.</p><p>구입한 책은 <a href="http://www.yes24.com/Product/Goods/62597864" rel="external nofollow noopener noreferrer" target="_blank">Node.js 교과서 - 길벗출판사</a> .</p><h1 id="노드란"><a href="#노드란" class="headerlink" title="노드란?"></a>노드란?</h1><blockquote><p>Node.js는 Chrome V8 Javascript엔진으로 빌드된 <code>Javascript 런타임</code>이다.</p></blockquote><h1 id="서버로서의-노드"><a href="#서버로서의-노드" class="headerlink" title="서버로서의 노드"></a>서버로서의 노드</h1><ul><li>노드의 가장 큰 특징 : 1) 싱글스레드 2) 논-블로킹 모델</li><li>노드를 서버로 사용할때의 장단점<ul><li>노드는 IO 처리를 잘한다(논블로킹 방식으로 처리).</li><li>하지만 노드는 <strong>CPU부하가 큰 작업에는 적합하지 않다.</strong> &gt;&gt; 작성한 코드 전체가 <code>스레드 하나에서 처리</code>되기 때문</li></ul></li></ul><blockquote><p>따라서 노드는 <code>개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데에</code> 적합하다.</p></blockquote><p>+) 노드에서 멀티스레드 사용이 불가능한건 아닌듯. 노드12에서 안정화된 워커스레드 기능으로 멀티스레딩 작업 가능하다고 한다.</p><p>+) 당연히 그래도 그냥 C++, Ruby, Go에 비해선 느리다.</p><a id="more"></a><ul><li>노드에는 웹서버가 내장되어 있다. 따라서 nginx, Apache와 같은 별도 웹서버를 설치할 필요가 없이 그냥 내장 웹서버 사용할 수 있다.</li><li>물론 나중에 서버 규모가 커지면 nginx같은 <em>별도 웹서버를 노드 서버와 연결</em>해야 한다.</li></ul><h1 id="REPL"><a href="#REPL" class="headerlink" title="REPL"></a>REPL</h1><ul><li>입력한 코드를 읽고, 해석하고, 결과를 반환하고, 종료할때까지 반복한다고 해서 REPL(Read Eval Print Loop) 라고 부른다.</li><li>node의 REPL도 간단하게 터미널에 node 쳐서 실행해볼 수 있다.</li><li>종료하려면 ctrl+c 두번, 혹은 .exit 입력하면 된다.</li></ul><h1 id="모듈화"><a href="#모듈화" class="headerlink" title="모듈화"></a>모듈화</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var.js</span></span><br><span class="line"><span class="keyword">const</span> odd = <span class="string">'odd num'</span>;</span><br><span class="line"><span class="keyword">const</span> even = <span class="string">'even num'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">odd, even</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>module.exports로 파일의 객체들을 모듈화 후 export함으로써, var.js 파일은 모듈로서 기능한다.</p></li><li><p><code>require</code> 함수로 불러온다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; odd, even &#125; = <span class="built_in">require</span>(<span class="string">'./var'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chkNum</span>(<span class="params">n</span>) =&gt; </span>&#123; <span class="keyword">return</span> n % <span class="number">2</span> ? odd : even &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = chkNum;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; odd, even &#125; = <span class="built_in">require</span>(<span class="string">'./var'</span>);</span><br><span class="line"><span class="keyword">const</span> chkNum = <span class="built_in">require</span>(<span class="string">'./func'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chkStrNum</span>(<span class="params">s</span>) =&gt; </span>&#123; <span class="keyword">return</span> s.length % <span class="number">2</span> ? odd : even &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(chkNum(<span class="number">10</span>)); <span class="comment">// even num 출력</span></span><br><span class="line"><span class="built_in">console</span>.log(chkStrNum(<span class="string">'hello'</span>)); <span class="comment">// odd num 출력</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="노드-내장객체"><a href="#노드-내장객체" class="headerlink" title="노드 내장객체"></a>노드 내장객체</h1><blockquote><p>노드는 내장객체로 window와 document가 없다!</p></blockquote><ol><li>global</li><li>console</li><li>타이머</li><li>module, exports, require</li><li>process</li></ol><h1 id="노드-내장모듈"><a href="#노드-내장모듈" class="headerlink" title="노드 내장모듈"></a>노드 내장모듈</h1><ol><li>os : 운영체제 정보를 가져온다</li><li>path : 폴더와 파일 경로를 조작한다</li><li><code>url</code> : 인터넷 주소를 조작한다</li><li><code>querystring</code> : url의 쿼리부분을 사용하기 쉽게 객체로 만드는 모듈</li><li><code>crypto</code> : 다양한 방식의 암호화를 도와주는 모듈</li><li><code>util</code> : 다양한 편의 기능을 모아둔 모듈</li><li><code>fs</code> : 파일시스템에 접근하는 모듈</li></ol>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/08/19/node-study1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Tensorflow 개발자 자격증 준비하기(6)</title>
      <link>https://katie0809.github.io/2020/07/25/tf-study6/</link>
      <guid>https://katie0809.github.io/2020/07/25/tf-study6/</guid>
      <pubDate>Sat, 25 Jul 2020 07:14:25 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Image-Classification-Tensorflow-dataset&quot;&gt;&lt;a href=&quot;#Image-Classification-Tensorflow-dataset&quot; class=&quot;headerlink&quot; title=&quot;Image Classification : Tensorflow dataset&quot;&gt;&lt;/a&gt;Image Classification : Tensorflow dataset&lt;/h2&gt;&lt;p&gt;3번 유형의 문제를 몇개 더 찾아보았다. 개/고양이 사진을 분류하는 문제를 풀어보았다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Image-Classification-Tensorflow-dataset"><a href="#Image-Classification-Tensorflow-dataset" class="headerlink" title="Image Classification : Tensorflow dataset"></a>Image Classification : Tensorflow dataset</h2><p>3번 유형의 문제를 몇개 더 찾아보았다. 개/고양이 사진을 분류하는 문제를 풀어보았다.</p><a id="more"></a><h2 id="1-문제"><a href="#1-문제" class="headerlink" title="1. 문제"></a>1. 문제</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># using the Cats v Dogs dataset from TFDS.</span></span><br><span class="line"><span class="comment"># The testing infrastructre will resize all images to 224x224 </span></span><br><span class="line"><span class="comment"># with 3 bytes of color depth. Make sure your input layer trains</span></span><br><span class="line"><span class="comment"># images to that specification, or the tests will fail.</span></span><br><span class="line"><span class="keyword">import</span> tensorflow_datasets <span class="keyword">as</span> tfds</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset_name = <span class="string">'cats_vs_dogs'</span></span><br><span class="line">dataset, info = tfds.load(name=dataset_name, split=tfds.Split.TRAIN, with_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span><span class="params">(features)</span>:</span></span><br><span class="line">    <span class="comment"># YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution_model</span><span class="params">()</span>:</span></span><br><span class="line">    train_dataset = dataset.map(preprocess).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    model = <span class="comment"># YOUR CODE HERE, BUT MAKE SURE YOUR LAST LAYER HAS 2 NEURONS ACTIVATED BY SOFTMAX</span></span><br><span class="line">        tf.keras.layers.Dense(<span class="number">2</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    model = solution_model()</span><br><span class="line">    model.save(<span class="string">"mymodel.h5"</span>)</span><br></pre></td></tr></table></figure><ul><li>tensorflow dataset 클래스의 개/고양이 컬러사진 데이터를 모델 학습에 사용한다.</li><li>최종 레이어는 softmax로 2개 종류로 분류하는 Dense layer<ul><li>label값은 0 or 1인 1차원 텐서다</li><li>label을 one hot encoding 하면 categorical cross entropy, 안하면 sparse categorical crossentropy를 사용하자.</li></ul></li></ul><h2 id="2-데이터-전처리"><a href="#2-데이터-전처리" class="headerlink" title="2. 데이터 전처리"></a>2. 데이터 전처리</h2><p>아.. 일단 데이터 다운로드 받는 것 부터가 난관이었다ㅋㅋ 오랜 고군분투 끝에 알아낸 방법은 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">test_dataset, train_dataset = tfds.load(name=<span class="string">'cats_vs_dogs'</span></span><br><span class="line">                                        , split=(<span class="string">'train[:35%]'</span>, <span class="string">'train[20%:]'</span>)</span><br><span class="line">                                        , as_supervised=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li><code>with_info</code> 옵션을 주면 <u>데이터셋의 정보를 같이 반환</u>한다. </li><li><code>split</code> 옵션설정을 통해 데이터를 앞에서부터 30%, 나머지 80%로 분할해서 반환하도록 했다.</li><li><code>as_supervised</code> 옵션을 <strong>True</strong>로 주면 데이터가 <u>튜플로 반환</u>된다. <strong>False</strong>일 경우 <u>dictionary 형태로 반환</u>된다. =&gt; default 값은 False.</li></ul><p>받아온 데이터를 전처리한다. 별건 없고 일단은 그냥 (1)이미지 값을 0-1 사이로 조정하고, (2)이미지 사이즈를 (224, 224)로 줄인다.</p><p>간단한 전처리 함수는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span><span class="params">(img, lbl)</span>:</span></span><br><span class="line">    _img = tf.cast(img, tf.float32)</span><br><span class="line">    _img = tf.divide(_img, <span class="number">255</span>)</span><br><span class="line">    _img = tf.image.resize(_img, (<span class="number">224</span>, <span class="number">224</span>))  <span class="comment"># 이미지 사이즈를 얜 224, 아래는 244로 해둬서 한참해멤...ㅋㅋ</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _img, lbl</span><br></pre></td></tr></table></figure><p>이제 전처리된 데이터셋으로 배치를 생성한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_databatch = train_dataset.map(preprocess).batch(BATCH_SZ).repeat()</span><br><span class="line">    test_databatch = test_dataset.map(preprocess).batch(BATCH_SZ).repeat()</span><br></pre></td></tr></table></figure><ol><li><code>map()</code> : 데이터셋의 모든 원소에 preprocess 함수로 지정한 변환을 한다</li><li><code>batch(BATCH_SZ)</code> : BATCH_SZ개씩 원소를 가져와서 데이터셋에 저장한다.<br>데이터셋 원소 개수는 데이터셋원소개수/BATCH_SZ(나머지있으면 +1)이다.</li><li><code>repeat()</code> : 이걸 넣어줘야 반복적으로 데이터셋의 모든 데이터에 대해 배치가 생긴다.</li></ol><h2 id="3-모델-구성"><a href="#3-모델-구성" class="headerlink" title="3. 모델 구성"></a>3. 모델 구성</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">model = Sequential([</span><br><span class="line">  Conv2D(<span class="number">16</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>)),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Conv2D(<span class="number">16</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">  MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">  Flatten(), </span><br><span class="line">  Dropout(<span class="number">0.5</span>),</span><br><span class="line">  Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">  Dense(<span class="number">2</span>, activation=<span class="string">'softmax'</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>, loss=<span class="string">'sparse_categorical_crossentropy'</span>, metrics=[<span class="string">'acc'</span>])</span><br></pre></td></tr></table></figure><h2 id="4-모델-학습"><a href="#4-모델-학습" class="headerlink" title="4. 모델 학습"></a>4. 모델 학습</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">checkpointPath = <span class="string">'catDogBest.ckpt'</span></span><br><span class="line">mc = ModelCheckpoint(checkpointPath,</span><br><span class="line">      monitor = <span class="string">'val_loss'</span>, </span><br><span class="line">      verbose = <span class="number">1</span>, </span><br><span class="line">      save_weights_only=<span class="literal">True</span>,</span><br><span class="line">      save_best_only = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model.fit(</span><br><span class="line">      train_databatch, </span><br><span class="line">      steps_per_epoch=(train_len/BATCH_SZ),</span><br><span class="line">      epochs=<span class="number">50</span>,</span><br><span class="line">      validation_data=(test_databatch),</span><br><span class="line">      validation_steps=(test_len/BATCH_SZ),</span><br><span class="line">      callbacks=[mc])</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Epoch 00028: val_loss improved from 0.16154 to 0.14961, saving model to catDogBest.ckpt</span><br><span class="line">582/581 [==============================] - 25s 43ms/step - loss: 0.1320 - acc: 0.9513 - val_loss: 0.1496 - val_acc: 0.9445</span><br></pre></td></tr></table></figure><h3 id="알게된-점"><a href="#알게된-점" class="headerlink" title="+ 알게된 점"></a>+ 알게된 점</h3><ul><li><p>train_dataset과 test_dataset의 비율을 조정하는 것 만으로도 모델의 성능을 높일 수 있다.</p></li><li><p>기존에 train_data랑 test_data를 걍 암생각없이 2 : 8로 나눴는데, 이를 3.5 : 8로 비율 조정한 것 만으로 모델 성능이 확 올라갔다.</p></li></ul><p>​    </p>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/07/25/tf-study6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Tensorflow 개발자 자격증 준비하기(5)</title>
      <link>https://katie0809.github.io/2020/06/30/tf-study5/</link>
      <guid>https://katie0809.github.io/2020/06/30/tf-study5/</guid>
      <pubDate>Tue, 30 Jun 2020 11:33:30 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Time-Series-Analysis&quot;&gt;&lt;a href=&quot;#Time-Series-Analysis&quot; class=&quot;headerlink&quot; title=&quot;Time Series Analysis&quot;&gt;&lt;/a&gt;Time Series Analysis&lt;/h2&gt;&lt;p&gt;시계열 데이터의 처리.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Time-Series-Analysis"><a href="#Time-Series-Analysis" class="headerlink" title="Time Series Analysis"></a>Time Series Analysis</h2><p>시계열 데이터의 처리.</p><a id="more"></a><h2 id="1-문제"><a href="#1-문제" class="headerlink" title="1. 문제"></a>1. 문제</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="comment"># DO NOT CHANGE THIS CODE</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">windowed_dataset</span><span class="params">(series, window_size, batch_size, shuffle_buffer)</span>:</span></span><br><span class="line">    series = tf.expand_dims(series, axis=<span class="number">-1</span>)</span><br><span class="line">    ds = tf.data.Dataset.from_tensor_slices(series)</span><br><span class="line">    ds = ds.window(window_size + <span class="number">1</span>, shift=<span class="number">1</span>, drop_remainder=<span class="literal">True</span>)</span><br><span class="line">    ds = ds.flat_map(<span class="keyword">lambda</span> w: w.batch(window_size + <span class="number">1</span>))</span><br><span class="line">    ds = ds.shuffle(shuffle_buffer)</span><br><span class="line">    ds = ds.map(<span class="keyword">lambda</span> w: (w[:<span class="number">-1</span>], w[<span class="number">1</span>:]))</span><br><span class="line">    <span class="keyword">return</span> ds.batch(batch_size).prefetch(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution_model</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">'https://storage.googleapis.com/download.tensorflow.org/data/Sunspots.csv'</span></span><br><span class="line">    urllib.request.urlretrieve(url, <span class="string">'sunspots.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your data should be loaded into 2 Python lists called time_step</span></span><br><span class="line"><span class="comment"># and sunspots. They are decleared here.</span></span><br><span class="line">    time_step = []</span><br><span class="line">    sunspots = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'sunspots.csv'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">      reader = csv.reader(csvfile, delimiter=<span class="string">','</span>)</span><br><span class="line">      next(reader)</span><br><span class="line">      <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        sunspots.append(<span class="comment"># YOUR CODE HERE)</span></span><br><span class="line">        time_step.append(<span class="comment"># YOUR CODE HERE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You should use numpy to create </span></span><br><span class="line"><span class="comment"># - your series from the list of sunspots</span></span><br><span class="line"><span class="comment"># - your time details from the list of time steps</span></span><br><span class="line">    series = <span class="comment"># YOUR CODE HERE</span></span><br><span class="line">    time = np.array(time_step)</span><br><span class="line"></span><br><span class="line"><span class="comment"># You should split the dataset into training and validation splits</span></span><br><span class="line"><span class="comment"># At time 3000. So everything up to 3000 is training, and everything</span></span><br><span class="line"><span class="comment"># after 3000 is validation. Write the code below to achieve that.</span></span><br><span class="line">    split_time = <span class="number">3000</span></span><br><span class="line">    time_train = <span class="comment"># YOUR CODE HERE</span></span><br><span class="line">    x_train = <span class="comment"># YOUR CODE HERE</span></span><br><span class="line">    time_valid = <span class="comment"># YOUR CODE HERE</span></span><br><span class="line">    x_valid = <span class="comment"># YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># DO NOT CHANGE THIS CODE</span></span><br><span class="line">    window_size = <span class="number">30</span></span><br><span class="line">    batch_size = <span class="number">32</span></span><br><span class="line">    shuffle_buffer_size = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tf.keras.backend.clear_session()</span><br><span class="line">    <span class="comment"># You can use any random seed you want. We use 51. :)</span></span><br><span class="line">    tf.random.set_seed(<span class="number">51</span>)</span><br><span class="line">    np.random.seed(<span class="number">51</span>)</span><br><span class="line">    train_set = windowed_dataset(x_train, window_size=window_size, batch_size=batch_size, shuffle_buffer=shuffle_buffer_size)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">      <span class="comment"># YOUR CODE HERE. DO NOT CHANGE THE FINAL TWO LAYERS FROM BELOW</span></span><br><span class="line">      tf.keras.layers.Dense(<span class="number">1</span>),</span><br><span class="line">      <span class="comment"># The data is not normalized, so this lambda layer helps</span></span><br><span class="line">      <span class="comment"># keep the MAE in line with expectations. Do not modify.</span></span><br><span class="line">      tf.keras.layers.Lambda(<span class="keyword">lambda</span> x: x * <span class="number">400</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># YOUR CODE HERE TO COMPILE AND TRAIN THE MODEL</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that you'll need to save your model as a .h5 like this</span></span><br><span class="line"><span class="comment"># This .h5 will be uploaded to the testing infrastructure</span></span><br><span class="line"><span class="comment"># and a score will be returned to you</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    model = solution_model()</span><br><span class="line">    model.save(<span class="string">"mymodel.h5"</span>)</span><br></pre></td></tr></table></figure><ul><li>주어진 csv파일을 가공하여 태양 흑점의 위치를 추적하는 모델을 생성한다.</li><li>Mean Absolute Error의 값이 최대 20 이하여야 한다.</li></ul><h2 id="2-데이터-가공"><a href="#2-데이터-가공" class="headerlink" title="2. 데이터 가공"></a>2. 데이터 가공</h2><h3 id="csv데이터-가공"><a href="#csv데이터-가공" class="headerlink" title="[ csv데이터 가공 ]"></a>[ csv데이터 가공 ]</h3><p>이전과는 다르게 csv데이터를 사용하는 듯 하다.</p><p>csv데이터를 다운받아와 저장한 뒤 대략적인 데이터 구조를 보면 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">urllib.request.urlretrieve(<span class="string">'https://storage.googleapis.com/download.tensorflow.org/data/Sunspots.csv'</span>, <span class="string">'sunspots.csv'</span>)</span><br><span class="line">sunspots = pd.read_csv(<span class="string">'sunspots.csv'</span>, sep=<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line">print(sunspots)</span><br></pre></td></tr></table></figure><p><img src="/image/TF_5-sunspots-question_-_Colaboratory.png" alt="TF_5-sunspots-question_-_Colaboratory"></p><p>sunspots.csv 데이터의 열은 아래와 같이 3개이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index([&#39;Unnamed: 0&#39;, &#39;Date&#39;, &#39;Monthly Mean Total Sunspot Number&#39;], dtype&#x3D;&#39;object&#39;)</span><br></pre></td></tr></table></figure><p>이중에 날짜 데이터와 월별 흑점개수 평균값 데이터를 주어진 <em>time_step, sunspots 배열</em>에 넣는다. 생성한 배열은 <strong>numpy배열로 변환</strong>한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dataframe = _sunspots[[<span class="string">'Date'</span>, <span class="string">'Monthly Mean Total Sunspot Number'</span>]]</span><br><span class="line"></span><br><span class="line">time_step = []</span><br><span class="line">sunspots = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, sunspot <span class="keyword">in</span> dataframe.iterrows():</span><br><span class="line">  time_step.append(sunspot[<span class="number">0</span>])</span><br><span class="line">  sunspots.append(sunspot[<span class="number">1</span>])</span><br><span class="line">  </span><br><span class="line">series = np.array(sunspots)</span><br><span class="line">time = np.array(time_step)</span><br></pre></td></tr></table></figure><p>학습을 위해 데이터셋을 분리한다. 문제의 조건은 아래와 같다.</p><blockquote><p>You should split the dataset into training and validation splits at time 3000. So <strong>everything up to 3000 is training</strong>, and everything <strong>after 3000 is validation</strong>. Write the code below to achieve that.</p></blockquote><p>따라서 아래와 같이 데이터셋을 분리한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">split_time = <span class="number">3000</span></span><br><span class="line">time_train = time[:split_time]</span><br><span class="line">x_train = series[:split_time]</span><br><span class="line">time_valid = time[split_time:]</span><br><span class="line">x_valid = series[split_time:]</span><br></pre></td></tr></table></figure><h3 id="Window-Sequence-Loader"><a href="#Window-Sequence-Loader" class="headerlink" title="[ Window Sequence Loader ]"></a>[ Window Sequence Loader ]</h3>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/06/30/tf-study5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Tensorflow 개발자 자격증 준비하기(4)</title>
      <link>https://katie0809.github.io/2020/06/22/tf-study4/</link>
      <guid>https://katie0809.github.io/2020/06/22/tf-study4/</guid>
      <pubDate>Mon, 22 Jun 2020 11:41:43 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Natural-Language-Processing&quot;&gt;&lt;a href=&quot;#Natural-Language-Processing&quot; class=&quot;headerlink&quot; title=&quot;Natural Language Processing&quot;&gt;&lt;/a&gt;Natural Language Processing&lt;/h2&gt;&lt;p&gt;문자열 데이터를 받아 sarcastic한지 판별하는 문제를 풀어보자. 이전과는 다르게 자연어 처리 문제이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Natural-Language-Processing"><a href="#Natural-Language-Processing" class="headerlink" title="Natural Language Processing"></a>Natural Language Processing</h2><p>문자열 데이터를 받아 sarcastic한지 판별하는 문제를 풀어보자. 이전과는 다르게 자연어 처리 문제이다.</p><a id="more"></a><h2 id="1-문제"><a href="#1-문제" class="headerlink" title="1. 문제"></a>1. 문제</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.text <span class="keyword">import</span> Tokenizer</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.sequence <span class="keyword">import</span> pad_sequences</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution_model</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">'https://storage.googleapis.com/download.tensorflow.org/data/sarcasm.json'</span></span><br><span class="line">    urllib.request.urlretrieve(url, <span class="string">'sarcasm.json'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DO NOT CHANGE THIS CODE OR THE TESTS MAY NOT WORK</span></span><br><span class="line">    vocab_size = <span class="number">1000</span></span><br><span class="line">    embedding_dim = <span class="number">16</span></span><br><span class="line">    max_length = <span class="number">120</span></span><br><span class="line">    trunc_type=<span class="string">'post'</span></span><br><span class="line">    padding_type=<span class="string">'post'</span></span><br><span class="line">    oov_tok = <span class="string">"&lt;OOV&gt;"</span></span><br><span class="line">    training_size = <span class="number">20000</span></span><br><span class="line"></span><br><span class="line">    sentences = []</span><br><span class="line">    labels = []</span><br><span class="line">    <span class="comment"># YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    model = tf.keras.Sequential([</span><br><span class="line">    <span class="comment"># YOUR CODE HERE. KEEP THIS OUTPUT LAYER INTACT OR TESTS MAY FAIL</span></span><br><span class="line">        tf.keras.layers.Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>)</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that you'll need to save your model as a .h5 like this</span></span><br><span class="line"><span class="comment"># This .h5 will be uploaded to the testing infrastructure</span></span><br><span class="line"><span class="comment"># and a score will be returned to you</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    model = solution_model()</span><br><span class="line">    model.save(<span class="string">"mymodel.h5"</span>)</span><br></pre></td></tr></table></figure><h2 id="2-데이터-가공"><a href="#2-데이터-가공" class="headerlink" title="2. 데이터 가공"></a>2. 데이터 가공</h2><p>: sarcasm 학습데이터는 json 포맷이다. 받아온 sarcasm.json 파일을 로드해와 sentences와 labels로 나눈다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># sarcasm 데이터 다운로드</span></span><br><span class="line">urllib.request.urlretrieve(<span class="string">'https://storage.googleapis.com/download.tensorflow.org/data/sarcasm.json'</span>, <span class="string">'sarcasm.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'sarcasm.json'</span>) <span class="keyword">as</span> file:</span><br><span class="line">data = json.load(file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터를 sentence와 label로 나눈다.</span></span><br><span class="line">dataset = []</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> data:</span><br><span class="line">sentences.append(elem[<span class="string">'headline'</span>])</span><br><span class="line">labels.append(elem[<span class="string">'is_sarcastic'</span>])</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 훈련 데이터와 테스트 데이터로 분류</span></span><br><span class="line">training_size = int(len(data)*<span class="number">0.2</span>)</span><br><span class="line">train_sentences = sentences[:training_size]</span><br><span class="line">train_labels = labels[:training_size]</span><br><span class="line">validation_sentences = sentences[training_size:]</span><br><span class="line">validation_labels = labels[training_size:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터셋은 numpy array이어야 한다.</span></span><br><span class="line">train_labels = np.array(train_labels)</span><br><span class="line">validation_labels = np.array(validation_labels)</span><br></pre></td></tr></table></figure><p>sarcasm 데이터셋은 자연어처리를 실습하기 위한 예제이다. 따라서 이전 포스트의 자연어 처리와 관련된 이론내용들을 실제로 적용해볼 수 있다.</p><blockquote><p><a href="https://katie0809.github.io/2020/02/17/ai-study4/">자연어 처리의 전처리</a></p><p><a href="https://katie0809.github.io/2020/02/17/ai-study5/#more">자연어 처리의 실습</a></p></blockquote><p>자연어 처리의 전처리 단계는 다음과 같다. </p><blockquote><p>자연어 처리의 전처리 단계 : <code>토큰화</code>, <code>단어집합 생성</code>, <code>정수인코딩</code>, <code>패딩</code></p></blockquote><p>아 맨날 까먹는다. 붕어인가ㅠ</p><h3 id="토큰화"><a href="#토큰화" class="headerlink" title="[ 토큰화 ]"></a>[ 토큰화 ]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.text <span class="keyword">import</span> Tokenizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 변경 불가</span></span><br><span class="line">vocab_size = <span class="number">1000</span></span><br><span class="line">oov_tok = <span class="string">"&lt;OOV&gt;"</span></span><br><span class="line">max_length = <span class="number">120</span></span><br><span class="line">trunc_type=<span class="string">'post'</span></span><br><span class="line">padding_type=<span class="string">'post'</span></span><br><span class="line">embedding_dim = <span class="number">16</span></span><br></pre></td></tr></table></figure><ol><li><p>Tokenizer를 정의한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokenizer = Tokenizer(num_words=vocab_size, oov_token=<span class="string">'&lt;OOV&gt;'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>num_words</code>: <strong>단어 집합 max 사이즈</strong>를 지정합니다. <u>가장 빈도수가 높은 단어부터 저장</u>합니다.</li><li><code>oov_token</code>: <strong>단어 집합에 없는 단어</strong>를 어떻게 표기할 것인지 지정해줍니다.</li></ul></li><li><p>학습시킬 대상 문장을 토큰화하고(단어 단위로 분리하고), 단어집합을 만든다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tokenizer.fit_on_texts(sentences)</span><br><span class="line">word_to_idx = tokenizer.word_index</span><br></pre></td></tr></table></figure></li><li><p>학습 대상 문장을 각각의 고유한 정수로 매핑한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_sequences &#x3D; tokenizer.texts_to_sequences(train_sentences)</span><br><span class="line">validation_sequences &#x3D; tokenizer.texts_to_sequences(validation_sentences)</span><br></pre></td></tr></table></figure></li></ol><h3 id="패딩"><a href="#패딩" class="headerlink" title="[ 패딩 ]"></a>[ 패딩 ]</h3><p>: <code>pad_sequences</code> 함수를 사용한다. 옵션값은 아래와 같다.</p><ul><li><code>maxlen</code>: <strong>최대 문장 길이</strong>를 정의합니다. <u>최대 문장길이보다 길면, 잘라냅</u>니다.</li><li><code>truncating</code>: 문장의 길이가 <code>maxlen</code>보다 <u>길 때</u> <strong>앞을 자를지 뒤를 자를지</strong> 정의합니다.</li><li><code>padding</code>: 문장의 길이가 <code>maxlen</code>보다 <u>짧을 때</u> 채워줄 값을 <strong>앞을 채울지, 뒤를 채울지</strong> 정의합니다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_padded = pad_sequences(train_sequences, truncating=trunc_type, padding=padding_type, maxlen=max_length)</span><br><span class="line">validation_padded = pad_sequences(validation_sequences, padding=padding_type, maxlen=max_length)</span><br></pre></td></tr></table></figure><h2 id="3-모델-설계"><a href="#3-모델-설계" class="headerlink" title="3. 모델 설계"></a>3. 모델 설계</h2><p>: Bidirectional LSTM 사용한 모델을 설계한다. 원래 강의노트 모델이 좀 과적합되는 것 같아서 중간에 dropout하나 추가해줌.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">model = tf.keras.Sequential([</span><br><span class="line">    tf.keras.layers.Embedding(vocab_size, embedding_dim, input_length=max_length),</span><br><span class="line">    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(<span class="number">32</span>)),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">24</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    tf.keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'adam'</span>, loss=<span class="string">'binary_crossentropy'</span>, metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">625/625 [==============================] - ETA: 0s - loss: 0.3208 - accuracy: 0.8569</span><br><span class="line">Epoch 00020: val_loss improved from 0.35426 to 0.35268, saving model to my_checkpoint3.ckpt</span><br><span class="line">625/625 [==============================] - 565s 904ms/step - loss: 0.3208 - accuracy: 0.8569 - val_loss: 0.3527 - val_accuracy: 0.8393</span><br><span class="line">Epoch 21/30</span><br></pre></td></tr></table></figure><p>통과하는 baseline은 정확도 83퍼 중반, loss 0.36이하였다. 임베딩 차원이 너무 작아서 그런지 정확도가 잘 안오른다..ㅠㅠ</p><h2 id="4-word2vec-적용"><a href="#4-word2vec-적용" class="headerlink" title="4. word2vec 적용"></a>4. word2vec 적용</h2><p>: 이전에 배웠던 word2vec 전처리를 추가해봤다. TED 강의 중 하나의 스크립트로 16차원의 임베딩 테이블을 학습한다. </p><p><a href="https://wikidocs.net/50739" rel="external nofollow noopener noreferrer" target="_blank">영어/한국어 Word2Vec 실습</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> word_tokenize, sent_tokenize</span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> Word2Vec</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"></span><br><span class="line">nltk.download(<span class="string">'punkt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 다운로드</span></span><br><span class="line">urllib.request.urlretrieve(<span class="string">"https://wit3.fbk.eu/get.php?path=XML_releases/xml/ted_en-20160408.zip&amp;filename=ted_en-20160408.zip"</span>, filename=<span class="string">"ted_en-20160408.zip"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># xml 파일로부터 &lt;content&gt;와 &lt;/content&gt; 사이의 내용만 가져온다.</span></span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">'ted_en-20160408.zip'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> z:</span><br><span class="line">  target_text = etree.parse(z.open(<span class="string">'ted_en-20160408.xml'</span>, <span class="string">'r'</span>))</span><br><span class="line">  parse_text = <span class="string">'\n'</span>.join(target_text.xpath(<span class="string">'//content/text()'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 정규 표현식의 sub 모듈을 통해 content 중간에 등장하는 (Audio), (Laughter) 등의 배경음 부분을 제거.</span></span><br><span class="line"><span class="comment"># 해당 코드는 괄호로 구성된 내용을 제거.</span></span><br><span class="line">content_text = re.sub(<span class="string">r'\([^)]*\)'</span>, <span class="string">''</span>, parse_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 입력 코퍼스에 대해서 NLTK를 이용하여 문장 토큰화를 수행.</span></span><br><span class="line">sent_text=sent_tokenize(content_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 각 문장에 대해서 구두점을 제거하고, 대문자를 소문자로 변환.</span></span><br><span class="line">normalized_text = []</span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> sent_text:</span><br><span class="line">     tokens = re.sub(<span class="string">r"[^a-z0-9]+"</span>, <span class="string">" "</span>, string.lower())</span><br><span class="line">     normalized_text.append(tokens)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 각 문장에 대해서 NLTK를 이용하여 단어 토큰화를 수행.</span></span><br><span class="line">result = [word_tokenize(sentence) <span class="keyword">for</span> sentence <span class="keyword">in</span> normalized_text]</span><br><span class="line"></span><br><span class="line">model = Word2Vec(sentences=result, size=<span class="number">16</span>, window=<span class="number">5</span>, min_count=<span class="number">5</span>, workers=<span class="number">4</span>, sg=<span class="number">0</span>)</span><br><span class="line">model.wv.save_word2vec_format(<span class="string">'eng_w2v'</span>) <span class="comment"># 워드 임베딩 저장</span></span><br></pre></td></tr></table></figure><h3 id="Embedding-Matrix-생성"><a href="#Embedding-Matrix-생성" class="headerlink" title="[Embedding Matrix 생성]"></a>[Embedding Matrix 생성]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">embedding_matrix = np.zeros((vocab_size, embedding_dim))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word, i <span class="keyword">in</span> word_to_idx.items():</span><br><span class="line">    <span class="keyword">if</span> i &gt;= vocab_size:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> word2vec.vocab:</span><br><span class="line">        embedding_matrix[i] = word2vec.word_vec(word)</span><br></pre></td></tr></table></figure><p>TED 강연자료로 학습한 워드임베딩 값으로 모델 학습에 사용할 임베딩 테이블을 생성한다. 생성한 <code>데이터셋 단어집합의 각 단어</code>에 대해 해당 단어의 벡터값이 생성한 eng_w2v에 존재할 경우 임베딩테이블에 값을 넣어준다.</p><p>생성한 embedding matrix값은 모델의 Embedding layer에서 아래와 같이 설정함으로서 모델 학습에 활용할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.keras.layers.Embedding(vocab_size, embedding_dim, weights=[embedding_matrix], input_length=max_length, trainable=<span class="literal">True</span>, mask_zero=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li><code>weights</code> 에 생성한 embedding matrix를 넣어준다.</li><li><code>trainable=True</code> 로 두면 생성한 embedding matrix를 초기 임베딩 레이어 값으로 사용하되, 모델 학습에 따라서 값을 다시 학습한다. 원래대로라면 이미 만들어진 임베딩 매트릭스 값을 학습하지 <strong>않는것이</strong> 맞겠지만, 내 경우 TED로 생성한 embedding table이 당연하게도 엄청 좋지는 않아서… 그냥 모델이랑 같이 학습을 시켜주는게 더 효과가 좋았다.</li></ul><p>결과적으로 초기값만 좀 달라진 셈인데 어쨌든 효과가 아예 없지는 않았다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Epoch 8/30</span><br><span class="line">625/625 [==============================] - ETA: 0s - loss: 0.3349 - accuracy: 0.8517</span><br><span class="line">Epoch 00008: val_loss improved from 0.36791 to 0.36273, saving model to my_checkpoint2.ckpt</span><br><span class="line">625/625 [==============================] - 123s 197ms/step - loss: 0.3349 - accuracy: 0.8517 - val_loss: 0.3627 - val_accuracy: 0.8344</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/06/22/tf-study4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝 스터디] 컴퓨터 비전을 위한 딥러닝</title>
      <link>https://katie0809.github.io/2020/06/21/ai-study9/</link>
      <guid>https://katie0809.github.io/2020/06/21/ai-study9/</guid>
      <pubDate>Sun, 21 Jun 2020 07:51:12 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt; 케라스 창시자에게 배우는 딥러닝 책을 참고하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;합성곱-신경망&quot;&gt;&lt;a href=&quot;#합성곱-신경망&quot; class=&quot;headerlink&quot; title=&quot;합성곱 신경망&quot;&gt;&lt;/a&gt;합성곱 신경망&lt;/h1&gt;&lt;p&gt;: 텐서플로 자격증을 공부하면서 컨브넷에 대한 이론적 이해가 많이 부족하다고 느꼈다. 이론 베이스가 약하니 모델을 어떻게 변형해야 할지도 감이 안와서 책을 보면서 좀 차근차근 다시 이해해보려고 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p> 케라스 창시자에게 배우는 딥러닝 책을 참고하였습니다.</p></blockquote><h1 id="합성곱-신경망"><a href="#합성곱-신경망" class="headerlink" title="합성곱 신경망"></a>합성곱 신경망</h1><p>: 텐서플로 자격증을 공부하면서 컨브넷에 대한 이론적 이해가 많이 부족하다고 느꼈다. 이론 베이스가 약하니 모델을 어떻게 변형해야 할지도 감이 안와서 책을 보면서 좀 차근차근 다시 이해해보려고 한다.</p><a id="more"></a><p><a href="https://wikidocs.net/64066" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/64066</a> 의 포스트를 공부한 내용이 포함되어 있습니다.</p><h2 id="합성곱-신경망-CNN-기본개념"><a href="#합성곱-신경망-CNN-기본개념" class="headerlink" title="합성곱 신경망(CNN) 기본개념"></a>합성곱 신경망(CNN) 기본개념</h2><ul><li><p>이미지의 <code>공간적인 구조에 대한 정보</code> 를 보존하며 학습하기 위해 사용하는 신경망</p></li><li><p>이미지는 기본적으로 <code>높이, 너비, 채널로 이루어진 3차원 텐서</code>이다. </p><ul><li>컬러 이미지 내 <strong>하나의 픽셀은 세가지 색(삼원색)의 조합으로 이뤄진다</strong>. 이는 해당 픽셀이 (1, 1, 3)의 3차원 텐서임을 의미한다.</li><li>따라서 이미지가 N*N 크기인 경우 특정 컬러 이미지는 (N, N, 3)의 3차원 텐서로 표현된다고 말할 수 있다.</li></ul></li><li><p>합성곱(convolution)은 <code>이미지의 특징을 추출해내는 연산</code> 이다. </p><ul><li>이미지에 커널을 사용해 쭉 훑어내면 결과 특성맵이 나오게 된다.</li></ul><p><img src="https://wikidocs.net/images/page/64066/conv9.png" alt></p></li></ul><h2 id="합성곱-신경망의-가중치"><a href="#합성곱-신경망의-가중치" class="headerlink" title="합성곱 신경망의 가중치"></a>합성곱 신경망의 가중치</h2><p><img src="/image/1__%E1%84%92%E1%85%A1%E1%86%B8%E1%84%89%E1%85%A5%E1%86%BC%E1%84%80%E1%85%A9%E1%86%B8_%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC_Convolution_Neural_Network__-_%E1%84%83%E1%85%B5%E1%86%B8_%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B3%E1%86%AF_%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB_%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%A5_%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5_%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%86%E1%85%AE%E1%86%AB.png" alt></p><h2 id="간단한-컨브넷-예제"><a href="#간단한-컨브넷-예제" class="headerlink" title="간단한 컨브넷 예제"></a>간단한 컨브넷 예제</h2><h2 id="간단한-컨브넷-예제-1"><a href="#간단한-컨브넷-예제-1" class="headerlink" title="간단한 컨브넷 예제"></a>간단한 컨브넷 예제</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br></pre></td></tr></table></figure><p> <img src="/image/img.jpeg" alt="컨브넷 구조"></p><ul><li>컨브넷은 <code>(이미지 높이, 이미지 너비, 채널의 수) 크기의 입력텐서</code>를 사용한다.<ul><li>이때 배치차원은 포함하지 않는다.</li><li><strong>채널의 수</strong>는 Conv2D 층에 전달된 <code>첫번째 매개변수</code>에 의해 조절된다.<br>: 위 코드의 경우 32 또는 64개</li></ul></li><li>((3, 3, 64) 크기인) 마지막 층의 출력텐서를 <u>fully-connected network에 연결</u>한다 : <code>layers.Dense()</code><ul><li>이는 <strong>Dense 층을 쌓은 분류기</strong>로 1D 벡터만을 처리한다. 따라서 이전층의 출력인 3D텐서를 1D텐서로 펼쳐야 한다.<br>: <code>layers.Flatten()</code></li></ul></li></ul><blockquote><p>대부분의 컨브넷에서 특성맵의 <code>깊이</code>는 점진적으로 <strong>증가</strong>하고(32, 64, 128…), 특성맵의 <code>크기</code>는 점진적으로 <strong>감소</strong>한다(28x28, 26x26, 13x13…).</p></blockquote><h2 id="합성곱-연산"><a href="#합성곱-연산" class="headerlink" title="합성곱 연산"></a>합성곱 연산</h2><blockquote><p>Dense 층은 입력특성공간에 있는 <code>전역패턴을 학습</code>하지만, <strong>합성곱 층은 <code>지역패턴</code>을 학습한다</strong>.</p></blockquote><ul><li><p>합성곱 연산은 <code>입력 특성맵(input feature map)</code> 3D텐서에 적용된다.</p></li><li><p>이 텐서는 2개의 공간축(높이, 너비)과 하나의 깊이축(채널축)으로 구성된다.</p><ul><li>RGB 이미지는 3개의 컬러채널을 가지므로 깊이축의 차원이 3.</li><li>MNIST와 같은 흑백 이미지는 깊이축의 차원이 1.</li></ul></li><li><p>합성곱 연산은 이러한 입력 특성맵에서 작은 패치를 추출, 변환하여 <code>출력 특성맵</code> 3D텐서를 만들어낸다.</p><ul><li>출력텐서의 <strong>깊이</strong>는 <u>층의 매개변수</u>로 결정되기 때문에 상황에 따라 다르다.</li><li>즉, 여기서의 <strong>깊이축의 채널</strong>은 더이상 RGB와 같은 특정 컬러를 의미하지 않는다. 대신 일종의 <code>필터</code>를 의미한다.<br>: 필터는 <u>입력 데이터의 어떤 특성을 인코딩</u>한다.</li></ul></li></ul><h3 id="MNIST-데이터를-통한-입출력-특성맵의-이해"><a href="#MNIST-데이터를-통한-입출력-특성맵의-이해" class="headerlink" title="[ MNIST 데이터를 통한 입출력 특성맵의 이해 ]"></a>[ MNIST 데이터를 통한 입출력 특성맵의 이해 ]</h3><ul><li><p>첫번째 합성곱 층이 (28, 28, 1)의 특성맵을 입력으로 받아 (26, 26, 32)크기의 특성맵을 출력한다.</p><p>= <strong>입력에 대해 32개의 필터를 적용한다</strong></p></li><li><dl><dt>(26, 26) 크기의 32개 출력채널 각각은 <code>입력의 각 위치에서의 필터 패턴에 대한 응답</code>을 의미한다.</dt><dd><strong>응답맵</strong>이라고 칭한다.</dd></dl></li></ul><h3 id="컨브넷의-특징"><a href="#컨브넷의-특징" class="headerlink" title="[ 컨브넷의 특징 ]"></a>[ 컨브넷의 특징 ]</h3><ol><li><p><code>translation invariant</code> : 이미지의 어느 한 곳에서 특정 패턴을 학습했다면, 이미지의 다른 부분에서 같은 패턴을 인식해낼 수 있다. 이는 세상은 평행 이동에 따라 다르게 인식되지 않는다는 우리의 인식방법과 동일하다. </p><p>반면, 완전 연결 네트워크는 새로운 위치에 나타난 것은 새로운 특성으로 인식한다.</p></li><li><p><code>공간적 계층구조 학습</code> : 합성곱 연산의 기본적인 프로세스는 다음과 같다.<br>[ 첫번째 합성곱 층 ] : 모서리와 같은 작은 지역 패턴을 학습.<br>[ 두번째 합성곱 층 ] : 첫번째 층의 특성으로 구성된 더 큰 패턴을 학습.</p><p>이러한 방식을 통해 더 복잡하고 추상적인 시각적 개념을 효과적으로 학습 가능하다.</p></li></ol><h3 id="합성곱의-핵심-parameter"><a href="#합성곱의-핵심-parameter" class="headerlink" title="[ 합성곱의 핵심 parameter ]"></a>[ 합성곱의 핵심 parameter ]</h3><p><img src="/image/img2.jpeg" alt="이미지 2"></p><ol><li><strong>입력으로부터 뽑아낼 패치크기</strong> : 3x3, 5x5 크기를 주로 사용한다.</li><li><strong>특성맵의 출력 깊이</strong> : 합성곱으로 <u>계산할 필터의 수</u>이다. 위의 예시에서는 32로 시작해서 64로 끝남.</li></ol><h2 id="패딩과-스트라이드"><a href="#패딩과-스트라이드" class="headerlink" title="패딩과 스트라이드"></a>패딩과 스트라이드</h2><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p><img src="/image/img3.jpeg" alt="이미지 3"></p><p>: 입력 특성맵의 가장자리에 적절한 개수의 행과 열을 추가하여 입력 특성맵과 출력특성맵의 크기가 같도록 한다.</p><p>케라스의 Conv2D층에서 패딩은 padding 변수로 설정 가능하다.</p><ul><li><code>valid</code> : 패딩을 사용하지 않음</li><li><code>same</code> : 패딩을 사용함. 출력 특성맵의 높이, 너비가 입력 특성맵과 같아진다.</li></ul><h3 id="Stride"><a href="#Stride" class="headerlink" title="Stride"></a>Stride</h3><p>: 입력 특성맵 위를 지나가는 윈도우 간의 거리(기본은 1씩 움직인다.)</p><p><img src="/image/img4.jpeg" alt="이미지 4"></p><ul><li>강제적으로 입력 특성맵을 다운샘플링 하는데에 사용된다.</li><li>실전에서는 드물게 사용된다. 특성맵의 다운샘플링에는 주로 <strong>max pooling 연산</strong>을 사용한다.</li></ul><h2 id="최대-풀링-연산"><a href="#최대-풀링-연산" class="headerlink" title="최대 풀링 연산"></a>최대 풀링 연산</h2><ul><li>스트라이드와 같이 특성맵을 강제적으로 다운샘플링 하는데에 사용한다.</li><li>입력 특성맵에서 각 윈도우별로 추출된 패치에 대해 <code>각 채널별로 최대값을 출력</code>한다.</li><li>보통 2x2윈도우와 스트라이드 2를 사용하여 특성맵을 <u>절반 크기로 다운샘플링</u>한다.</li></ul><p>: 당연하게도 평균풀링 등 다른 방법도 있다. 하지만 최대 풀링연산이 가장 성능이 좋다.</p><h3 id="최대-풀링-연산을-하는-이유"><a href="#최대-풀링-연산을-하는-이유" class="headerlink" title="[ 최대 풀링 연산을 하는 이유 ]"></a>[ 최대 풀링 연산을 하는 이유 ]</h3><ul><li>특성맵의 가중치 개수를 줄인다.<br>: 너무 많은 가중치로 인한 overfitting 방지</li><li>연속적인 합성곱 층이 점점 커지는 윈도우를 통해 입력 특성맵을 바라보도록 함으로서 <code>필터의 공간적인 계층 구조를 형성</code>한다. (?)</li></ul><blockquote><p>따라서 일반적으로 컨브넷의 서브샘플링은 다음의 방법을 사용한다.</p><p>(1) 스트라이드가 없는 합성곱으로 조밀한 특성맵을 만든다.<br>(2) 작은 각각의 패치에 대해 최대로 활성화된 특성을 고른다.</p></blockquote>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/06/21/ai-study9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Tensorflow 개발자 자격증 준비하기(3)</title>
      <link>https://katie0809.github.io/2020/06/18/tf-study3/</link>
      <guid>https://katie0809.github.io/2020/06/18/tf-study3/</guid>
      <pubDate>Thu, 18 Jun 2020 08:03:47 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Image-Classification&quot;&gt;&lt;a href=&quot;#Image-Classification&quot; class=&quot;headerlink&quot; title=&quot;Image Classification&quot;&gt;&lt;/a&gt;Image Classification&lt;/h2&gt;&lt;p&gt;가위바위보 손 사진을 갖고 가위/바위/보자기로 이미지를 분류하는 classification 문제를 풀어보자. 이전과 마찬가지로 이미지 분류 문제입니다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Image-Classification"><a href="#Image-Classification" class="headerlink" title="Image Classification"></a>Image Classification</h2><p>가위바위보 손 사진을 갖고 가위/바위/보자기로 이미지를 분류하는 classification 문제를 풀어보자. 이전과 마찬가지로 이미지 분류 문제입니다.</p><a id="more"></a><h2 id="1-문제"><a href="#1-문제" class="headerlink" title="1. 문제"></a>1. 문제</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution_model</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">'https://storage.googleapis.com/download.tensorflow.org/data/rps.zip'</span></span><br><span class="line">    urllib.request.urlretrieve(url, <span class="string">'rps.zip'</span>)</span><br><span class="line">    local_zip = <span class="string">'rps.zip'</span></span><br><span class="line">    zip_ref = zipfile.ZipFile(local_zip, <span class="string">'r'</span>)</span><br><span class="line">    zip_ref.extractall(<span class="string">'tmp/'</span>)</span><br><span class="line">    zip_ref.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TRAINING_DIR = <span class="string">"tmp/rps/"</span></span><br><span class="line">    training_datagen = ImageDataGenerator(</span><br><span class="line">    <span class="comment"># YOUR CODE HERE)</span></span><br><span class="line"></span><br><span class="line">    train_generator = <span class="comment"># YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">    <span class="comment"># YOUR CODE HERE, BUT END WITH A 3 Neuron Dense, activated by softmax</span></span><br><span class="line">        tf.keras.layers.Dense(<span class="number">3</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h2 id="2-기본-CNN모델-사용"><a href="#2-기본-CNN모델-사용" class="headerlink" title="2. 기본 CNN모델 사용"></a>2. 기본 CNN모델 사용</h2><p>: 케라스 책에 있는 고양이 vs 강아지 기본 분류모델을 사용했다.</p><h3 id="데이터-전처리"><a href="#데이터-전처리" class="headerlink" title="[ 데이터 전처리 ]"></a>[ 데이터 전처리 ]</h3><p>: 단계는 다음과 같다. <code>ImageGenerator</code> 클래스를 사용한다.</p><ol><li>사진 파일을 읽는다</li><li>jpg컨텐츠를 rgb픽셀로 디코딩</li><li>부동소수점 타입의 텐서로 변환</li><li>0 - 255의 픽셀값을 [0, 1] 사이로 조정한다.<br>: <strong>신경망은 작은 입력값을 선호한다.</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">training_datagen = ImageDataGenerator(</span><br><span class="line">  rescale=<span class="number">1.</span> / <span class="number">255</span>,</span><br><span class="line">  validation_split=<span class="number">0.2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">train_generator = training_datagen.flow_from_directory(TRAINING_DIR, </span><br><span class="line">                                                       target_size=(<span class="number">150</span>, <span class="number">150</span>), </span><br><span class="line">                                                       batch_size=<span class="number">20</span>, </span><br><span class="line">                                                       class_mode=<span class="string">'categorical'</span>, </span><br><span class="line">                                                       subset=<span class="string">'training'</span>,</span><br><span class="line">                                                      )</span><br><span class="line"></span><br><span class="line">validation_generator = training_datagen.flow_from_directory(TRAINING_DIR, </span><br><span class="line">                                                            target_size=(<span class="number">150</span>, <span class="number">150</span>), </span><br><span class="line">                                                            batch_size=<span class="number">20</span>, </span><br><span class="line">                                                            class_mode=<span class="string">'categorical'</span>,</span><br><span class="line">                                                            subset=<span class="string">'validation'</span>,</span><br><span class="line">                                                           )</span><br></pre></td></tr></table></figure><ul><li><code>rescale=1. / 255</code> : 모든 이미지를 1/255로 스케일 조정</li><li><code>target_size=(150, 150)</code> : 모든 이미지 크기를 150 x 150으로 바꾼다</li><li><code>class_mode=&#39;categorical&#39;</code> : 다중분류일 경우 categorical, 혹은 sparse 사용. 이진분류는 binary사용.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model.fit(</span><br><span class="line">  train_generator, </span><br><span class="line">  steps_per_epoch=len(train_generator),</span><br><span class="line">  epochs=<span class="number">30</span>,</span><br><span class="line">  validation_data=(validation_generator),</span><br><span class="line">  validation_steps=len(validation_generator),</span><br><span class="line">  callbacks=[es, mc],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>fit()</code> : 첫번째 매개변수로 python generator를 받는다(ImageGenerator로 생성).</li><li><code>steps_per_epoch</code> : 하나의 에포크를 정의하기위해 사용할 배치의 수. 이 값만큼 경사하강법을 실시한다.<ul><li>여기서 20개의 샘플이 하나의 배치이므로 에포크 하나에서 샘플 2016개가 모두 처리되려면 101개의 배치가 필요하다.</li><li>이는 그냥 간단하게 <strong>len(train_generator)</strong>의 값이다.</li></ul></li><li><code>validation_data</code> : python data generator, 혹은 numpy tuple을 인자로 넘길 수 있다.</li></ul><p>![샘플개수와_배치데이터_python_generator_크기](/image/스크린샷 2020-06-22 오전 12.00.50.png)</p><h3 id="사용한-모델"><a href="#사용한-모델" class="headerlink" title="[ 사용한 모델 ]"></a>[ 사용한 모델 ]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">150</span>, <span class="number">150</span>, <span class="number">3</span>)),</span><br><span class="line">    MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">    Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>),</span><br><span class="line">    MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">    Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>),</span><br><span class="line">    MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">    Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>),</span><br><span class="line">    MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line">    Flatten(), </span><br><span class="line">    Dense(<span class="number">512</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    Dense(<span class="number">3</span>, activation=<span class="string">'softmax'</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=keras.optimizers.RMSprop(lr=<span class="number">1e-4</span>), loss=<span class="string">'categorical_crossentropy'</span>, metrics=[<span class="string">'acc'</span>])</span><br></pre></td></tr></table></figure><p>: 결과는 책에서 나온대로 70%대 초반정도의 정확도를 보여줬다. 이때 훈련 정확도와 검증 정확도, 훈련 손실과 검증 손실의 양상은 아래의 이미지와 비슷했다.</p><p><img src="https://i.imgur.com/e0pZ4i9.png" alt="훈련정확도와_검증정확도"></p><p><img src="https://i.imgur.com/Kv1ZdeQ.png" alt="훈련손실과_검증손실"></p><ul><li>위의 두 그래프는 <strong>과대적합</strong>되는 모델의 양상을 보여준다. <ul><li>훈련 정확도는 선형적으로 증가하여 100%까지 이르렀지만, 검증 정확도는 어느 지점에서 멈춰있다. </li><li>훈련 손실은 선형적으로 감소하여 0%까지 이르렀지만, 검증 손실은 선형적으로 증가/변화가 없다.</li></ul></li></ul><p>이러한 Overfitting문제를 컴퓨터 비전분야에서 해결하기 위해 일반적으로 사용하는 <code>Data augumentation(데이터 증식)</code> 방법을 사용해보도록 하자.</p><h2 id="3-데이터-증식-사용"><a href="#3-데이터-증식-사용" class="headerlink" title="3. 데이터 증식 사용"></a>3. 데이터 증식 사용</h2><blockquote><p><code>데이터 증식</code> : 기존 훈련샘플들을 변환함으로서 <strong>더 많은 훈련데이터를 생성</strong>하여 학습을 위한 샘플의 개수를 늘리는 방법</p></blockquote><p>케라스에서는 ImageDataGenerator에서 이미지를 읽어들일때 여러 랜덤변환을 적용하도록 설정할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ImageDataGenerator(</span><br><span class="line">  rescale=<span class="number">1.</span> / <span class="number">255</span>,</span><br><span class="line">  validation_split=<span class="number">0.2</span></span><br><span class="line">  rotation_range=<span class="number">40</span>,      <span class="comment"># 랜덤하게 사진을 회전시킬 각도 범위(1-180도)</span></span><br><span class="line">  width_shift_range=<span class="number">0.2</span>,  <span class="comment"># 사진을 수평으로 랜덤하게 평행이동시킬 범위</span></span><br><span class="line">  height_shift_range=<span class="number">0.2</span>, <span class="comment"># 사진을 수직으로 랜덤하게 평행이동시킬 범위</span></span><br><span class="line">  shear_range=<span class="number">0.2</span>,        <span class="comment"># 랜덤하게 전단변환을 적용할 각도 범위</span></span><br><span class="line">  zoom_range=<span class="number">0.2</span>,         <span class="comment"># 랜덤하게 사진을 확대할 범위</span></span><br><span class="line">  horizontal_flip=<span class="literal">True</span>,   <span class="comment"># 랜덤하게 이미지를 수평으로 뒤집을지 여부</span></span><br><span class="line">  fill_mode=<span class="string">'nearest'</span>,    <span class="comment"># 회전/이동 등으로 새롭게 생성되는 픽셀을 채울 방법</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>회전각의 범위는 <code>-rotation_range ~ +rotation_range</code>이다</li><li>height/width_shift_range는 전체 너비와 높이에 대한 비율값이다.</li><li>전단변환은 rotation_range로 회전할 때 y축 방향으로 각도를 증가시켜 이미지를 변형한다.</li><li>horizontal_flip은 수평대칭을 가정할 수 있는 풍경이나 인물사진의 학습에 사용한다. 도로 표지판과 같이 뒤집힌 글씨를 학습시키는건 노노.</li><li>fill_mode의 기본값인 <strong>nearest</strong>는 <u>인접한 픽셀을 사용</u>한다. 그밖에 constant, reflect, wrap등이 있다.</li></ol><p>또한 모델에는 Dense layer직전에 Dropout을 추가한다.</p><h2 id="4-사전-훈련된-컨브넷-사용"><a href="#4-사전-훈련된-컨브넷-사용" class="headerlink" title="4. 사전 훈련된 컨브넷 사용"></a>4. 사전 훈련된 컨브넷 사용</h2><p>완전 사기다 이건ㅋㅋ. 나쁜뜻이 아니라 성능이 너무 극적으로 좋아져서 사기라는 의미다. 실제 시험때 써도 될지 모르겠다.</p><p>방법은 그냥 간단하다. 사전 훈련된 합성곱 신경망을 가져와서 내 Dense layer classifier 앞에 넣어준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.applications.vgg16 <span class="keyword">import</span> VGG16</span><br><span class="line"></span><br><span class="line">conv_base = VGG16(weights=<span class="string">'imagenet'</span>,</span><br><span class="line">                  include_top=<span class="literal">False</span>,</span><br><span class="line">                  input_shape=(<span class="number">150</span>, <span class="number">150</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">conv_base.trainable = <span class="literal">False</span> <span class="comment"># 사전학습된 가중치는 학습하지 않는다.</span></span><br></pre></td></tr></table></figure><p>모델은 아래처럼 간단해진다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(conv_base)</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">256</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">3</span>, activation=<span class="string">'softmax'</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Epoch 30&#x2F;30</span><br><span class="line">101&#x2F;101 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 549s 5s&#x2F;step - loss: 2.8820e-04 - acc: 1.0000 - val_loss: 1.3292e-05 - val_acc: 0.9881</span><br><span class="line"></span><br><span class="line">Epoch 00030: val_acc did not improve from 0.99603</span><br></pre></td></tr></table></figure><p>근데 학습시간이 어ㅓㅓ어어ㅓㅓ엄청나게 오래걸린다. 실제로는 못쓸듯…</p>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/06/18/tf-study3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Tensorflow 개발자 자격증 준비하기(2)</title>
      <link>https://katie0809.github.io/2020/06/16/tf-study2/</link>
      <guid>https://katie0809.github.io/2020/06/16/tf-study2/</guid>
      <pubDate>Tue, 16 Jun 2020 13:19:43 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Basic-Classification-with-CNN&quot;&gt;&lt;a href=&quot;#Basic-Classification-with-CNN&quot; class=&quot;headerlink&quot; title=&quot;Basic Classification with CNN&quot;&gt;&lt;/a&gt;Basic Classification with CNN&lt;/h2&gt;&lt;p&gt;이번에는 케라스의 패션 MNIST 데이터셋을 사용해 10개의 카테고리로 옷을 분류하는 문제를 해결해보겠다. 텐서플로 기본 튜토리얼을 참고했습니다.&lt;/p&gt;
&lt;p&gt;다음 &lt;a href=&quot;https://www.tensorflow.org/tutorials/keras/classification&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;튜토리얼&lt;/a&gt;을 참고했습니다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Basic-Classification-with-CNN"><a href="#Basic-Classification-with-CNN" class="headerlink" title="Basic Classification with CNN"></a>Basic Classification with CNN</h2><p>이번에는 케라스의 패션 MNIST 데이터셋을 사용해 10개의 카테고리로 옷을 분류하는 문제를 해결해보겠다. 텐서플로 기본 튜토리얼을 참고했습니다.</p><p>다음 <a href="https://www.tensorflow.org/tutorials/keras/classification" rel="external nofollow noopener noreferrer" target="_blank">튜토리얼</a>을 참고했습니다.</p><a id="more"></a><h2 id="첫번째-신경망-훈련하기-기초적인-분류-문제"><a href="#첫번째-신경망-훈련하기-기초적인-분류-문제" class="headerlink" title="첫번째 신경망 훈련하기 : 기초적인 분류 문제"></a>첫번째 신경망 훈련하기 : 기초적인 분류 문제</h2><ul><li><p><u>운동화, 셔츠 등의 옷 이미지를 분류하는 신경망 모델</u>을 구축한다.</p></li><li><p>10개의 카테고리, 7만개의 이미지로 구성된 <code>fasion mnist 데이터셋</code>을 사용한다(기본 mnist 데이터셋은 손글씨 숫자로 이루어져 있다.)</p><p>: 네트워크 훈련에 6만개의 이미지를 사용한다. 테스트 데이터는 1만개의 이미지를 사용한다.</p></li></ul><h3 id="1-데이터셋-로드하기"><a href="#1-데이터셋-로드하기" class="headerlink" title="1) 데이터셋 로드하기"></a>1) 데이터셋 로드하기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tensorflow와 tf.keras를 임포트합니다</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line">fashion_mnist = keras.datasets.fashion_mnist</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()</span><br></pre></td></tr></table></figure><ul><li><code>load_data()</code> : 4개의 NumPy 배열이 반환된다. (학습에 사용되는 훈련세트, 테스트에 사용되는 훈련세트)</li><li><strong>각각의 이미지</strong>는 <u>28 * 28 크기의 numpy배열</u>이다.</li><li>각 이미지는 카테고리를 나타내는 <u>0에서 9사이의 정수</u>인 하나의 <code>label</code>과 매핑되어 있다.</li></ul><h3 id="2-데이터-전처리"><a href="#2-데이터-전처리" class="headerlink" title="2) 데이터 전처리"></a>2) 데이터 전처리</h3><ul><li><p>각 이미지가 갖는 픽셀값의 범위는 0<del>255 이다. 이를 0</del>1사이의 값으로 조정한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_images = train_images / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">test_images = test_images / <span class="number">255.0</span></span><br></pre></td></tr></table></figure></li><li><p>첫 25개 이미지와, 각 이미지의 카테고리명을 출력해본다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">25</span>):</span><br><span class="line">    plt.subplot(<span class="number">5</span>,<span class="number">5</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.grid(<span class="literal">False</span>)</span><br><span class="line">    plt.imshow(train_images[i], cmap=plt.cm.binary)</span><br><span class="line">    plt.xlabel(class_names[train_labels[i]])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-모델-구성"><a href="#3-모델-구성" class="headerlink" title="3) 모델 구성"></a>3) 모델 구성</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),</span><br><span class="line">    keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><ul><li><code>tf.keras.layers.Flatten</code> : 2차원 배열의 이미지포맷을 28 * 28 = 784 픽셀의 <strong>1차원 배열로 변환</strong>한다.<ul><li>이미지 내 픽셀의 행을 펼쳐서 일렬로 늘린다.</li><li>학습되는 가중치는 없다. 데이터 변환만 진행한다.</li></ul></li><li><code>tf.keras.layers.Dense</code> : 밀집 연결층 혹은 완전 연결층이라고 지칭.<ul><li>위의 코드에서 첫번째 Dense층은 128개의 노드(뉴런)를 갖는다.</li><li>두번째 층은 10개의 카테고리에 이미지가 속할 확률을 출력해내는 softmax층이다.</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><ul><li><code>optimizer</code> : 데이터와 손실 값을 바탕으로 모델의 가중치를 업데이트하는 방법</li><li><code>loss</code> : 훈련하는 동안 모델의 오차를 측정하는 방법. 모델의 학습이 올바른 방향으로 향하도록 이 손실함수의 값을 최소화할 필요가 있다.</li><li><code>metrics</code> : 훈련단계와 테스트단계를 모니터링 하기 위해 사용한다. 위의 코드에서 지표로 사용하는 accuracy는 올바르게 분류된 이미지의 비율을 의미한다.</li></ul><h3 id="4-모델-훈련"><a href="#4-모델-훈련" class="headerlink" title="4) 모델 훈련"></a>4) 모델 훈련</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(train_images, train_labels, epochs=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="5-정확도-평가"><a href="#5-정확도-평가" class="headerlink" title="5) 정확도 평가"></a>5) 정확도 평가</h3><ul><li>테스트 데이터셋에서 모델의 성능을 비교한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_loss, test_acc = model.evaluate(test_images,  test_labels, verbose=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n테스트 정확도:'</span>, test_acc)</span><br></pre></td></tr></table></figure><h2 id="나의-풀이"><a href="#나의-풀이" class="headerlink" title="나의 풀이"></a>나의 풀이</h2><p>: 일단 먼저 튜토리얼의 코드를 그대로 사용해봤다. 썩 성능이 좋지 않았다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Basic Datasets Question</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Create a classifier for the Fashion MNIST dataset</span></span><br><span class="line"><span class="comment"># Note that the test will expect it to classify 10 classes and that the </span></span><br><span class="line"><span class="comment"># input shape should be the native size of the Fashion MNIST dataset which is </span></span><br><span class="line"><span class="comment"># 28x28 monochrome. Do not resize the data. YOur input layer should accept</span></span><br><span class="line"><span class="comment"># (28,28) as the input shape only. If you amend this, the tests will fail.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line">fashion_mnist = tf.keras.datasets.fashion_mnist</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()</span><br><span class="line">train_images = train_images / <span class="number">255.0</span></span><br><span class="line">test_images = test_images / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution_model</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    model = keras.Sequential([</span><br><span class="line">        keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),</span><br><span class="line">        keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">        keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">    ])</span><br><span class="line">    model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">                  loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">                  metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">    model.fit(train_images, train_labels, epochs=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that you'll need to save your model as a .h5 like this</span></span><br><span class="line"><span class="comment"># This .h5 will be uploaded to the testing infrastructure</span></span><br><span class="line"><span class="comment"># and a score will be returned to you</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    model = solution_model()</span><br><span class="line"></span><br><span class="line">    test_loss, test_acc = model.evaluate(test_images,  test_labels, verbose=<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'\n테스트 정확도:'</span>, test_acc)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Epoch 1&#x2F;5</span><br><span class="line">1875&#x2F;1875 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 3s 2ms&#x2F;step - loss: 0.4936 - accuracy: 0.8256</span><br><span class="line">Epoch 2&#x2F;5</span><br><span class="line">1875&#x2F;1875 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 3s 2ms&#x2F;step - loss: 0.3743 - accuracy: 0.8652</span><br><span class="line">Epoch 3&#x2F;5</span><br><span class="line">1875&#x2F;1875 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 3s 2ms&#x2F;step - loss: 0.3343 - accuracy: 0.8778</span><br><span class="line">Epoch 4&#x2F;5</span><br><span class="line">1875&#x2F;1875 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 3s 2ms&#x2F;step - loss: 0.3118 - accuracy: 0.8846</span><br><span class="line">Epoch 5&#x2F;5</span><br><span class="line">1875&#x2F;1875 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 3s 2ms&#x2F;step - loss: 0.2913 - accuracy: 0.8923</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3574 - accuracy: 0.8679</span><br><span class="line"></span><br><span class="line">테스트 정확도: 0.867900013923645</span><br></pre></td></tr></table></figure><blockquote><p>실제 시험에서 테스트의 정확도는 89%, loss는 33% 이하여야 합격이다.</p></blockquote><p>튜토리얼의 코드가 생각보다 성능이 안나와서 이것저것 개선을 시도해봤다.</p><hr><h3 id="시도-1"><a href="#시도-1" class="headerlink" title="시도 1)"></a>시도 1)</h3><p>: 단순히 생각해봤을때 가장 기본적이라고 생각되는 조건들을 추가해봤다.</p><ol><li><code>epoch 증가</code> : 학습 횟수를 5에서 30회로 늘렸다.</li><li><code>검증 데이터셋</code> 사용 : fasion mnist에서 제공되는 테스트 데이터셋을 실제 학습이 잘 되고있는지를 검증하는 validation set으로 추가했다.</li><li><code>조기종료 조건</code> 추가 : 학습 횟수를 늘린만큼 잘못 학습이 될 경우를 방지하기 위해 조기종료 조건을 추가했다.</li></ol><p>대충 바뀐 코드부분은 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">es = EarlyStopping(monitor=<span class="string">'val_loss'</span>, mode=<span class="string">'min'</span>, verbose=<span class="number">1</span>, patience=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">model.fit(train_images, train_labels, epochs=<span class="number">30</span>, callbacks=es, validation_data=(test_images, test_labels))</span><br></pre></td></tr></table></figure><ul><li>검증 데이터셋의 오차가 4번 이상 증가하면 과적합으로 판단하고 학습을 종료시키도록 했다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Epoch 16&#x2F;30</span><br><span class="line">1875&#x2F;1875 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 4s 2ms&#x2F;step - loss: 0.1993 - accuracy: 0.9251 - val_loss: 0.3415 - val_accuracy: 0.8849</span><br><span class="line">Epoch 00016: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3415 - accuracy: 0.8849</span><br><span class="line"></span><br><span class="line">테스트 정확도: 0.8848999738693237</span><br></pre></td></tr></table></figure><p>전반적으로 성능이 조금 좋아졌다. 아직 합격기준에는 미치지 못한다.</p><p>그리고 계속 이런저런 코드를 찾아보니 categorical_crossentropy라는 손실함수를 사용하는 경우도 있어서 내 코드의 sparse_categorical_crossentropy 손실함수와의 차이점이 궁금해졌다. 찾아봄.</p><blockquote><p><code>categorical_crossentropy</code> 와 <code>sparse_categorical_crossentropy</code> 의 차이점은?</p><p><img src="/image/20200618_135630.png" alt></p></blockquote><p>-&gt;   원핫코딩한 데이터의 분류 = categorical_crossentropy. input shape과 output shape의 크기가 같다.</p><h3 id="시도-2"><a href="#시도-2" class="headerlink" title="시도 2)"></a>시도 2)</h3><ol><li>조기종료 조건 수정 : 데이터셋 오차의 증가 허용을 4번 -&gt; 3번으로 줄였다.</li><li>최적 모델 저장 : <strong>모델 체크포인트</strong>를 설정해서 val_accuracy가 증가한 경우에만 모델을 저장했다.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> EarlyStopping, ModelCheckpoint</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    es = EarlyStopping(monitor=<span class="string">'val_loss'</span>, mode=<span class="string">'min'</span>, verbose=<span class="number">1</span>, patience=<span class="number">3</span>)</span><br><span class="line">    mc = ModelCheckpoint(<span class="string">'best_model.h5'</span>, monitor = <span class="string">'val_accuracy'</span>, mode = <span class="string">'max'</span>, verbose = <span class="number">1</span>, save_best_only = <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">   model.fit(train_images, train_labels, epochs=<span class="number">30</span>, callbacks=[es, mc], validation_data=(test_images, test_labels))</span><br><span class="line"></span><br><span class="line">    loaded_model = keras.models.load_model(<span class="string">'best_model.h5'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loaded_model</span><br></pre></td></tr></table></figure><p>변화가 사알짝 있었다. 5번 시도해본 결과 1번 합격기준에 맞췄다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Epoch 00011: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3351 - accuracy: 0.8876</span><br><span class="line">테스트 정확도: 0.8876000046730042</span><br><span class="line"></span><br><span class="line">Epoch 00009: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.3240 - accuracy: 0.8842</span><br><span class="line">테스트 정확도: 0.8841999769210815</span><br><span class="line"></span><br><span class="line">Epoch 00013: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3313 - accuracy: 0.8928</span><br><span class="line">테스트 정확도: 0.892799973487854</span><br><span class="line"></span><br><span class="line">Epoch 00014: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3192 - accuracy: 0.8916</span><br><span class="line">테스트 정확도: 0.8916000127792358</span><br><span class="line"></span><br><span class="line">Epoch 00010: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3199 - accuracy: 0.8863</span><br><span class="line">테스트 정확도: 0.8863000273704529</span><br></pre></td></tr></table></figure><p>하지만 아직 한참 모자란다ㅠ 특히 loss부분이 크게 줄지 않는 것 같다.</p><h3 id="시도-3"><a href="#시도-3" class="headerlink" title="시도 3)"></a>시도 3)</h3><p>: 모델 복잡도를 증가시키고 Dropout을 추가해줘봤다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),</span><br><span class="line">    keras.layers.Dense(<span class="number">256</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Epoch 00018: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3267 - accuracy: 0.8895</span><br><span class="line">테스트 정확도: 0.8895000219345093</span><br><span class="line"></span><br><span class="line">Epoch 00009: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3385 - accuracy: 0.8802</span><br><span class="line">테스트 정확도: 0.8802000284194946</span><br><span class="line"></span><br><span class="line">Epoch 00011: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3385 - accuracy: 0.8805</span><br><span class="line">테스트 정확도: 0.8805000185966492</span><br><span class="line"></span><br><span class="line">Epoch 00009: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3637 - accuracy: 0.8756</span><br><span class="line">테스트 정확도: 0.8755999803543091</span><br><span class="line"></span><br><span class="line">Epoch 00017: early stopping</span><br><span class="line">313&#x2F;313 - 0s - loss: 0.3238 - accuracy: 0.8895</span><br><span class="line">테스트 정확도: 0.8895000219345093</span><br></pre></td></tr></table></figure><p>오히려 결과가 더 안좋아졌다. 음.. 어떻게 해야하지</p><h3 id="시도-4"><a href="#시도-4" class="headerlink" title="시도 4)"></a>시도 4)</h3><p>: <strong>CNN을 사용</strong>하고 <strong>모델 복잡도</strong>를 확 올려봤다. 컨볼루션 레이어를 생성하는 <code>Conv2D</code> 클래스는 4차원 텐서를 입력으로 받는다. 따라서 fasion_mnist의 28 * 28 이미지 데이터를 reshape해줄 필요가 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_images = tf.reshape(train_images, shape=[<span class="number">60000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br><span class="line">test_images = tf.reshape(test_images, shape=[<span class="number">10000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>모델은 구글링으로 적당히 짜깁기해서 아래처럼 구성해봤다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">3</span>, strides=(<span class="number">2</span>, <span class="number">2</span>), activation=<span class="string">'relu'</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)),</span><br><span class="line">    keras.layers.Conv2D(filters=<span class="number">64</span>, kernel_size=<span class="number">3</span>, strides=(<span class="number">2</span>, <span class="number">2</span>), activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.MaxPooling2D(pool_size=<span class="number">2</span>),</span><br><span class="line">    keras.layers.Flatten(),</span><br><span class="line">    keras.layers.Dense(<span class="number">1024</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">256</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>오 유의미한 변화가 있었다. 전반적인 loss가 0.3 이하로 줄어들고 정확도는 90%를 평균적으로 넘었다. 이정도면 턱걸이지만  시험의 통과는 가능한 수준이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Epoch 00008: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2781 - accuracy: 0.9010</span><br><span class="line">테스트 정확도: 0.9010000228881836</span><br><span class="line"></span><br><span class="line">Epoch 00008: early stopping</span><br><span class="line">313&#x2F;313 - 2s - loss: 0.2836 - accuracy: 0.9018</span><br><span class="line">테스트 정확도: 0.9017999768257141</span><br><span class="line"></span><br><span class="line">Epoch 00008: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.3023 - accuracy: 0.9014</span><br><span class="line">테스트 정확도: 0.9014000296592712</span><br><span class="line"></span><br><span class="line">Epoch 00008: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.3116 - accuracy: 0.9024</span><br><span class="line">테스트 정확도: 0.902400016784668</span><br><span class="line"></span><br><span class="line">Epoch 00010: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.3102 - accuracy: 0.9064</span><br><span class="line">테스트 정확도: 0.9064000248908997</span><br></pre></td></tr></table></figure><p>이게 CNN을 사용해서 올라간건지 아니면 모델 복잡도를 증가시킨것도 변화에 의미가 있었는지 궁금해서 시도2) 의 모델에 CNN만 추가해서 다시 테스트해봤다. </p><p>배치를 쓰지않고 느려터진 CNN을 돌리려니 모델 학습되는걸 기다리는것만 백년걸린다. 아 힘드러.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">3</span>, strides=(<span class="number">2</span>, <span class="number">2</span>), activation=<span class="string">'relu'</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)),</span><br><span class="line">    keras.layers.Conv2D(filters=<span class="number">64</span>, kernel_size=<span class="number">3</span>, strides=(<span class="number">2</span>, <span class="number">2</span>), activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.MaxPooling2D(pool_size=<span class="number">2</span>),</span><br><span class="line">    keras.layers.Flatten(),</span><br><span class="line">    keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Epoch 00011: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2710 - accuracy: 0.9044</span><br><span class="line">테스트 정확도: 0.9043999910354614</span><br><span class="line"></span><br><span class="line">Epoch 00011: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2746 - accuracy: 0.9055</span><br><span class="line">테스트 정확도: 0.9054999947547913</span><br><span class="line"></span><br><span class="line">Epoch 00008: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2923 - accuracy: 0.8992</span><br><span class="line">테스트 정확도: 0.8992000222206116</span><br><span class="line"></span><br><span class="line">Epoch 00010: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2896 - accuracy: 0.8998</span><br><span class="line">테스트 정확도: 0.8998000025749207</span><br><span class="line"></span><br><span class="line">Epoch 00012: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2843 - accuracy: 0.9051</span><br><span class="line">테스트 정확도: 0.9050999879837036</span><br></pre></td></tr></table></figure><p>굉장히 애매한 결과가 나왔다. 정확도의 maximum이 모델 복잡도를 올렸을때보다 조금 높아졌지만 minimum도 그만큼 살짝 낮아졌다. 혹시나 해서 최종 레이어 이전에 20%의 비율로 dropout을 추가해주고 다시 학습시켜봤다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Epoch 00013: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2861 - accuracy: 0.9081</span><br><span class="line">테스트 정확도: 0.9081000089645386</span><br><span class="line"></span><br><span class="line">Epoch 00013: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2754 - accuracy: 0.9056</span><br><span class="line">테스트 정확도: 0.9056000113487244</span><br><span class="line"></span><br><span class="line">Epoch 00013: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2760 - accuracy: 0.9051</span><br><span class="line">테스트 정확도: 0.9050999879837036</span><br><span class="line"></span><br><span class="line">Epoch 00011: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2751 - accuracy: 0.9064</span><br><span class="line">테스트 정확도: 0.9064000248908997</span><br><span class="line"></span><br><span class="line">Epoch 00013: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2877 - accuracy: 0.9019</span><br><span class="line">테스트 정확도: 0.9018999934196472</span><br></pre></td></tr></table></figure><p>오오오 확실히 변화가 있었다. 전반적으로 정확도가 90.5% 이상으로 상승했다. 결국 Dense 레이어를 추가해서 단순히 모델 복잡도를 올려버리는 것 보다는 dropout을 추가해서 복잡도를 낮추는게 더 효과가 있었다.</p><p>여기에서 궁금해서 몇가지 더 실험을 해봤다.</p><ol><li><p>생각보다 loss가 많이 낮아졌기에 손실이 높아지는걸 감수하고 학습을 좀더 진행시켜보면 정확도가 올라갈지 궁금했다. <u>조기종료 조건의 patience를 5로 높여봤다.</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Epoch 00016: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.3029 - accuracy: 0.9076</span><br><span class="line">테스트 정확도: 0.9075999855995178</span><br><span class="line"></span><br><span class="line">Epoch 00013: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2799 - accuracy: 0.9045</span><br><span class="line">테스트 정확도: 0.9045000076293945</span><br></pre></td></tr></table></figure><p>손실이 증가한거에 비해 정확도의 증가는 미미한 편이다.</p></li><li><p>dropout 비율이 학습에 미치는 영향이 궁금했다. dropout 비율을 높여봤다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Dropout : 0.5</span><br><span class="line">Epoch 00012: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2802 - accuracy: 0.9046</span><br><span class="line">테스트 정확도: 0.9046000242233276</span><br><span class="line"></span><br><span class="line">Epoch 00016: early stopping</span><br><span class="line">313&#x2F;313 - 1s - loss: 0.2810 - accuracy: 0.9080</span><br><span class="line">테스트 정확도: 0.9079999923706055</span><br><span class="line"></span><br><span class="line"># Dropout : 0.25</span><br><span class="line">Epoch 00010: early stopping</span><br><span class="line">313&#x2F;313 - 3s - loss: 0.2662 - accuracy: 0.9120</span><br><span class="line">테스트 정확도: 0.9120000004768372</span><br><span class="line"></span><br><span class="line">Epoch 00011: early stopping</span><br><span class="line">313&#x2F;313 - 3s - loss: 0.2499 - accuracy: 0.9139</span><br><span class="line">테스트 정확도: 0.9139000177383423</span><br><span class="line"></span><br><span class="line"># Dropout : 0.3</span><br><span class="line">Epoch 00012: early stopping</span><br><span class="line">313&#x2F;313 - 3s - loss: 0.2442 - accuracy: 0.9173</span><br><span class="line">테스트 정확도: 0.9172999858856201</span><br><span class="line"></span><br><span class="line">Epoch 00009: early stopping</span><br><span class="line">313&#x2F;313 - 3s - loss: 0.2510 - accuracy: 0.9128</span><br><span class="line">테스트 정확도: 0.9128000140190125</span><br></pre></td></tr></table></figure><p>대박!!! 드롭아웃 비율을 조절한 것 만으로도 엄청난 변화가 생겼다. 드디어 0.5는 썩 성능이 좋지 않았고 0.3정도가 적당한 듯 싶다. 신기하네.</p></li></ol><hr><h2 id="최종모델"><a href="#최종모델" class="headerlink" title="최종모델"></a>최종모델</h2><p>내가 구성한 모델 중 가장 높은 성능을 보여준놈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">3</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)),</span><br><span class="line">    keras.layers.MaxPooling2D(pool_size=<span class="number">2</span>),</span><br><span class="line">    keras.layers.Conv2D(filters=<span class="number">64</span>, kernel_size=<span class="number">3</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.MaxPooling2D(pool_size=<span class="number">2</span>),</span><br><span class="line">    keras.layers.Flatten(),</span><br><span class="line">    keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dropout(<span class="number">0.3</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="추가-어디-책에서-본-모델"><a href="#추가-어디-책에서-본-모델" class="headerlink" title="추가 (+) 어디 책에서 본 모델"></a>추가 (+) 어디 책에서 본 모델</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Conv2D(<span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)),</span><br><span class="line">    keras.layers.MaxPooling2D(pool_size=<span class="number">2</span>),</span><br><span class="line">    keras.layers.Flatten(),</span><br><span class="line">    keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">100</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Epoch 00021: early stopping</span><br><span class="line">313&#x2F;313 - 2s - loss: 0.2330 - accuracy: 0.9183</span><br><span class="line">테스트 정확도: 0.9182999730110168</span><br><span class="line"></span><br><span class="line">Epoch 00017: early stopping</span><br><span class="line">313&#x2F;313 - 2s - loss: 0.2335 - accuracy: 0.9160</span><br><span class="line">테스트 정확도: 0.9160000085830688</span><br><span class="line"></span><br><span class="line">Epoch 00013: early stopping</span><br><span class="line">313&#x2F;313 - 2s - loss: 0.2499 - accuracy: 0.9131</span><br><span class="line">테스트 정확도: 0.913100004196167</span><br><span class="line"></span><br><span class="line">Epoch 00014: early stopping</span><br><span class="line">313&#x2F;313 - 2s - loss: 0.2392 - accuracy: 0.9165</span><br><span class="line">테스트 정확도: 0.9164999723434448</span><br></pre></td></tr></table></figure><p>간단하게 생겼는데 성능이 꽤 좋다. 이유가 뭘까?</p>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/06/16/tf-study2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Tensorflow 개발자 자격증 준비하기(1)</title>
      <link>https://katie0809.github.io/2020/06/08/tf-study1/</link>
      <guid>https://katie0809.github.io/2020/06/08/tf-study1/</guid>
      <pubDate>Mon, 08 Jun 2020 12:24:40 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Basic-Question&quot;&gt;&lt;a href=&quot;#Basic-Question&quot; class=&quot;headerlink&quot; title=&quot;Basic Question&quot;&gt;&lt;/a&gt;Basic Question&lt;/h2&gt;&lt;p&gt;구글에서 텐서플로 자격증 시험을 신규 출시(?)하였습니다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&quot;https://www.tensorflow.org/certificate?hl=ko&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;이 링크&lt;/a&gt;에서 확인할 수 있습니다. 응시료가 무려 100달러. 요즘 달러도 비싼데 아주 비싼 시험입니다. 떨어지면 재응시도 제한되므로 왠만하면 한번에 붙는 것을 목표로 합시다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Basic-Question"><a href="#Basic-Question" class="headerlink" title="Basic Question"></a>Basic Question</h2><p>구글에서 텐서플로 자격증 시험을 신규 출시(?)하였습니다.</p><p>자세한 내용은 <a href="https://www.tensorflow.org/certificate?hl=ko" rel="external nofollow noopener noreferrer" target="_blank">이 링크</a>에서 확인할 수 있습니다. 응시료가 무려 100달러. 요즘 달러도 비싼데 아주 비싼 시험입니다. 떨어지면 재응시도 제한되므로 왠만하면 한번에 붙는 것을 목표로 합시다.</p><a id="more"></a><p>첫번째 문제를 풀어보자. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Given this data, train a neural network to match the xs to the ys</span></span><br><span class="line"><span class="comment"># So that a predictor for a new value of X will give a float value</span></span><br><span class="line"><span class="comment"># very close to the desired answer</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">()</span>:</span></span><br><span class="line">    xs = np.array([<span class="number">-9.0</span>, <span class="number">0.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">8.0</span>], dtype=float)</span><br><span class="line">    ys = np.array([<span class="number">7.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">6.0</span>, <span class="number">5.0</span>, <span class="number">3.0</span>], dtype=float)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># YOUR CODE HERE</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    model = solution()</span><br><span class="line">    model.save(<span class="string">"mymodel"</span>)</span><br></pre></td></tr></table></figure><h2 id="1-문제분석"><a href="#1-문제분석" class="headerlink" title="1. 문제분석"></a>1. 문제분석</h2><h3 id="1-1-조건"><a href="#1-1-조건" class="headerlink" title="1-1. 조건"></a>1-1. 조건</h3><ul><li>xs를 ys에 매칭시키는 신경망모델을 제작하라.</li><li>모델의 input shape은 [1]</li><li>생성된 모델, 즉 predictor는 특정 실수값을 입력으로 받아 desired answer인 하나의 실수값을 반환한다.</li></ul><h3 id="1-2-관련이론"><a href="#1-2-관련이론" class="headerlink" title="1-2. 관련이론"></a>1-2. 관련이론</h3><ul><li><a href="https://wikidocs.net/21670" rel="external nofollow noopener noreferrer" target="_blank">케라스로 구현하는 선형회귀</a></li><li><a href="https://tykimos.github.io/2017/07/09/Early_Stopping/" rel="external nofollow noopener noreferrer" target="_blank">케라스 학습 조기종료</a></li><li><a href="http://blog.naver.com/win0k" rel="external nofollow noopener noreferrer" target="_blank">케라스(keras) 머신러닝 과적합 및 조기종료 시키기</a>]</li></ul><h2 id="2-풀이"><a href="#2-풀이" class="headerlink" title="2. 풀이"></a>2. 풀이</h2><ul><li>간단한 선형회귀 문제라고 생각했다. 위의 링크에 있는 코드를 거의 그대로 사용할 수 있을 듯 하다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 사용할 라이브러리</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential  <span class="comment"># 케라스의 Sequential()을 임포트</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense <span class="comment"># 케라스의 Dense()를 임포트</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> optimizers <span class="comment"># 케라스의 옵티마이저를 임포트</span></span><br></pre></td></tr></table></figure><h3 id="2-1-모델-설계"><a href="#2-1-모델-설계" class="headerlink" title="2-1. 모델 설계"></a>2-1. 모델 설계</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 케라스에서는 다양한 층으로 이루어진 인공신경망의 구성을 위해 Sequential()을 사용한다.</span></span><br><span class="line"><span class="comment"># Sequential()을 model로 선언한 뒤에 model.add()코드를 통해 층을 단계적으로 추가한다.</span></span><br><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1개의 실수 xs[i]에 대해 1개의 실수 ys[i]를 예측하는 모델이므로 출력차원과 입력차원 모두 1이다.</span></span><br><span class="line">model.add(Dense(<span class="number">1</span>, input_dim=<span class="number">1</span>, activation=<span class="string">'linear'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># optimizer는 경사하강법을 사용한다. learning rate은 0.01</span></span><br><span class="line">sgd = optimizers.SGD(lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 손실함수는 평균제곱오차(mse)를 사용한다.</span></span><br><span class="line">model.compile(optimizer=sgd, loss=<span class="string">'mse'</span>, metrics=[<span class="string">'mse'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 학습 진행한다. epoch는 300</span></span><br><span class="line">model.fit(xs, ys, batch_size=<span class="number">1</span>, epochs=<span class="number">300</span>, shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-모델-결과"><a href="#2-2-모델-결과" class="headerlink" title="2-2. 모델 결과"></a>2-2. 모델 결과</h3><ul><li><p>그냥 300번 학습하게 뒀더니 엄청 과적합이 되는 느낌. 학습 데이터도 얼마 없고 하다보니 loss가 거의 0.0000000001 수준으로 줄어들었다.</p></li><li><p>조기종료 조건을 추가해줘봤다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> EarlyStopping</span><br><span class="line"></span><br><span class="line">early_stopping = EarlyStopping(monitor=<span class="string">'loss'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 모델 학습 함수에 early_stopping에 대한 callback인자를 추가해준다.</span></span><br><span class="line">model.fit(xs, ys, batch_size=<span class="number">1</span>, epochs=<span class="number">300</span>, shuffle=<span class="literal">False</span>, callbacks=[early_stopping])</span><br></pre></td></tr></table></figure></li><li><p>대충 epoch 213에서 멈추는듯.</p></li></ul><h3 id="2-3-모델-평가"><a href="#2-3-모델-평가" class="headerlink" title="2-3. 모델 평가"></a>2-3. 모델 평가</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(model.predict([<span class="number">10.0</span>]))</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/06/08/tf-study1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝 스터디] Attention을 활용한 기계번역(실습)</title>
      <link>https://katie0809.github.io/2020/03/23/ai-study8/</link>
      <guid>https://katie0809.github.io/2020/03/23/ai-study8/</guid>
      <pubDate>Mon, 23 Mar 2020 01:41:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;텐서플로우 공식 가이드 중 &lt;a href=&quot;https://www.tensorflow.org/tutorials/text/nmt_with_attention&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Neural machine translation with attention&lt;/a&gt; 문서의 실습을 참고하였습니다.&lt;/p&gt;
&lt;h1 id=&quot;Neural-machine-translation-with-attention&quot;&gt;&lt;a href=&quot;#Neural-machine-translation-with-attention&quot; class=&quot;headerlink&quot; title=&quot;Neural machine translation with attention&quot;&gt;&lt;/a&gt;Neural machine translation with attention&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;스페인어에서 영어로 기계번역을 수행하는 seq2seq 모델을 직접 구현해본다.&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>텐서플로우 공식 가이드 중 <a href="https://www.tensorflow.org/tutorials/text/nmt_with_attention" rel="external nofollow noopener noreferrer" target="_blank">Neural machine translation with attention</a> 문서의 실습을 참고하였습니다.</p><h1 id="Neural-machine-translation-with-attention"><a href="#Neural-machine-translation-with-attention" class="headerlink" title="Neural machine translation with attention"></a>Neural machine translation with attention</h1><ul><li>스페인어에서 영어로 기계번역을 수행하는 seq2seq 모델을 직접 구현해본다.</li></ul><a id="more"></a><p>기본적인 데이터의 처리 과정은 이전과 같다. 전처리 과정은 생략하고 실제 인코더-어텐션-디코더를 클래스 형태로 구현하는 부분의 코드를 분석해본다.</p><h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><h3 id="1-클래스-설계"><a href="#1-클래스-설계" class="headerlink" title="1. 클래스 설계"></a>1. 클래스 설계</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span><span class="params">(tf.keras.Model)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocab_size, embedding_dim, enc_units, batch_sz)</span>:</span></span><br><span class="line">    super(Encoder, self).__init__()</span><br><span class="line">    self.batch_sz = batch_sz</span><br><span class="line">    self.enc_units = enc_units</span><br><span class="line">    self.embedding = tf.keras.layers.Embedding(vocab_size, embedding_dim)</span><br><span class="line">    self.gru = tf.keras.layers.GRU(self.enc_units,</span><br><span class="line">                                   return_sequences=<span class="literal">True</span>,</span><br><span class="line">                                   return_state=<span class="literal">True</span>,</span><br><span class="line">                                   recurrent_initializer=<span class="string">'glorot_uniform'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x, hidden)</span>:</span></span><br><span class="line">    x = self.embedding(x)</span><br><span class="line">    output, state = self.gru(x, initial_state = hidden)</span><br><span class="line">    <span class="keyword">return</span> output, state</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize_hidden_state</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.zeros((self.batch_sz, self.enc_units))</span><br></pre></td></tr></table></figure><p>[기본 파이썬 문법]</p><ul><li>class Encoder(<code>tf.keras.Model</code>) : Encoder 클래스는 tf.keras.Model 클래스를 상속</li><li>__ init __ : 클래스 생성자. 객체 생성 시점에 자동 호출</li><li>super(Encoder, self).__ init __() : 부모 클래스 초기화. <a href="[https://hashcode.co.kr/questions/6419/python3-super%EC%99%80-supera-self%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94](https://hashcode.co.kr/questions/6419/python3-super와-supera-self의-차이는-무엇인가요)">super()와 super(A, self)의 차이점</a> 참고</li></ul><p>[코드 분석]</p><ul><li><p>tf.keras.layers.Embedding()</p><ul><li>단어를 밀집벡터로 만드는 케라스 함수. 임베딩 층을 만든다.</li><li><strong>( <code>샘플의 수(시퀀스 길이)</code>, <code>입력크기(단어집합 크기)</code>)</strong> 인 2D 텐서를 입력으로 받아 <strong>( <code>샘플의 수(시퀀스 길이)</code>, <code>입력크기(단어집합 크기)</code>, <code>임베딩 차원</code>)</strong> 인 3D 텐서를 반환한다.</li><li>호출 위한 기본 파라미터는<br>: <code>input_dim</code>(단어집합 크기), <code>output_dim</code>(임베딩 차원) 이다.</li></ul></li><li><p>tf.keras.layers.GRU()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tf.compat.v1.keras.layers.GRU(</span><br><span class="line">    units, activation=<span class="string">'tanh'</span>, recurrent_activation=<span class="string">'hard_sigmoid'</span>, use_bias=<span class="literal">True</span>,</span><br><span class="line">    kernel_initializer=<span class="string">'glorot_uniform'</span>, recurrent_initializer=<span class="string">'orthogonal'</span>,</span><br><span class="line">    bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="literal">None</span>, recurrent_regularizer=<span class="literal">None</span>,</span><br><span class="line">    bias_regularizer=<span class="literal">None</span>, activity_regularizer=<span class="literal">None</span>, kernel_constraint=<span class="literal">None</span>,</span><br><span class="line">    recurrent_constraint=<span class="literal">None</span>, bias_constraint=<span class="literal">None</span>, dropout=<span class="number">0.0</span>,</span><br><span class="line">    recurrent_dropout=<span class="number">0.0</span>, implementation=<span class="number">1</span>, return_sequences=<span class="literal">False</span>,</span><br><span class="line">    return_state=<span class="literal">False</span>, go_backwards=<span class="literal">False</span>, stateful=<span class="literal">False</span>, unroll=<span class="literal">False</span>,</span><br><span class="line">    reset_after=<span class="literal">False</span>, **kwargs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><strong><code>units</code></strong>: Positive integer, dimensionality of the output space. 출력 텐서의 차원.</li><li><strong><code>return_sequences</code></strong>: Boolean. Whether to return the last output in the output sequence, or the full sequence. 모든 시점의 output을 출력할것인지(true), 아니면 최종 시점의 output만 출력할 것인지 결정.</li><li><strong><code>return_state</code></strong>: Boolean. Whether to return the last state in addition to the output. 최종 시점의 output뿐만 아니라 최종 시점의 은닉상태도 출력할지를 결정</li><li>호출 위한 기본 파라미터는<br>: <code>inputs</code> (3D tensor), training, initial_state</li></ul></li></ul><h3 id="2-사용"><a href="#2-사용" class="headerlink" title="2. 사용"></a>2. 사용</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">encoder = Encoder(vocab_inp_size, embedding_dim, units, BATCH_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample input</span></span><br><span class="line">sample_hidden = encoder.initialize_hidden_state()</span><br><span class="line">sample_output, sample_hidden = encoder(example_input_batch, sample_hidden)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Encoder output shape: (batch size, sequence length, units) &#123;&#125;'</span>.format(sample_output.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Encoder Hidden state shape: (batch size, units) &#123;&#125;'</span>.format(sample_hidden.shape))</span><br></pre></td></tr></table></figure><h3 id="3-코드분석-Embedding-layer의-통과"><a href="#3-코드분석-Embedding-layer의-통과" class="headerlink" title="3. 코드분석 - Embedding layer의 통과"></a>3. 코드분석 - Embedding layer의 통과</h3><p>위의 코드는 이전의 전처리를 수행해야 시행해볼 수 있다. 바로 인코더 모델의 모습만 확인해 볼 수 있도록 임의의 텐서를 만들어 모델 구조를 확인해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span><span class="params">(tf.keras.Model)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocab_size, embedding_dim, enc_units, batch_sz)</span>:</span></span><br><span class="line">    super(Encoder, self).__init__()</span><br><span class="line">    self.batch_sz = batch_sz</span><br><span class="line">    self.enc_units = enc_units</span><br><span class="line">    self.embedding = tf.keras.layers.Embedding(vocab_size, embedding_dim)</span><br><span class="line">    self.rnn = tf.keras.layers.SimpleRNN(self.enc_units,</span><br><span class="line">                                   return_sequences=<span class="literal">True</span>,</span><br><span class="line">                                   return_state=<span class="literal">True</span>,</span><br><span class="line">                                   recurrent_initializer=<span class="string">'glorot_uniform'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x, hidden)</span>:</span></span><br><span class="line">    x = self.embedding(x)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Encoder input shape: &#123;&#125;'</span>.format(x.shape))</span><br><span class="line">    output, state = self.rnn(x, initial_state = hidden)</span><br><span class="line">    <span class="keyword">return</span> output, state</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize_hidden_state</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.zeros((self.batch_sz, self.enc_units))</span><br><span class="line"></span><br><span class="line">example_input_batch = tf.zeros((<span class="number">3</span>, <span class="number">7</span>))</span><br><span class="line">encoder = Encoder(<span class="number">12</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># sample input</span></span><br><span class="line">sample_hidden = encoder.initialize_hidden_state()</span><br><span class="line">sample_output, sample_hidden = encoder(example_input_batch, sample_hidden)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Encoder output shape: (batch size, sequence length, units) &#123;&#125;'</span>.format(sample_output.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Encoder Hidden state shape: (batch size, units) &#123;&#125;'</span>.format(sample_hidden.shape))</span><br><span class="line"></span><br><span class="line">encoder.summary()</span><br></pre></td></tr></table></figure><p>위의 코드는 </p><ol><li>단어집합 크기 : 12</li><li>임베딩 차원 : 4</li><li>은닉상태의 크기 : 6</li><li>배치크기 : 3</li></ol><p>인 경우이다. 이때 입력 배치는 (3, 7)의 텐서이다. 공부를 하면서 헷갈리는 부분이 있어서 텐서의 크기를 단어집합 크기와 동일하게 3, 12로 잡고 싶었는데 그렇게 하면 out of bound 인덱스 오류가 나더라. 즉, 모델의 단어집합 크기와 동일한 크기의 텐서를 초기 입력으로 넣을 수 없는 듯 하다. 어쩔 수 없이 만든 그림은 (1) 모델의 단어집합 크기가 12인 경우 모델의 모습 과 (2) 모델의 초기 입력 텐서의 크기가 (3(=batch_sz), 12)인 경우 두개의 짬뽕이 되어버림.</p><p>위의 코드를 시행하면 아래의 결과가 나온다.</p><p><img src="/image/Untitled_-_Colaboratory.png" alt="Untitled_-_Colaboratory"></p><h4 id="임베딩-레이어"><a href="#임베딩-레이어" class="headerlink" title="임베딩 레이어"></a>임베딩 레이어</h4><p><img src="/image/nlp_visualize7.png" alt="자연어처리_시각화-8320429"></p><p>케라스의 Embedding 함수는 단어집합의 크기와 임베딩 차원을 변수로 받아 임베딩 레이어를 만들어준다. 이때 레이어에 모델을 추가하는 것과 모델에 들어가는 텐서는 별도이다. 난 이 개념을 이해하는게 넘나 어려웠다..ㅋㅋㅋㅠ</p><p>이게 뭔말인고 하니… 위의 그림은 시퀀스 길이가 12, 시퀀스 개수가 3, 임베딩 차원이 4인 경우 Embedding Layer를 통과했을때 텐서의 크기변환 시각화이다. </p><p>즉, 아래와 같은 예시가 있다고 가정하자.</p><p>[[I, am, studying, neural, language, machine, translation, in, a, cafe, near, home], [I, am, studying, language], [neural, machine, translation]]</p><p>이때 각 시퀀스를 12의 길이로 패딩해주자.</p><p>[    [I, am, studying, neural, language, machine, translation, in, a, cafe, near, home], </p><p>​    [I, am, studying, language, <pad>, <pad>, <pad>, <pad>, <pad>, <pad>, <pad>, <pad>], </pad></pad></pad></pad></pad></pad></pad></pad></p><p>​    [neural, machine, translation, <pad>, <pad>, <pad>, <pad>, <pad>, <pad>, <pad>, <pad>, <pad>]]</pad></pad></pad></pad></pad></pad></pad></pad></pad></p><p>패딩된 시퀀스를 정수 인코딩해주면 대충 아래처럼 된다.</p><p>[[1, 2, 3, …, 12], [1, 2, 3, 5, 0, 0, … 0], [4, 6, 7, 0, 0….. 0]]</p><p>= 크기 (3, 12)</p><p>그럼 이 (3, 12)의 텐서가 Embedding(단어집합 크기, 임베딩차원) 으로 만들어진 임베딩 레이어에 들어가는거다. </p><p>이때 단어집합의 크기를 14라고 하면(단어장 개수 + <unk> + <pad>) 해당 텐서가 들어가는 <code>임베딩 레이어 모델</code> 에는 임베딩 작업을 위한 <code>룩업 테이블</code> 이 생성되고, 이때 이 룩업테이블의 크기는 <code>임베딩 레이어의 파라미터의 개수</code> 가 된다.</pad></unk></p><blockquote><dl><dt>num of parameters in Embedding layer</dt><dd><code>14(vocab sz) * 4(embedding dim)</code> </dd></dl></blockquote><p><img src="/image/nlp_visualize5.png" alt="자연어처리_시각화-8321348"></p><p>위의 코드에서는 example_input_batch가 입력으로 들어가는데 코드 설명을 보면 (64, 16)의 크기이며 단어장 크기는 9000정도라고 한다. 또한 임베딩 차원은 256이라고 한다.</p><p>그럼 결국 다음과 같다.</p><ul><li>길이가 16인 시퀀스가 64개 있다. : 16개의 단어로 이뤄진 문장이 64개</li><li>(64, 16)인 이 입력텐서는 임베딩 레이어를 거치면 (64, 16, 9000) 이 된다.</li><li>임베딩 레이어의 파라미터 개수는 9000 * 256</li></ul><h3 id="4-코드분석-RNN-은닉층의-통과"><a href="#4-코드분석-RNN-은닉층의-통과" class="headerlink" title="4. 코드분석 - RNN 은닉층의 통과"></a>4. 코드분석 - RNN 은닉층의 통과</h3><p>원본 코드에서는 GRU를 사용했지만 보다 용이한 (나의)이해를 위해 사용하는 은닉층을 SimpleRNN으로 변경해보았다.</p><p>아까 위에서 임베딩 층을 통과하면서 (시퀀스 개수, 시퀀스 길이, 임베딩 차원) 으로 변환된 텐서는 RNN의 입력으로 들어가게 된다.</p><p><img src="/image/nlp_visualize1.png" alt="자연어처리_시각화-8321950"></p><p>그리고 은닉층을 통과한 텐서는 위의 그림처럼 변환되게 된다. 이때 <em>units</em> 은 <code>은닉층의 크기</code> 를 의미한다. 은닉층의 파라미터는 아래 그림과 같다.</p><ol><li><img src="/image/nlp_visualize2.png" alt="자연어처리_시각화-8322229"></li><li><img src="/image/nlp_visualize3.png" alt="자연어처리_시각화-8322259"></li></ol><p>1번 그림의 vocab_sz는 sequence length인데 바꾸기가 귀찮았다. 여튼 내가 이해한 것은 이랬고, 결국 두개를 합쳐서 그려보면 아래와 같아진다.</p><p><img src="/image/nlp_visualize4.png" alt="자연어처리_시각화-8322406"></p><p>중간의 (3, 6) 텐서가 현재시점의 은닉상태이다. 즉, hidden state의 shape은 (num of sequence, 은닉상태 크기) 이다.</p><h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><h3 id="1-클래스-설계-1"><a href="#1-클래스-설계-1" class="headerlink" title="1. 클래스 설계"></a>1. 클래스 설계</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BahdanauAttention</span><span class="params">(tf.keras.layers.Layer)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, units)</span>:</span></span><br><span class="line">    super(BahdanauAttention, self).__init__()</span><br><span class="line">    self.W1 = tf.keras.layers.Dense(units)</span><br><span class="line">    self.W2 = tf.keras.layers.Dense(units)</span><br><span class="line">    self.V = tf.keras.layers.Dense(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, query, values)</span>:</span></span><br><span class="line">    <span class="comment"># query hidden state shape == (batch_size, hidden size)</span></span><br><span class="line">    <span class="comment"># query_with_time_axis shape == (batch_size, 1, hidden size)</span></span><br><span class="line">    <span class="comment"># values shape == (batch_size, max_len, hidden size)</span></span><br><span class="line">    <span class="comment"># we are doing this to broadcast addition along the time axis to calculate the score</span></span><br><span class="line">    query_with_time_axis = tf.expand_dims(query, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># score shape == (batch_size, max_length, 1)</span></span><br><span class="line">    <span class="comment"># we get 1 at the last axis because we are applying score to self.V</span></span><br><span class="line">    <span class="comment"># the shape of the tensor before applying self.V is (batch_size, max_length, units)</span></span><br><span class="line">    score = self.V(tf.nn.tanh(</span><br><span class="line">        self.W1(query_with_time_axis) + self.W2(values)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># attention_weights shape == (batch_size, max_length, 1)</span></span><br><span class="line">    attention_weights = tf.nn.softmax(score, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># context_vector shape after sum == (batch_size, hidden_size)</span></span><br><span class="line">    context_vector = attention_weights * values</span><br><span class="line">    context_vector = tf.reduce_sum(context_vector, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context_vector, attention_weights</span><br></pre></td></tr></table></figure><h3 id="2-사용-1"><a href="#2-사용-1" class="headerlink" title="2. 사용"></a>2. 사용</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attention_layer = BahdanauAttention(<span class="number">10</span>)</span><br><span class="line">attention_result, attention_weights = attention_layer(sample_hidden, sample_output)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Attention result shape: (batch size, units) &#123;&#125;"</span>.format(attention_result.shape))</span><br><span class="line">print(<span class="string">"Attention weights shape: (batch_size, sequence_length, 1) &#123;&#125;"</span>.format(attention_weights.shape))</span><br></pre></td></tr></table></figure><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><h3 id="1-클래스-설계-2"><a href="#1-클래스-설계-2" class="headerlink" title="1. 클래스 설계"></a>1. 클래스 설계</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span><span class="params">(tf.keras.Model)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocab_size, embedding_dim, dec_units, batch_sz)</span>:</span></span><br><span class="line">    super(Decoder, self).__init__()</span><br><span class="line">    self.batch_sz = batch_sz</span><br><span class="line">    self.dec_units = dec_units</span><br><span class="line">    self.embedding = tf.keras.layers.Embedding(vocab_size, embedding_dim)</span><br><span class="line">    self.gru = tf.keras.layers.GRU(self.dec_units,</span><br><span class="line">                                   return_sequences=<span class="literal">True</span>,</span><br><span class="line">                                   return_state=<span class="literal">True</span>,</span><br><span class="line">                                   recurrent_initializer=<span class="string">'glorot_uniform'</span>)</span><br><span class="line">    self.fc = tf.keras.layers.Dense(vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># used for attention</span></span><br><span class="line">    self.attention = BahdanauAttention(self.dec_units)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x, hidden, enc_output)</span>:</span></span><br><span class="line">    <span class="comment"># enc_output shape == (batch_size, max_length, hidden_size)</span></span><br><span class="line">    context_vector, attention_weights = self.attention(hidden, enc_output)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x shape after passing through embedding == (batch_size, 1, embedding_dim)</span></span><br><span class="line">    x = self.embedding(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x shape after concatenation == (batch_size, 1, embedding_dim + hidden_size)</span></span><br><span class="line">    x = tf.concat([tf.expand_dims(context_vector, <span class="number">1</span>), x], axis=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># passing the concatenated vector to the GRU</span></span><br><span class="line">    output, state = self.gru(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output shape == (batch_size * 1, hidden_size)</span></span><br><span class="line">    output = tf.reshape(output, (<span class="number">-1</span>, output.shape[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output shape == (batch_size, vocab)</span></span><br><span class="line">    x = self.fc(output)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x, state, attention_weights</span><br></pre></td></tr></table></figure><h3 id="2-사용-2"><a href="#2-사용-2" class="headerlink" title="2. 사용"></a>2. 사용</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">decoder = Decoder(vocab_tar_size, embedding_dim, units, BATCH_SIZE)</span><br><span class="line"></span><br><span class="line">sample_decoder_output, _, _ = decoder(tf.random.uniform((BATCH_SIZE, <span class="number">1</span>)),</span><br><span class="line">                                      sample_hidden, sample_output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Decoder output shape: (batch_size, vocab size) &#123;&#125;'</span>.format(sample_decoder_output.shape))</span><br></pre></td></tr></table></figure><h2 id="The-optimizer-and-the-loss-function"><a href="#The-optimizer-and-the-loss-function" class="headerlink" title="The optimizer and the loss function"></a>The optimizer and the loss function</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">optimizer = tf.keras.optimizers.Adam()</span><br><span class="line">loss_object = tf.keras.losses.SparseCategoricalCrossentropy(</span><br><span class="line">    from_logits=<span class="literal">True</span>, reduction=<span class="string">'none'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span><span class="params">(real, pred)</span>:</span></span><br><span class="line">  mask = tf.math.logical_not(tf.math.equal(real, <span class="number">0</span>))</span><br><span class="line">  loss_ = loss_object(real, pred)</span><br><span class="line"></span><br><span class="line">  mask = tf.cast(mask, dtype=loss_.dtype)</span><br><span class="line">  loss_ *= mask</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tf.reduce_mean(loss_)</span><br></pre></td></tr></table></figure><h2 id="Checkpoints"><a href="#Checkpoints" class="headerlink" title="Checkpoints"></a>Checkpoints</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checkpoint_dir = <span class="string">'./training_checkpoints'</span></span><br><span class="line">checkpoint_prefix = os.path.join(checkpoint_dir, <span class="string">"ckpt"</span>)</span><br><span class="line">checkpoint = tf.train.Checkpoint(optimizer=optimizer,</span><br><span class="line">                                 encoder=encoder,</span><br><span class="line">                                 decoder=decoder)</span><br></pre></td></tr></table></figure><h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(inp, targ, enc_hidden)</span>:</span></span><br><span class="line">  loss = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    enc_output, enc_hidden = encoder(inp, enc_hidden)</span><br><span class="line"></span><br><span class="line">    dec_hidden = enc_hidden</span><br><span class="line"></span><br><span class="line">    dec_input = tf.expand_dims([targ_lang.word_index[<span class="string">'&lt;start&gt;'</span>]] * BATCH_SIZE, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Teacher forcing - feeding the target as the next input</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, targ.shape[<span class="number">1</span>]):</span><br><span class="line">      <span class="comment"># passing enc_output to the decoder</span></span><br><span class="line">      predictions, dec_hidden, _ = decoder(dec_input, dec_hidden, enc_output)</span><br><span class="line"></span><br><span class="line">      loss += loss_function(targ[:, t], predictions)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># using teacher forcing</span></span><br><span class="line">      dec_input = tf.expand_dims(targ[:, t], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  batch_loss = (loss / int(targ.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">  variables = encoder.trainable_variables + decoder.trainable_variables</span><br><span class="line"></span><br><span class="line">  gradients = tape.gradient(loss, variables)</span><br><span class="line"></span><br><span class="line">  optimizer.apply_gradients(zip(gradients, variables))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> batch_loss</span><br><span class="line">  </span><br><span class="line">  EPOCHS = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCHS):</span><br><span class="line">  start = time.time()</span><br><span class="line"></span><br><span class="line">  enc_hidden = encoder.initialize_hidden_state()</span><br><span class="line">  total_loss = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (batch, (inp, targ)) <span class="keyword">in</span> enumerate(dataset.take(steps_per_epoch)):</span><br><span class="line">    batch_loss = train_step(inp, targ, enc_hidden)</span><br><span class="line">    total_loss += batch_loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> batch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">      print(<span class="string">'Epoch &#123;&#125; Batch &#123;&#125; Loss &#123;:.4f&#125;'</span>.format(epoch + <span class="number">1</span>,</span><br><span class="line">                                                   batch,</span><br><span class="line">                                                   batch_loss.numpy()))</span><br><span class="line">  <span class="comment"># saving (checkpoint) the model every 2 epochs</span></span><br><span class="line">  <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    checkpoint.save(file_prefix = checkpoint_prefix)</span><br><span class="line"></span><br><span class="line">  print(<span class="string">'Epoch &#123;&#125; Loss &#123;:.4f&#125;'</span>.format(epoch + <span class="number">1</span>,</span><br><span class="line">                                      total_loss / steps_per_epoch))</span><br><span class="line">  print(<span class="string">'Time taken for 1 epoch &#123;&#125; sec\n'</span>.format(time.time() - start))</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://katie0809.github.io/2020/03/23/ai-study8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
